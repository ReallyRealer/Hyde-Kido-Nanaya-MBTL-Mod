btl_debPrint2( "\n>>> [btl_MakeChrTableFunc]" );

//参照されてると残るならとりあえずクローンしてみる
//テーブル内のテーブルとかに未対応だったのでちゃんと深いコピーに修正
function Battle_Std::CloneCopy( container )
{
	switch( typeof(container) )
	{
		case "table":
			local result = clone container;
			foreach( k,v in container)
			{
				result[k] = Battle_Std.CloneCopy(v);
			}
			return result;
		case "array":
			return clone container;
		default:
		return container;
	}
}

//tblにstdを上書きでくっつける(再帰あり)
function Battle_Std::MergeTable( tbl, std )
{
	//btl_debPrint2("\n"+ (typeof tbl=="table")? ("") : ("("+tbl+") ") );
	//btl_debPrint2("\nMergeTableStart\n");
	foreach(i, v in std) //i スロット名　v スロットの中身
	{
		if (!( i in tbl))	//見つかったMv(function i)がtblに無かったら追加
		{
			tbl[i] <- Battle_Std.CloneCopy(v);
			switch( typeof v )
			{
			case "table":	
				//btl_debPrint2(" デフォルト:"+format("%30s = %s \n",i,v.tostring()) );
				break;
			case "function":
				//btl_debPrint2(" デフォルト:"+format("%30s = %s \n",i,v.tostring()) );
				break;
			default:
				//btl_debPrint2(" デフォルト:"+format("%30s = %s \n",i,v.tostring()) );
				break;
			}
		}
		else //既にあった場合は…スロットの中をまわして個別に上書き
		{
			//vのtypeで分岐
			//print(format("[%s]",typeof v));
			switch( typeof v )
			{
			case "table":	
				//btl_debPrint2("\nMergeTableStart("+i+")\n");
				Battle_Std.MergeTable( tbl[i], v )
				break;
			case "function":
				//btl_debPrint2(" 定義済み　:"+i+"()\n" );				
				break;
			default:
				//btl_debPrint2(" 定義済み　:"+format("%30s = %s\n",i,v.tostring() ) );
				tbl[i] <- Battle_Std.CloneCopy(v);
				break;
			}
		}
	}
	//btl_debPrint2("MergeTableEnd\n\n");	
}

//tblにstdを上書きしないでくっつける(再帰あり)
function Battle_Std::InsertTable( tbl, std )
{
	//btl_debPrint2("\n"+ (typeof tbl=="table")? ("") : ("("+tbl+") ") );
	//btl_debPrint2("\nMergeTableStart\n");
	foreach(i, v in std) //i スロット名　v スロットの中身
	{
		if (!( i in tbl))	//見つかったMv(function i)がtblに無かったら追加
		{
			tbl[i] <- Battle_Std.CloneCopy(v);
			
			switch( typeof v )
			{
			case "table":	
				//btl_debPrint2(" デフォルト:"+format("%30s = %s \n",i,v.tostring()) );
				break;
			case "function":
				//btl_debPrint2(" デフォルト:"+format("%30s = %s \n",i,v.tostring()) );
				break;
			default:
				//btl_debPrint2(" デフォルト:"+format("%30s = %s \n",i,v.tostring()) );
				break;
			}
		}
		else //既にあった場合は…スロットの中をまわして個別に上書き
		{
			//vのtypeで分岐
			//テーブルだったら回して、それ以外なら上書き？
			//print(format("[%s]",typeof v));
			switch( typeof v )
			{
			case "table":	
			case "array": // array時も回すように変更 21/03/25
				//btl_debPrint2("\nMergeTableStart("+i+")\n");
				Battle_Std.InsertTable( tbl[i], v )
				break;
			case "function":
				//btl_debPrint2(" 定義済み　:"+i+"()\n" );				
				break;
			default:
				//btl_debPrint2(" 定義済み　:"+format("%30s = %s\n",i,v.tostring() ) );
				break;
			}
		}
	}
	//btl_debPrint2("MergeTableEnd\n\n");	
}


//コマンド作成作り直し
/*
・キャラクターのテーブルを作成(chr_tbl)
・const Std_CommandTable.CMN_CommandTable2を用意
・Std_CommandTable.CMN_CommandTable2の「Def_SCT_Common」フラグがあるスロットをchr_tblにコピー
・↑のtテーブルを回して、Std_CommandTable.CMN_CommandTable2に同名のスロットがないか探す
　あったら＞・同名のスロットをコピー
　　　　　　・その上にtの内容を上書き
　なかったら＞新規作成？

・chr_tblはテンプレ形式なのでコマンド用のテーブルに変換する？
・chr_tblテーブルを配列にしたものを作る
・配列をnumでソートする

・おわり
*/



//最終的にプログラムに渡すコマンドの配列を返す
//numの値でソートする
function Battle_Std::GetCommandTableFromTmpl( chr_tbl )
{
	local cmd = []; //最終コマンド配列
	
	//エラーチェック用
	local check_tbl = {};
	
	foreach(slot, val in chr_tbl) //i スロット名　v スロットの中身
	{
		//ベースの移植処理
		if( "basecommand" in val )
		{
			//_dpn("★★★ベース処理★★★★");
			if( val.basecommand in chr_tbl )
			{
				//_dpn("あった:"+val.basecommand );
				local tmp = chr_tbl[val.basecommand];
				
				foreach( s, v in tmp )
				{
					if( typeof v == "function" || typeof v == "table" )
					{
						local func_name = "Base_" + s;
						val[func_name] <- v;
						//_dpn("追加:"+func_name);
					}
				}
			}
		}
		
		if( !( "command" in val ) )
		{
			btl_debError_CharacterMake("【注意】おかしなコマンドなので無視"+slot);
			continue;
		}
		
		//
		local cmd_tbl = Battle_Std.GetCmdFromTmpl( val, slot ); //check関数足したりして、cmd形式のテーブルに変換
		
		//ここでエラーチェックする意味とは
		if( "num" in val )
		{
			if( val.num in check_tbl )
			{
				btl_debError_CharacterMake("【警告】同じ番号のnumがあります:"+slot+" num:"+val.num);
			}
			else
			{
				check_tbl[val.num] <- 1; //追加
			}
			//print("\n num:"+val.num);
		}
		else
		{
			btl_debError_CharacterMake("【警告】commandにnum指定がありません:"+slot);
		}
		cmd.append(cmd_tbl);
	}

	//numでソート
	cmd.sort(function(a, b) { return a.num > b.num ? 1 : a.num < b.num ? -1 : 0; });
	return cmd;
}

//CmdTmplに対して自動で不足パラメータとか追加してくれる
//おまじない的なやつ
local setDefault = function( tbl, slot, val )
{
	if( slot in tbl )
	{
	}
	else
	{
		tbl[slot] <- val;
	}
}

Battle_Std.SetCmdTmplAutoParams <- function( chr_tbl ) : (setDefault)
{
	foreach(slot, val in chr_tbl) //i スロット名　v スロットの中身
	{
		// _dpn("SCTAP:"+slot );
		if( "UpdateTable" in val )
		{
		
			if( "cmdparam" in val.UpdateTable )
			{
				//_dp("\n cmdparamあった:"+slot+" -> "+val.UpdateTable.cmdparam );
				val.UpdateTable.cmdparam = val.UpdateTable.cmdparam|Def_CMDP_ChrCommand;
			}
			else
			{
				// _dp("\n cmdparamなかった");
				val.UpdateTable.cmdparam <- Def_CMDP_ChrCommand;
			}
			
		}
		else
		{
			val.UpdateTable <- { name = "Mv_"+slot, cmdparam=Def_CMDP_ChrCommand };
			_dp("\n 自動でUpdateTableを作りました:"+slot);
		}
		
		if( "name" in val )
		{
		}
		else
		{
			val.name <- "Cmd_"+slot; //Cmdの名前
		}
		
		
		// コマンドテーブル自体が持つフラグ（自分自身が何者か）
		// コマンドチェック時に参照したりする（連打コンボのコマンドかどうかを見たり）
		if( "cmdflags" in val )
		{
		}
		else
		{
			val.cmdflags <- 0; // 初期値
		}
		val._GetCommandFlags <- function(){ return cmdflags }; // 上記の取得関数
		

		setDefault( val, "flags", 0 );
		
		//もし必殺技ならフラグを追加します
		if( slot.find("Skill")==0 )
		{
			local useFlags = ["lastdelay"]; // 追加したいフラグを入れ済みの使用予定フラグ
			
			if( typeof val.flags == "array" )
			{
				useFlags.extend( val.flags ); // useCmdFlagsを全部追加
			}
			else if( typeof val.flags == "string" )
			{
				useFlags.append( val.flags ); // 配列の要素として追加
			}
			else if( val.flags == 0 )
			{
			}
			else
			{
				btl_debError_CharacterMake("【警告】CmdFlagに変な値が入っている:"+slot );
			}
			val.flags = useFlags;
		}
		
		setDefault( val, "num", 0 );
		setDefault( val, "name", "Cmd_"+slot );
		setDefault( val, "flags", 0 );
		setDefault( val, "commandcheckmuki", 0 );
		if( !"command" in val )
		{
			_dpn("★command指定がないコマンドを登録しようとしています:"+slot );//流石にエラーなので警告だす
			setDefault( val, "command", 0 );
		}
		setDefault( val, "UpdateFrameID", 0 );
		setDefault( val, "SpGaugePlus", 100 );
		setDefault( val, "StdCombo", 0 );
		setDefault( val, "CmdTmplFlags", 0 );
		setDefault( val, "CmdTmplStdComboCnt", 0 );
		setDefault( val, "posstatus", _PosState_Ground );
	}
}


//Check関数を作成したり、tmplからまともなcmd形式に変換する
function Battle_Std::GetCmdFromTmpl( tmpl, tmpl_name="" )
{
	//デバッグ用処理
	if( Def_Dbg_LocalDebugMode )
	{
		local dbgf = {};
		dbgf.Check <- 				( "Check" in tmpl )? tmpl.Check : 0;
		dbgf.CmdStdCheck <-			( "CmdStdCheck" in tmpl )? tmpl.CmdStdCheck : 0;
		dbgf.CmdAfterCheck <-		( "CmdAfterCheck" in tmpl )? tmpl.CmdAfterCheck : 0;
		dbgf.Base_CmdCheck <- 			( "Base_CmdCheck" in tmpl )? tmpl.Base_CmdCheck : 0;
		dbgf.CmdCheck <- 			( "CmdCheck" in tmpl )? tmpl.CmdCheck : 0;
		dbgf.Base_CmdBeforeStdFunc <-	( "Base_CmdBeforeStdFunc" in tmpl )? tmpl.Base_CmdBeforeStdFunc : 0;
		dbgf.CmdBeforeStdFunc <-	( "CmdBeforeStdFunc" in tmpl )? tmpl.CmdBeforeStdFunc : 0;
		dbgf.CmdBeforeFunc <-		( "CmdBeforeFunc" in tmpl )? tmpl.CmdBeforeFunc : 0;
		dbgf.Base_CmdAfterStdFunc <-		( "Base_CmdAfterStdFunc" in tmpl )? tmpl.Base_CmdAfterStdFunc : 0;
		dbgf.CmdAfterStdFunc <-		( "CmdAfterStdFunc" in tmpl )? tmpl.CmdAfterStdFunc : 0;
		dbgf.CmdAfterFunc <-		( "CmdAfterFunc" in tmpl )? tmpl.CmdAfterFunc : 0;
		dbgf.CmdLastFunc <-			( "CmdLastFunc" in tmpl )? tmpl.CmdLastFunc : 0;
		
		if( dbgf.Check && ( dbgf.CmdStdCheck || dbgf.CmdAfterCheck || dbgf.CmdCheck || dbgf.CmdBeforeStdFunc || dbgf.CmdBeforeFunc || dbgf.CmdAfterStdFunc || dbgf.CmdAfterFunc || dbgf.CmdLastFunc ) )
		{
			btl_debError_CharacterMake("【警告】Checkと何かが被っている:"+tmpl_name );
		}
		if( dbgf.CmdCheck && ( dbgf.CmdStdCheck || dbgf.CmdAfterCheck ) )
		{
			btl_debError_CharacterMake("【警告】CmdCheckと何かが被っている:"+tmpl_name );
		}
		if( dbgf.CmdStdCheck && ( dbgf.CmdCheck || dbgf.CmdBeforeStdFunc || dbgf.CmdBeforeFunc || dbgf.CmdAfterStdFunc || dbgf.CmdAfterFunc || dbgf.CmdLastFunc ) )
		{
			btl_debError_CharacterMake("【警告】CmdStdCheckと何かが被っている:"+tmpl_name );
		}
	}
	
	local command_check = function() : (tmpl, tmpl_name)
	{
		if( "Check" in tmpl )
		{
			return tmpl.Check(); //これで全てやる用（本来のCheck関数の代わり）
		}
		else
		{
			//local timeobj = BMvDeb.ProcTimer(); // 生成＆計測開始
			//timeobj.SetName(tmpl_name);
			if( "Base_CmdBeforeStdFunc" in tmpl )
			{
				if( tmpl.Base_CmdBeforeStdFunc() == 0 )
				{
					return 0;
				}
			}
			if( "CmdBeforeStdFunc" in tmpl )
			{
				if( tmpl.CmdBeforeStdFunc() == 0 )
				{
					return 0;
				}
			}			
			if( "CmdBeforeFunc" in tmpl )
			{
				if( tmpl.CmdBeforeFunc() == 0 )
				{
					return 0;
				}
			}
			if( "Base_CmdCheck" in tmpl )
			{
				if( Battle_Std.CmdCheck(tmpl.Base_CmdCheck, tmpl_name) != 1 ) return 0;
			}
			if( "CmdCheck" in tmpl )
			{
				if( Battle_Std.CmdCheck(tmpl.CmdCheck, tmpl_name) != 1 ) return 0;
			}
			else
			{
				if( Battle_Std.CmdCheck({},tmpl_name) != 1 ) return 0;	
			}
			if( "Base_CmdAfterStdFunc" in tmpl )
			{
				if( tmpl.Base_CmdAfterStdFunc() == 0 )
				{
					return 0;
				}
			}
			if( "CmdAfterStdFunc" in tmpl )
			{
				if( tmpl.CmdAfterStdFunc() == 0 ) return 0;
			}
			if( "CmdAfterFunc" in tmpl )
			{
				if( tmpl.CmdAfterFunc() == 0 ) return 0;
			}
			if( "CmdLastFunc" in tmpl ) //これはＡ連打用なので手動では使わないこと
			{
				if( tmpl.CmdLastFunc() == 0 ) return 0;
			}
			//timeobj.End(); // 終了、ここまでの時間がコンソールに表示される
		}	
	}
	
	local ret = 
	{
		num = tmpl.num, //コマンド番号
		name = tmpl.name, //Cmdの名前
		commandcheckmuki = tmpl.commandcheckmuki,
		command = tmpl.command,
		flags = tmpl.flags,
		UpdateFrameID = tmpl.UpdateFrameID,
		SpGaugePlus = tmpl.SpGaugePlus,
		StdCombo = tmpl.StdCombo,
		CmdTmplFlags = tmpl.CmdTmplFlags,
		CmdTmplStdComboCnt = tmpl.CmdTmplStdComboCnt,
		posstatus = tmpl.posstatus,
	
		Check = function() : (tmpl, command_check)
		{
			if( command_check() == 0 ) return 0;
			//_dpn("Check:"+tmpl.name);
			return 1; // ここまでくれば出せる技
			//return ( Battle_Std.CmdCheck(v.CmdCheck) )
		},
		
		CheckAlive = function() : (tmpl, command_check)
		{
			//コマンドが成功して移行待ちになっている時に「全コマンドチェック前」に毎フレーム呼び出される
			//移行待ちがないときは経由しない
			//ヒットストップ中などに入力したものだけここを経由する
			//この枠は１つしかないので、1Fに１回のみ通過する
			//この枠は優先度が高いもので上書きされていく
			//入力時は発動できたけど、いざ出すタイミングになって本当にOKかチェックする
			
			if( command_check() == 0 ) return 0;
			//_dpn("CheckAlive:"+tmpl.name);

			return 1;
		}
		
		
		UpdateTable = tmpl.UpdateTable,
	}
	//_dp("\ntmpl_name:"+tmpl_name);
	//print(" - ret:update"+ret.UpdateTable.name);
	//if( tmpl_name=="Skill_0202A") 
	
	
	return ret;
}

function Battle_Std::MakeCommandTable( param={} )
{
	if( "command" in param )
	{
		local t = param.command;
		
		local chr_tbl = {}; // 最終的に使うキャラコマンドテーブル
		local cmn = Battle_Std.GetStdCommandTable(); // StdCommandTbl.txtのコマンドリスト
		
		// 超例外処理
		// 2CCを定義してるキャラの場合、標準コマンドのラピッドビートの定義の参照先を変える
		local change_rb1_command = 0; //RB1のコマンド参照先を変える	
		if( "Atk_2C_2C" in t ) // キャラ別コマンドで2CCがある
		{
			change_rb1_command = 1; // コマンドを変える
		}		
		
		//全キャラが持つ標準コマンドを追加
		foreach(i, v in cmn)
		{
			if( "cmdtmplflags" in v && v.cmdtmplflags&Def_SCT_Common ) 
			{
				btl_debPrint_CharacterMake("標準コマンドを追加:"+i);
				
				if( change_rb1_command && i == "Atk_RapidRelay" )
				{
					_dpn("ラピッドビート 2CC用の例外処理");
					chr_tbl[i] <- Battle_Std.CloneCopy( cmn.Atk_RapidRelay_2CC );
				}
				else if( i == "Atk_RapidRelay_2CC" )
				{
					//追加しない
				}
				else
				{
					chr_tbl[i] <- Battle_Std.CloneCopy(v);
				}
			}
		}
		
		//各キャラで定義してあるコマンドと同じものがStdCommandTblにあったらベースとしてコピー
		foreach(i, v in t) //i スロット名　v スロットの中身
		{
			if( i in cmn )
			{
				btl_debPrint_CharacterMake("tmplと同名のをコピー:"+i);
				chr_tbl[i] <- Battle_Std.CloneCopy( cmn[i] ); //tと同名のをコピー
			}
			else
			{
				btl_debPrint_CharacterMake("未定義コマンド:"+i);
			}	
		}
		
		if( Def_Dbg_LocalDebugMode )
		{
			//あってはいけない定義をチェック
			foreach( slot, val in chr_tbl )
			{
				if( "CmdBeforeFunc" in val || "CmdAfterFunc" in val )
				{
					_dpn("【警告】★stdcmdにキャラ関数エラー:"+slot);
				}
			}
			
			foreach( slot, val in t )
			{
				if( "CmdBeforeStdFunc" in val || "CmdAfterStdFunc" in val )
				{
					_dpn("【警告】★キャラcmdにStd関数エラー:"+slot);
				}
			}			
			
		}
		
		
		Battle_Std.MergeTable(chr_tbl, t); //tの内容を再帰的に上書きしていく
		Battle_Std.SetCmdTmplAutoParams( chr_tbl ); // chr_tblを仕上げる
		
		local retcmd = Battle_Std.GetCommandTableFromTmpl(chr_tbl);
		return retcmd;
	}
	else
	{
		_dpn("【警告】command定義がありません");
		return Battle_Std.GetCommandTableFromTmpl({});//一応空を返す
	}
	
}

function Battle_Std::MakeCommandTableUNI( param={} )
{
	if( "command" in param )
	{
		local t = param.command;
		
		local chr_tbl = {}; // 最終的に使うキャラコマンドテーブル
		local cmn = Battle_Std.GetStdCommandTable(); // StdCommandTbl.txtのコマンドリスト
		
		//全キャラが持つ標準コマンドを追加
		foreach(i, v in cmn)
		{
			if( "cmdtmplflags" in v && v.cmdtmplflags&Def_SCT_Common ) 
			{
				btl_debPrint_CharacterMake("標準コマンドを追加:"+i);
				
				chr_tbl[i] <- Battle_Std.CloneCopy(v);
			}
		}
		
		//各キャラで定義してあるコマンドと同じものがStdCommandTblにあったらベースとしてコピー
		foreach(i, v in t) //i スロット名　v スロットの中身
		{
			if( i in cmn )
			{
				btl_debPrint_CharacterMake("tmplと同名のをコピー:"+i);
				chr_tbl[i] <- Battle_Std.CloneCopy( cmn[i] ); //tと同名のをコピー
			}
			else
			{
				btl_debPrint_CharacterMake("未定義コマンド:"+i);
			}	
		}
		
		if( Def_Dbg_LocalDebugMode )
		{
			//あってはいけない定義をチェック
			foreach( slot, val in chr_tbl )
			{
				if( "CmdBeforeFunc" in val || "CmdAfterFunc" in val )
				{
					_dpn("【警告】★stdcmdにキャラ関数エラー:"+slot);
				}
			}
			
			foreach( slot, val in t )
			{
				if( "CmdBeforeStdFunc" in val || "CmdAfterStdFunc" in val )
				{
					_dpn("【警告】★キャラcmdにStd関数エラー:"+slot);
				}
			}
			
			foreach( slot, val in t )
			{
				// 623BorCにしないといけないのに623Bになってそうなのを探す
				if( slot.find("Skill")==0 && slot.find("B")==slot.len()-1 )
				{
					local seach_ex = slot.slice(0,slot.len()-1)+"EX";
					if( seach_ex in t )
					{
						_dpn("【警告】EXあるのにBorCになっていない:"+slot);
					}
				}
			}
			
		}
		
		
		Battle_Std.MergeTable(chr_tbl, t); //tの内容を再帰的に上書きしていく
		Battle_Std.SetCmdTmplAutoParams( chr_tbl ); // chr_tblを仕上げる
		
		local retcmd = Battle_Std.GetCommandTableFromTmpl(chr_tbl);
		return retcmd;
	}
	else
	{
		_dpn("【警告】command定義がありません");
		return Battle_Std.GetCommandTableFromTmpl({});//一応空を返す
	}
	
}

function Battle_Std::GetMoveTableFromTmpl( chr_tbl )
{
	local mv = {}; //最終Mvテーブル
	foreach(i_chr_tbl, v_chr_tbl in chr_tbl) //i スロット名　v スロットの中身
	{
		//print(format("見つかった:MV:%s Slot:%s\n ",i_chr_tbl.tostring(),v_chr_tbl.tostring()));
		//print( typeof v_chr_tbl );
		switch( typeof v_chr_tbl )
		{
		case "table": //行動テーブルだよ多分
			local t = Battle_Std.GetMvFromTmpl( v_chr_tbl, i_chr_tbl ); //mv形式のテーブルに変換
			mv[i_chr_tbl] <- Battle_Std.CloneCopy(t); //テスト
			break;	
		default://それ以外ならそのまま入れちゃう（関数とか）
			mv[i_chr_tbl] <- Battle_Std.CloneCopy(v_chr_tbl); //テスト		
			break;
		}		
	}

	return mv;
}

//Mvtmplのテーブルからmvを作成するところ
function Battle_Std::GetMvFromTmpl( tmpl, tmpl_name )
{
	local ret = {};
/*
	if(tmpl_name=="Skill_236X_236A")
	{
		print("?"+tmpl);
	}
	
*/

	//今のところユズリハ専用
	foreach( i, v in tmpl )
	{
		//integer BattouMv
		if( type( v )=="integer" )
		{
			//print("\n[テーブルに入れる]" + tmpl_name+" <- " + i);
			if( i in ret )
			{
				ret[i] = v;
			}
			else
			{
				ret[i] <- v;
			}
		}
	}

	if(!( "Init" in tmpl ))
	{
		local check = ( ( "Init_Before" in tmpl ) || ( "Init_Std" in tmpl ) || ( "Init_After" in tmpl ) );
		if( !check ) btl_debError_CharacterMake("【警告】Initがありません:"+tmpl_name);
	
		ret.Init <- function() : (tmpl,tmpl_name)
		{
			if( "Init_Before" in tmpl )
			{
				tmpl.Init_Before();
			}
			//tmplにInitStdがあったらInitの最初で呼ぶ
			if( "Init_Std" in tmpl )
			{
				//_dm("[Init_Std] "+tmpl_name);
				tmpl.Init_Std();
			}
			else
			{
				_dm("[Init_Stdなかった]"+tmpl_name);
				BMvTbl.SetMuki(_Direction_Auto);
				BMvTbl.SetPattern(0);
			}
			if( "Init_After" in tmpl )
			{
				//_dm("[Init_After]"+tmpl_name);
				tmpl.Init_After();
			}
		}	
	}
	else
	{
		ret.Init <- function() : (tmpl)
		{
			tmpl.Init();
		}
	}
	
	if(!( "Update" in tmpl ))
	{
		ret.Update <- function() : (tmpl)
		{
			if( "Update_Before" in tmpl ) tmpl.Update_Before();
			if( "Update_Std" in tmpl ) tmpl.Update_Std();
			if( "Update_After" in tmpl ) tmpl.Update_After();
		}	
	}	
	else
	{
		ret.Update <- function() : (tmpl)
		{
			tmpl.Update();
		}
	}
	
	if(!( "FrameUpdate" in tmpl ))
	{
		ret.FrameUpdate <- function() : (tmpl)
		{
			if( "Start_Std" in tmpl || "Start_After" in tmpl )
			{
				local mvs = BMvTbl.GetMvStatus();
				// _dpn("mvs.MvCount:"+mvs.MvCount+" call:"+mvs.FrameCallCount );
				if( mvs.MvCount == 3 && !Battle_Std.MoveCodeEx.CheckFlag( 3, def_MC3_AfterFrameUpdateStartTiming ) )
				{
					// _dpn("同時押し猶予終わり");
					Battle_Std.MoveCodeEx.DelFlag( 1, def_MC1_CmdLvDZ_OK );
					Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_AfterFrameUpdateStartTiming );
					if( "Start_Std" in tmpl )
					{
						tmpl.Start_Std();
					}
					if( "Start_After" in tmpl )
					{
						tmpl.Start_After();
					}
				}
			}

			if( "FrameUpdate_Before" in tmpl ) tmpl.FrameUpdate_Before();
			if( "FrameUpdate_Std" in tmpl ) tmpl.FrameUpdate_Std();
			if( "FrameUpdate_After" in tmpl ) tmpl.FrameUpdate_After();
		}	
	}		
	else
	{
		ret.FrameUpdate <- function() : (tmpl)
		{
			tmpl.FrameUpdate();
		}
	}

	if(!( "Finalize" in tmpl ))
	{
		local check = ( ( "Finalize_Before" in tmpl ) || ( "Finalize_Std" in tmpl ) || ( "Finalize_After" in tmpl ) );
		if( !check ) btl_debError_CharacterMake("【警告】Finalizeがありません:"+tmpl_name);
		
		ret.Finalize <- function() : (tmpl)
		{
			if( "Finalize_Before" in tmpl ) tmpl.Finalize_Before();
			if( "Finalize_Std" in tmpl ) tmpl.Finalize_Std();
			if( "Finalize_After" in tmpl ) tmpl.Finalize_After();
		}	
	}		
	else
	{
		ret.Finalize <- function() : (tmpl)
		{
			tmpl.Finalize();
		}
	}
	
	if(!( "HitInterrupt" in tmpl ))
	{
		ret.HitInterrupt <- function() : (tmpl)
		{
			if( "HitInterrupt_Before" in tmpl ) tmpl.HitInterrupt_Before();
			if( "HitInterrupt_Std" in tmpl ) tmpl.HitInterrupt_Std();
			if( "HitInterrupt_After" in tmpl ) tmpl.HitInterrupt_After();
			
			//XXX:仮
			local newFB = ("flags" in tmpl)? tmpl.flags&def_FBTmplFlags_NewTypeFireBall : 0;
			//※今、仮でfireballと通常の処理が別になっている
			if( !newFB )
			{
				if( "HitTiming" in tmpl )
				{
					if( Battle_Std.CheckHitTiming() )
					{
						tmpl.HitTiming();
					}
				}
				if( "DamageTiming" in tmpl )
				{
					if( Battle_Std.CheckDamageTiming() )
					{
						tmpl.DamageTiming();
					}
				}
				if( "GuardTiming" in tmpl )
				{
					if( Battle_Std.CheckGuardTiming() )
					{
						tmpl.GuardTiming();
					}
				}
			}
		}	
	}	
	else
	{
		ret.HitInterrupt <- function() : (tmpl)
		{
			tmpl.HitInterrupt();
		}
	}
	
	if(!( "LastUpdate" in tmpl ))
	{
		ret.LastUpdate <- function() : (tmpl)
		{
			if( "LastUpdate_Before" in tmpl ) tmpl.LastUpdate_Before();
			if( "LastUpdate_Std" in tmpl ) tmpl.LastUpdate_Std();
			if( "LastUpdate_After" in tmpl ) tmpl.LastUpdate_After();
		}	
	}	
	else
	{
		ret.LastUpdate <- function() : (tmpl)
		{
			tmpl.LastUpdate();
		}
	}
	


	return ret;
}

//-----------------------------------------------------------------------------
// Battle_Std::MakeMoveTable　※キャラのMvから呼ばれる
//-----------------------------------------------------------------------------
//Tmplとcmdを見てMvなtableを作成する
function Battle_Std::MakeMoveTable( t, cmd, _ChrNum = 0 )
{
	/*
	tとcmdから必要なMvリストを作成
	MvListから
	
	*/
	local mvlist = {}; //用意しとかないとエラーでちゃうmv一覧
	
	local func_CheckAdd_Slot = function( _slotname, _cmd, _mvlist )
	{
		if( _slotname in _mvlist )
		{
			if( _slotname in _cmd )
			{
				_mvlist[_slotname] = _cmd[_slotname];
			}
		}
		else
		{
			if( _slotname in _cmd )
			{
				_mvlist[_slotname] <- _cmd[_slotname];
			}
		}
	}

	//cmdから呼ばれるmvをリストアップ
	foreach(v in cmd) 
	{
		local mvname = v.UpdateTable.name; //cmdでUpdateTableで指定されたものを追加する
		if( !(mvname in mvlist) )
		{
			mvlist[mvname] <- {},
			mvlist[mvname].isDone <- true;
			if( "UpdateFrameID" in v )
			{
				mvlist[mvname].UpdateFrameID <- v.UpdateFrameID;		
			}
			if( "SpGaugePlus" in v )
			{
				mvlist[mvname].SpGaugePlus <- v.SpGaugePlus;		
			}
			if( "CmdTmplFlags" in v )
			{
				mvlist[mvname].CmdTmplFlags <- v.CmdTmplFlags;
			}
			if( "CmdTmplStdComboCnt" in v )
			{
				mvlist[mvname].CmdTmplStdComboCnt <- v.CmdTmplStdComboCnt;
			}
			btl_debPrint_CharacterMake("Cmdで定義されている:"+mvname);		
		}
		else
		{
			// func_CheckAdd_Slot( "isDone", true, mvlist[mvname] );
			func_CheckAdd_Slot( "UpdateFrameID", v, mvlist[mvname] );
			func_CheckAdd_Slot( "SpGaugePlus", v, mvlist[mvname] );
			func_CheckAdd_Slot( "CmdTmplFlags", v, mvlist[mvname] );
			func_CheckAdd_Slot( "CmdTmplStdComboCnt", v, mvlist[mvname] );
	
			btl_debPrint_CharacterMake("Cmdで定義されている２:"+mvname);		
		}
	}

	//Mvで定義されてるmvもリストアップ
	foreach(i,v in t) 
	{
		if( !(i in mvlist) ) //Cmdには無くてMvにだけあるSkillはきっと状態移行のみだよ
		{
			mvlist[i] <- 
			{
				isDone = true,
				SpGaugePlus = 0, //発動時のゲージ増加を無くす
				NoCmdMv = 1, //CmdにはないMv
			}
			btl_debPrint_CharacterMake("Mvで定義されている:"+i);
		}
		else //既に登録されてたらそのまま
		{
		
		}
	}

/*	
	foreach(i,v in mvlist) 
	{
		print("\n"+i);
	}	
*/	
	local mv = Battle_Std.MakeMoveTmpl(t,mvlist,_ChrNum);
	
	//これ上書きだからね！
	local stdmv = Battle_Std.GetStdMoveTable( _ChrNum );
	Battle_Std.MergeTable( mv, stdmv ); //tに標準Mvをぶっこみ、skillも入る
	
	if( Def_Dbg_LocalDebugScriptPath )
	{
		Battle_Std.DebugFunc.AddBtlDebugScript( mv );
	}
	
	local retmv = Battle_Std.GetMoveTableFromTmpl(mv); //tmplなのか判断しつつ変換してmv化
	
	Battle_Std.ErrorCheckMoveTable( retmv ); //エラーチェック
	
	return retmv;
}

// NPCキャラから呼ばれる
function Battle_Std::MakeNpcMoveTable( t )
{
	//一旦仮
	//TODO:NPCはNPC専用の標準MVだけくっつけるように仕様を変える
	_dpn("--- MakeNpcMoveTable Start");
	
	local stdmv = Battle_Std.GetStdNpcMoveTable();
	Battle_Std.MergeTable( t, stdmv ); //tに標準Mvをぶっこみ、skillも入る
	local retmv = Battle_Std.GetMoveTableFromTmpl(t); //tmplなのか判断しつつ変換してmv化
	// Battle_Std.ErrorCheckMoveTable( retmv ); //エラーチェック

	_dpn("--- MakeNpcMoveTable End");
	
	/*
	foreach( slot, val in retmv )
	{
		_dpn(slot);
	}
	*/

	return retmv;
}

//Mvに抜けがないかとか調べるくん
function Battle_Std::ErrorCheckMoveTable( mvlist )
{
	foreach(i,v in mvlist) 
	{
		local type = typeof v;
		
		if( type=="table" )
		{
			//print("\n"+i+" Initがねぇ"+type);
			local ExistInit = ( "Init" in v );
			local ExistFinalize = ( "Finalize" in v );
			
			if( !ExistInit )
			{
				btl_debError_CharacterMake("【警告】Initがねぇ:"+i);
			}
			if( !ExistFinalize )
			{
				btl_debError_CharacterMake("【警告】Finalizeがねぇ:"+i);
			}
		}
	}	
}

//Tmplを見てMvなtableを作成する
//作る時にMvに対してユニークIDを振り分けるとか…
// _ChrNum : キャラ番号
function Battle_Std::MakeMoveTmpl( t, mvlist, _ChrNum )
{
	//cdm_tmplのスロットでまわしてMvを生成、つっこむ
	local cmd_mvtmpl = {}; //cmdから予想されるMvtmplテーブル

	local pat_num_moon_skill = BMvEff.GetPatternNum( { datatype=1, pat="moon_skill" } );//事前に取得
	
	foreach(mvname,v in mvlist) //i スロット名　v スロットの中身
	{	
		local mv_tmpl = {};
		//i スロットの名前からどんなMvか判断してテンプレートを作成
		//Skill_〜 必殺技
		//Atk_〜 通常〜特殊技
		//local mvname = v.UpdateTable.name;
		
		if( mvname.find("Mv_Skill_") ==0 )
		{
			local pat = mvname.slice(9); //使うパターン名を取得　Mv_Skill_***
			local flags = 0; //tmplのフラグ設定
			local fgp = 0;
			//print("\n mvname:"+mvname+" pat:"+pat+" mvname.find(Mv_Skill_):"+mvname.find("Mv_Skill_")+" isGround:"+isGround );
			if( mvname in t )
			{
				local target_tmpl = t[mvname]; //該当tmplのテーブルの中身
				if( "usepat" in target_tmpl )
				{
					//print("\nしてあった");
					pat = target_tmpl.usepat;
				}
				if( "flags" in target_tmpl )
				{
					flags = target_tmpl.flags;
				}
				if( "fgp" in target_tmpl )
				{
					fgp = target_tmpl.fgp;
				}
			}

			// いろいろ作り直し
			//Mv名前からの検索結果
			local find = 
			{
				EX = mvname.find("EX"),
				SP = mvname.find("SP"),
				BC = mvname.find("BC"),
				LA = mvname.find("LastArc"),
				isLastEX = ( mvname.find("EX",(mvname.len()-2)) == mvname.len()-2 ),
				isLastSP = ( mvname.find("SP",(mvname.len()-2)) == mvname.len()-2 ),
				isLastBC = ( mvname.find("BC",(mvname.len()-2)) == mvname.len()-2 ),
				Add = mvname.find("_Add"),
				JAdd = mvname.find("_JAdd"),
				Hit = mvname.find("_Hit"),
				JHit = mvname.find("_JHit"),
				SkillJ = mvname.find("Mv_Skill_J"),
				// IWEXIST = mvname.find("IWEXIST"),
				IWEXIST = mvname.find("LastArc"),
				End = ( mvname.find("_End") || mvname.find("_GuardEnd") ),//大技用
			}

			local isAir = 0;//基本的に地上技
			if( flags&def_TmplFlags_Air )
			{
				//フラグ指定が何よりも重要
				isAir = 1;
			}
			else
			{
				if( find.JAdd != null )
				{
					isAir = 1;
				}
				else if( find.Add != null )
				{
					isAir = 0;
				}
				else if( find.SkillJ == 0 )
				{
					//_JAddも_Addもない場合はこれを見ます
					isAir = 1;
				}
			}
			
			local isGround = !isAir; // 地上の必殺技かどうか
			
			local isEX_Init = ( flags&def_TmplFlags_EX_Init ) || find.isLastEX; //ケツにEXがあるとEX技の始動(ヒット分岐は別)
			local isSP_Init = ( flags&def_TmplFlags_SP_Init ) || find.isLastSP; //ケツにSPがあるとSP技の始動(ヒット分岐は別)
			local isBC_Init = ( flags&def_TmplFlags_BC_Init ) || find.isLastBC; //ケツにBCがあるとBC技の始動(ヒット分岐は別)
			local JumpFrameID = 0;
			local isHit = ( flags&def_TmplFlags_Hit ) || ( find.Hit != null ) || ( find.JHit != null ); //ヒット時の状態移行（patは変化するけど）系 /* 0927 変更点 */
			local isAdd = ( flags&def_TmplFlags_Add ) || ( find.Add != null ) || ( find.JAdd != null ); //どっかにあったら追加コマンド扱い 

			local isEX = find.EX;//始動関係なくEX扱いかどうか
			local isSP = find.SP;//始動関係なくSP扱いかどうか
			local isLA = find.LA;//始動関係なくSP扱いかどうか
			local isBC = find.BC;//始動関係なくSP扱いかどうか

			local isSPEnd = (isSP && find.End);//大技の終了行動。ガードエンドもある。
			
			local isInit = ( isEX_Init || isSP_Init || isBC_Init || (!isHit && !isAdd) )? 1 : 0;
			
			
			local setMvCode = def_MC_Skill;
			if( isEX_Init || isEX )
			{
				setMvCode = def_MC_Skill|def_MC_EXAction;
			}
			if( isSP_Init || isSP )
			{
				setMvCode = def_MC_Skill|def_MC_SPAction;
			}
			if( isBC_Init || isBC )
			{
				setMvCode = def_MC_Skill|def_MC_BCAction;
			}
			
			//インフィニットワースイグジストもSPアクション
			//専用処理が多く共通のカットインとか不要なので、isSP_Initはつけない（多分）
			if( find.IWEXIST != null )
			{
				setMvCode = def_MC_Skill|def_MC_SPAction;
			}
			
			// ボイス定義
			// この名前の音声を呼び出す
			local Voice = {};
			Voice.Init <- mvname+"_Init";
			Voice.FU <- mvname+"_FU";
			
			//isGroundが最初のSkillを見てるので、後ろから見てって再確認
			//Mv_Skill_J214_214A は地上技
			//Mv_Skill_J214_Hit は地上技　…！？
			//Mv_Skill_J214_J214A は空中技
			//XXX:ここの処理、今は「Mv_Skill_J214_JAdd214A」と記述するので不要

			/*
			for(local i=mvname.len(); i>0; i--)
			{
				local pos = mvname.find("_",i);
				
				if( pos )
				{
					
					local str = mvname.slice(pos+1)
					//print("\nみつけた i:"+i+" pos;"+pos+" "+str+" ");
					if( isGround != (str.find("J")!=0) ) _dpn("★★★なんかおかしい！！！★★★");
					
					isGround = (str.find("J")!=0); //Jからはじまるなら空中技やろ！
					break;
				}
				//print(i+" ");
			}
			*/
			
			if("UpdateFrameID" in v)
			{
				//print("\nあった"+v.UpdateFrameID+"\n");
				if( v.UpdateFrameID != 0)
				{
					JumpFrameID = v.UpdateFrameID;
				}
			}
			local SpGaugePlus = def_SC_SkillInit_Plus;
			
			if("SpGaugePlus" in v) //ゲージ増加率の指定があったら(0-100)
			{
				SpGaugePlus = SpGaugePlus * v.SpGaugePlus/100;
			}
			if( SpGaugePlus==0 )
			{
				//print("\nゲージ増加の無いMv:"+mvname);
			}
			
			btl_debPrint_CharacterMake("name:"+mvname+" pat:"+pat+" id:"+JumpFrameID+" 地上:"+isGround+" EX:"+isEX_Init);
			//print("?"+mvname.find("EX",(mvname.len()-2))+" len:"+mvname.len()+"\n");
			
			//0:デバッグオフ パターン番号(0〜999):ヒット-1:パターンなし、-2:フレームなし（指定時のみ）
			if( JumpFrameID || flags&def_TmplFlags_ChangeStatusOnly ) //パターン指定ではなくFrameID変化のみのMvもしくは状態移行
			{
			}
			else
			{
				//print("\n pat:"+pat);
				//local ret = BtlMvStd.CheckHan6Data( { pat=100 } );
				local ret = BtlMvStd.CheckHan6Data( { pat=pat } );
				if( ret < 0 ) //パターンが無い
				{
					//デバッグ時のみの処理
					if( Def_Dbg_LocalDebugMode )
					{
						if( mvname in t )
						{
							if( "Init" in t[mvname] )
							{
								//print("\nでもInitがあるね")
							}
							else
							{
								_dp("\n【警告】Tmplから作ったMv用のパターンが存在しません "+pat+" ret:"+ret);
							}
						}
						else
						{
							_dp("\n【警告】 "+mvname+"がTmplに無いです");
						}
					}
				}
				else if( typeof pat == "string" )
				{
					local pat_num = BMvEff.GetPatternNum( { datatype=0, pat=pat } ); // パターン文字列のパターン番号を事前取得
					pat = pat_num; // 番号に差し替え
				}
			}
			
			local furimuki = !(isHit || isAdd || flags&def_TmplFlags_NoFurimuki ); //振り向き処理をやるかどうか(ヒット状態移行か追加コマンドだとやらない) //ver1.03
			//local furimuki = !(isAdd); //振り向き処理をやるかどうか(追加コマンドだとやらない) //ver1.01 ver1.02
			
			//CmdTmplFlags
			//スマートステアのアナウンス
			local smart_stear = 0;
			if( "CmdTmplFlags" in v )
			{
				if( Def_Rule_StdSmartSteer && v.CmdTmplFlags & def_CMDFlags_AnnounceSmaetSteer )
				{
					smart_stear = 1;
				}
				else if( Def_Rule_CroSmartSteer && v.CmdTmplFlags & def_CMDFlags_AnnounceSmaetSteerCro )
				{
					smart_stear = 2;
				}
				else if( Def_Rule_AirSmartSteer && v.CmdTmplFlags & def_CMDFlags_AnnounceSmaetSteerAir )
				{
					smart_stear = 3;
				}
			}
			
			local isNM = (!isEX && !isSP && !isLA && !isBC)? 1 : 0;
			
			//Mvに自動で設定するパラメータ
			local preParam =
			{
				pat = pat, // パターン番号
				JumpFrameID = JumpFrameID, // 0以外ならパターンジャンプせずにFrameIDジャンプ

				SpGaugePlus = SpGaugePlus, // 必殺技空振りでのSPゲージ増加量
				isGround = isGround, // 地上必殺技かどうか
				isAir = !isGround, // 空中必殺技かどうか
				isInit = isInit,
				isSP_Init = isSP_Init, // SP技の発動かどうか
				isEX_Init = isEX_Init, // EX技の発動かどうか
				isBC_Init = isBC_Init, // BC技の発動かどうか
				isEX = isEX, // EX技扱いかどうか
				isSP = isSP, // SP技扱いかどうか
				isBC = isBC, // BC技扱いかどうか
				isLA = isLA, // LA技扱いかどうか
				isNM = isNM, // 上記以外かどうか
				furimuki = furimuki, // 相手の方を振り向くかどうか
				Voice = Voice, // ボイス定義
				setMvCode = setMvCode, // Mvに指定するMvCode0
				smart_stear = smart_stear, // スマートステアアナウンスタイミングかどうか

				addcomborate = ( flags&def_TmplFlags_NoAddComboRate )? 0 : 1, // 発動時にコンボレートを加算するかどうか
				enable_doujicancel = ( flags&def_TmplFlags_DoujiCancelOK )? 1 : 0, // 同時押しキャンセルを認めるMvか
				enable_ReversalInfo = ( flags&def_TmplFlags_NoDrawReversalInfo )? 0 : 1, // リバーサル表記を出すか
				noClearVector = ( flags&def_TmplFlags_NoClearVector )? 1 : 0, // 発動時にベクトル初期化をしないか
				isMuteki = ( flags&def_TmplFlags_Muteki )? 1 : 0, // 無敵技扱いにするか　※未使用
				noSurinuke = ( flags&def_TmplFlags_NoSurinuke )? 1 : 0, //すり抜けない処理を入れるか
				noSousai = ( flags&def_TmplFlags_NoSousai )? 1 : 0, //相殺判定との相殺処理

				isHit = isHit,
				isAdd = isAdd,
				isSparkDisableAttak = ( isEX || isSP )? 1 : 0,
				fgp = fgp,
				isSPEnd = isSPEnd, // 大技のヒットorガードの終了行動かどうか
				
				moonskill_effpos = { x=0, y=-200 }, // ムーンスキルのエフェクト座標
			}
			//技のタイプを分類(しばらくデバッグ用に使う）
			local skillType = "技種："; 
			if( !preParam.isGround ) skillType += "【空中】";
			if( isSP_Init ) skillType += "【SP発動】";
			if( isEX_Init) skillType += "【EX発動】";
			if( isHit ) skillType += "ヒット分岐";
			if( isAdd ) skillType += "追加技";
			
			//ムーンスキルのエフェクト座標
			if( _ChrNum == Def_ChrNo_Chr019 ) // ネコアルク
			{
				preParam.moonskill_effpos.y = -120; // キャラが小さすぎるので座標調整
			}
			
			//コンボレート加算タイミング
			//上や下で似たようなチェックがあるけど念のため整理
			if( flags&def_TmplFlags_NoAddComboRate || flags&def_TmplFlags_ChangeStatusOnly || preParam.isHit )
			{
				preParam.addcomborate = 0;
			}
			
			//Init_Std
			if( flags&def_TmplFlags_ChangeStatusOnly ) //状態の移行のみのtmplだった
			{
				mv_tmpl.Init_Std <- function() : (preParam, skillType)
				{
					_dpn(skillType);
					
					Battle_Std.TypeSE_Play({ type=preParam.Voice.Init }); //発動ボイス
					
					Battle_Std.MoveCode.AddFlag( preParam.setMvCode ); // 行動コード(必殺技)を設定
					if( !preParam.isGround )
					{
						Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_AirSkill );
					}
					Battle_Std.InitAtkSkillMv(); // 通常技や必殺技の共通初期化
					Battle_Std.InitSkillMv();

					// Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_SidouHitSkill ); // 始動であてた技フラグをたてる
					
					Battle_Std.PassHitMoveCodes(); // ヒット分岐でのMvCode引継ぎ
					
					Battle_Std.SetVsAtkValueFromMvActionCode(); // MvActionCodeを見てVSダメージ削り値を設定
				}
			}
			else
			{
				mv_tmpl.Init_Std <- function() : (preParam, skillType, pat_num_moon_skill)
				{
					// _dpn(skillType);
					
					// 追加技のとき
					if( preParam.isAdd )
					{
						Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_AddMv );
						Battle_Std.PassAddSkillMoveCodes();
						
						if( Battle_Std.ChangeMoveCodeEx_CheckFlag( 4, def_MC4_SkillVecAdded ) )
						{
							_dpn("追加技で前の行動でベクトル加算をしていたのでスキルボーナスを行動側で予約");
							Battle_Std.MoveCodeEx.AddFlag( 5, def_MC5_SmallSkillBonusYoteiMv );
						}
					}					
					
					if( Def_Dbg_LocalDebugMode )
					{
						if( Def_Dbg_LocalDebugScriptPath ) //ローカル環境でのデバッグ時
						{
							Battle_Std.DebugFunc.CallCheckFightingGameParams( preParam.fgp );
						}
					}
					
					if( preParam.isEX )
					{
						// _dpn("★EX");
						BMvTbl.SetMvAction( def_MVA_EXSkill );
						
						BMvTbl.SetVsAtkValue( { type=0, val=def_SVAV_EXSkill, time=9999, flag=_ClearFlag_ChangeMv } );
					}
					else if( preParam.isSP )
					{
						// _dpn("★SP");
						BMvTbl.SetMvAction( def_MVA_SPSkill );
						Battle_Std.MoveCodeEx.AddFlag( 5, def_MC5_ArcDriveSkill );
						
						BMvTbl.SetVsAtkValue( { type=0, val=def_SVAV_SPSkill, time=9999, flag=_ClearFlag_ChangeMv } );
					}
					else if( preParam.isLA )
					{
						// _dpn("★LA");
						BMvTbl.SetMvAction( def_MVA_LASkill );
						
						BMvTbl.SetVsAtkValue( { type=0, val=def_SVAV_LASkill, time=9999, flag=_ClearFlag_ChangeMv } );
					}
					else if( preParam.isBC )
					{
						// ヒスコハでも同じ処理あり
						// _dpn("★BC");
						BMvTbl.SetMvAction( def_MVA_BCSkill );
						
						local moonVsAtkVal = ( Def_Sys_BossChara_MoonSkillVsAtkType && BMvCore.GetBossFlag() != 0 )? def_SVAV_NmSkill : def_SVAV_BCSkill; // ボスMSが強すぎる問題対策
						BMvTbl.SetVsAtkValue( { type=0, val=moonVsAtkVal, time=9999, flag=_ClearFlag_ChangeMv } );
					}
					else
					{
						BMvTbl.SetMvAction( def_MVA_None );
						BMvTbl.SetVsAtkValue( { type=0, val=def_SVAV_NmSkill, time=9999, flag=_ClearFlag_ChangeMv } );
					}
					
					// _dpn("EXInit:"+preParam.isEX_Init+" isGround:"+preParam.isGround+" isAdd:"+preParam.isAdd+" isHit:"+preParam.isHit );
					
					if( Def_Dbg_LocalDebugMode ) //ローカル環境でのデバッグ時
					{
						if( Def_Dbg_TmplMoveLog ) _dp1p("\n setMvCode:"+preParam.setMvCode+" isGround:"+preParam.isGround+" furimuki:"+preParam.furimuki);
					
						if( !preParam.isHit ) // ヒット分岐でのフレーム測定は不要
						{
							if( Def_Dbg_LocalDebugScriptPath ) //ローカル環境でのデバッグ時
							{
								Battle_Std.DebugFunc.CallAtkInitScript();
							}
						}
					}
					
					//ずらしおしを考慮してアナウンスは呼ばないこと
					
					if( preParam.isGround )
					{
						if( !preParam.noClearVector ) Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
						if( preParam.furimuki ) BMvTbl.SetMuki(_Direction_Auto); //ヒット状態移行か追加コマンド以外なら振り向く
					}
					else
					{
						//空中
						Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_AirSkill );
						
						if( preParam.isInit )
						{
							Battle_Std.SetNormalXVecLimit( 2000 );// Xベクトルに制限
						}
					}
					Battle_Std.Reversal.CheckTime_DrawInfo( preParam.enable_ReversalInfo ); // リバーサルなら文字表示
					
					Battle_Std.ClearHitStatus_SetChangeMv(); // ヒット情報のクリア
					
					//パターンを変更した後の処理
					if( preParam.JumpFrameID )
					{
						BMvTbl.JumpFrameID(preParam.JumpFrameID)
					}
					else
					{
						BMvTbl.SetPattern(preParam.pat);
					}
					
					if( !Def_Sys_ComboRateSetStartTiming && preParam.addcomborate && !preParam.isHit )
					{
						//_dp1p("\n ★必殺技でコンボレート加算★");
						BMvTbl.AddComboRate(); // コンボレート加算
					}

					if( preParam.isSP_Init )
					{
						if( !preParam.isAdd )
						{
							Battle_Std.InitWorthSkill(); //SPゲージ消費・カットイン呼び出し
						}
					}
					else if( preParam.isEX_Init )
					{
						if( !preParam.isAdd )
						{
							Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
							BMvEff.SetPlayerTimer( { muteki_nage=3, muteki_nageX=3 } ); //EX必殺技は雑に固定の投げ無敵
						}
						Battle_Std.PcAfterImage_EXSkillInit();
					}
					else if( preParam.isBC_Init )
					{
						if( !preParam.isAdd )
						{
							local eff = BMvEff.CreateObject( { datatype=1, start_pat=pat_num_moon_skill, x=preParam.moonskill_effpos.x*128, y=preParam.moonskill_effpos.y*128 } );
							
							Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
							
							Battle_Std.SetFromNoCancelFlag2(); // 生出しフラグ立て
						}
					}
					else
					{
						//EXやSPの発動以外は同時押しを許容する
						//XXX:preParam.enable_doujicancelのチェックがない
						Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
					}
					Battle_Std.TypeSE_Play({ type=preParam.Voice.Init }); //発動ボイス
					//_dm("?"+preParam.Voice.Init);
					
					if( preParam.isEX_Init || preParam.isSP_Init || !preParam.isGround )
					{
						if( !preParam.noClearVector )
						{
							BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_DivKeep } ); //暗転技も慣性は残さない方向で
						}
					}
					if( preParam.SpGaugePlus>0 && !( preParam.isEX_Init || preParam.isSP_Init ) ) //ゲージ増加指定がある、かつEXorSP以外( CmdにないMvの場合SpGaugePlusは0になる )
					{
						BMvEff.SetSpGauge( { value=preParam.SpGaugePlus, limitval=25 } ); //EX・SPじゃなけりゃ発動時にSP増加予約
					}
					//BMvTbl.ClearCommand(); //必殺技はコマンドバッファクリアする　※これをやるとタメコマンドとかも消えるので使ってはいけない
					Battle_Std.MoveCode.AddFlag( preParam.setMvCode ); // 行動コード(必殺技)を設定
					Battle_Std.InitAtkSkillMv(); // 通常技や必殺技の共通初期化
					Battle_Std.InitSkillMv();
					if( !preParam.noSousai )
					{
						Battle_Std.Sousai.Init(); //相殺情報を初期化
					}
					
					if( preParam.enable_doujicancel ) // 同時押しのキャンセルを認める
					{
						Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
					}
					
					Battle_Std.AddMoveCode_CSAntenGaesiSkill(); // CSからの暗転返しで出した技ならフラグを立てる
					
					// if( preParam.isHit && !preParam.addcomborate )
					if( preParam.isHit )//XXX:addcomborateのチェックはなぜ必要だった？
					{
						//_dp("\n ヒット分岐っぽいのでフラグ引継ぎ");
						Battle_Std.PassHitMoveCodes(); // ヒット分岐でのMvCode引継ぎ
					}
					
					//
					if( preParam.isSparkDisableAttak ) // LastUpdateと条件が同じじゃないとダメ
					{
						// _dpn("スパーク不可");
						// XXX:バーストなしにしたので
						// BMvTbl.SetSparkDisableAttack(1);// ヒットしたらスパーク不可の技
					}
					
					//相殺関係
					if( preParam.isSP )
					{
						//未設定＝相殺しない
					}
					else if( preParam.isEX )
					{
						BMvTbl.SetSkillLv( def_MVSL_SkillEx );
					}
					else if( preParam.isBC )
					{
						BMvTbl.SetSkillLv( def_MVSL_SkillMs );
					}
					else
					{
						BMvTbl.SetSkillLv( def_MVSL_SkillNm );
					}
					
					//未使用なので入ってこない
					if( preParam.isMuteki )
					{
						Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_Muteki );
						BMvTbl.SetSkillLv(def_MVSL_Invincibility);//無敵技同士でのみ相殺
					}
					
					// エフェクト座標
					BMvTbl.SetPP(def_PP_SkillEffecType,0);
					BMvTbl.SetPP(def_PP_SkillEffectPos_X,0);
					BMvTbl.SetPP(def_PP_SkillEffectPos_Y,0);
					
					// 技のInitタイミングでベクトル加算のフラグがなかったらスキルボーナス初回の技として記憶
					// 飛び道具呼び出し時や設置起爆タイミング（手動）でもフラグは更新される
					if( !Battle_Std.EnemyDamageFlag_Check( def_DF_SkillVecAdded ) )
					{
						Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_NoDFSkillVecAdded );// Init時点では初回だったMv
					}
				}
			}
			
			//FrameUpdate_Std
			mv_tmpl.FrameUpdate_Std <- function() : (preParam)
			{
				Battle_Std.TypeSE_Play({ type=preParam.Voice.FU }); //発動ボイス
				
				// ムーンスキルの発生をムーンドライブ中かどうかで変化させる
				// SetPatternを多重にやってパターンの進みを遅くする
				if( Def_Sys_MoonDriveMonnSkill_ChangeActiveDelay )
				{
					if( !Battle_Std.MoonDrive_IsActive() )
					{
						if( preParam.isBC_Init )
						{
							if( BMvTbl.GetMvStatus().MvCount <= (Def_Sys_MoonDriveMonnSkill_ChangeActiveDelay-1) )
							{
								_dpn("発生遅延:"+Def_Sys_MoonDriveMonnSkill_ChangeActiveDelay);
								BMvTbl.SetPattern(preParam.pat);
							}
						}
					}
				}
				
				
				//EX技のエフェクト関係の情報をセット
				if( preParam.isEX_Init && !Battle_Std.PP_CheckFlag( def_PP_SkillEffecType, def_PP_SET_FindEffectPos ) )
				{
					// エフェクト座標
					local rc0 = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool } );
					
					if( rc0.sx != _Hantei_Error ) // 存在するか
					{
						Battle_Std.PP_AddFlag( def_PP_SkillEffecType, def_PP_SET_FindEffectPos );//エフェクトあった
						
						BMvTbl.SetPP(def_PP_SkillEffectPos_X,rc0.sx);
						BMvTbl.SetPP(def_PP_SkillEffectPos_Y,rc0.sy);

						local rc1 = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 1 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool } );
						//暗転中進む
						if( rc1.sx != _Hantei_Error ) // 存在するか
						{
							Battle_Std.PP_AddFlag( def_PP_SkillEffecType, def_PP_SET_AntenMove );//暗転中進むタイプ
						}
					}
				}
				
				//EXの暗転処理関係
				if( preParam.isEX_Init && !Battle_Std.PP_CheckFlag( def_PP_SkillEffecType, def_PP_SET_CalledEffect ) ) // エフェクトをよんでない
				{
					if( Battle_Std.MoveCodeEx.CheckFlag( 3, def_MC3_AfterFrameUpdateStartTiming ) ) //Startの後（コスト消費後？）
					{
						if( Battle_Std.PP_CheckFlag( def_PP_SkillEffecType, def_PP_SET_FindEffectPos ) ) // 特殊判定0を発見済みならその座標に出す
						{
							// 暗転のエフェクトの設定
							local cutinGrpParam = { x=0, y=-200, frame=def_FL_EXCutinBGChangeTime };
							cutinGrpParam.x = BMvTbl.GetPP(def_PP_SkillEffectPos_X);
							cutinGrpParam.y = BMvTbl.GetPP(def_PP_SkillEffectPos_Y);

							// 暗転のタイプによって処理が変わる
							if( Battle_Std.PP_CheckFlag( def_PP_SkillEffecType, def_PP_SET_AntenMove ) )
							{
								// _dpn("暗転中進む");
								Battle_Std.SetSkillStopTime(def_FL_EXCutinStopTime); //時間停止
							}
							else
							{
								// _dpn("暗転中進まない");
								BMvEff.SetStopTime( { time=def_FL_EXCutinStopTime, stopme=2, bounderase=1 } ); //時間停止
								
								Battle_Std.CallAntenStopObject();
								if( Def_Sys_EXCutinNageMuteki )
								{
									BMvEff.SetPlayerTimer( { muteki_nage=Def_Sys_EXCutinNageMuteki, muteki_nageX=Def_Sys_EXCutinNageMuteki } ); // 投げ無敵だけつける
								}
							}
							
							// 暗転する時にカットインを入れる処理
							Battle_Std.PP_AddFlag( def_PP_SkillEffecType, def_PP_SET_CalledEffect ); //エフェクトを呼んだ
							
							Battle_Std.SetEXCutinCameraFocus( def_FL_EXCutinStopTime );
							Battle_Std.SetEXCutinGrp( cutinGrpParam );
						}
					}
				}
				
				// local no_sousai = (preParam.fgp&(Def_FGP_CommandThrow|Def_FGP_MoveAction));//相殺出さない条件
				local no_sousai = (preParam.fgp&Def_FGP_MoveAction);//相殺出さない条件
				if( preParam.noSousai )
				{
					no_sousai = 1; // 相殺処理を一切しない
				}
				
				// if( !Battle_Std.MoveCodeEx.CheckFlag( 0, def_MC_BCAction ) && !no_sousai )
				// 必殺技　相殺判定がついていたら普通に相殺する
				// ムーンスキル　1Fから相殺判定がついているが、有効にするのはムーンドライブ中のみ
				if( !no_sousai )
				{
					local isMoonSkillCmdInit = ( preParam.isBC_Init && !preParam.isAdd );//ムーンスキル（発動エフェクトが出るもの。要するに派生やヒット分岐は含まない）
					
					if( isMoonSkillCmdInit )
					{
						local sousai_ok_frame = 1;

						if( Def_Sys_MoonDriveSousai_DisableAirMoonSkill && preParam.isAir )
						{
							// _dpn("空中ムーンスキルは無効");
							sousai_ok_frame = 0;
						}
						
						if( Def_Sys_MoonDriveSousai_EnableActiveFrame )
						{
							if( BMvTbl.GetMvStatus().MvCount > Def_Sys_MoonDriveSousai_EnableActiveFrame)
							{
								sousai_ok_frame = 0; //10F以降は判定があっても相殺をつけない
							}
							
							if( Def_Sys_MoonDriveSousai_DisableEnemyAntenStop )
							{
								if( Battle_Std.MoveCodeEx.CheckFlag( 3, def_MC3_OnceEnemyAntenStop ) )
								{
									_dpn("被暗転による相殺消滅");
									sousai_ok_frame = 0;
								}
							}
						}
						if( Battle_Std.MoonDrive_IsActive() && sousai_ok_frame )
						{
							Battle_Std.Sousai.FrameUpdate();
						}
						else
						{
							Battle_Std.Sousai.Erase(); // 相殺しない
						}
					}
					else
					{
						Battle_Std.Sousai.FrameUpdate();
					}
				}
				
				// 無敵状態かどうかを見てフラグを立てたりアナウンスを出したりする
				
				if( !Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_MutekiAnnounce ) && !Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_NoMutekiAnnounce ) )
				{
					local cmdParam = BMvTbl.GetCmdParam(0);
					if( preParam.isHit || !(cmdParam&Def_CMDP_ChrCommand) || BMvCore.GetCaptureCharaData().isdone() )
					{
						//ヒット分岐は除外
						//コマンドを入れてない（自動で派生）
						//つかみ状態
						//上記は無敵アナウンスが不要なので出し済みにしてしまう
						// Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_MutekiAnnounce );
						Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_NoMutekiAnnounce );
					}
					else
					{
						if( Battle_Std.CheckDagekiMuteki() )
						{
							local mvs = BMvTbl.GetMvStatus();
							if( mvs.MvCount <= 3 && Battle_Std.ChangeMoveCodeEx_CheckFlag( 4, def_MC4_AtemiSousaiSuccess ) && BMvEff.GetPlayerMuteki( 0 ) )
							{
								// _dpn("ここは耐える"); // 3F待つ必要はないかもだが一応保険
							}
							else
							{
								//でかかりは同時押しなどがあるので除外するが、フラグはつける
								Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_Muteki );
								BMvTbl.SetSkillLv(def_MVSL_Invincibility);//無敵技同士でのみ相殺
							}
						}
						
						if( Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_Muteki ) )
						{
							local mvs = BMvTbl.GetMvStatus();
							if( mvs.MvCount >= 3 )
							{
								Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_MutekiAnnounce );
								BMvTbl.SetSkillLv(def_MVSL_Invincibility);//無敵技同士でのみ相殺
								
								//アナウンス
								BMvEff.AttackInfoString_Set({ word=def_AISW_Invincibility,} );
							}
						}
					}
				}
				
				//BC技のキャラフラッシュ処理
				//60F持続するけど、他で上書きされないように毎フレーム設定する
				//月ゲージの残量が空になると、光加減は変わる
				if( preParam.isBC_Init )
				{
					Battle_Std.UpdateMoonSkillEffect(1);
				}
				
				//
				if( Def_Sys_FastSkillVecPosShift && preParam.noSurinuke && !Battle_Std.CheckEnemyisDamage() )
				{
					Battle_Std.PosShiftFastVector(); // すり抜けないように座標調整
				}
			}
			
			//Update_Std
			mv_tmpl.Update_Std <- function()
			{
				BMvTbl.SetPP(def_PP_SkillUpdateVal,0);
			}
			
			//Start_Std
			mv_tmpl.Start_Std <- function() : (preParam)
			{
				if( Def_Sys_ComboRateSetStartTiming && preParam.addcomborate && !preParam.isHit )
				{
					BMvTbl.AddComboRate(); // コンボレート加算
				}
				
				if( preParam.isBC_Init )
				{
					Battle_Std.StartShortCutSkill(); //コスト消費
				}
				
				if( preParam.isEX_Init )
				{
					Battle_Std.StartExSkill(); //コスト消費
				}
			}
			
			//Finalize_Std
			mv_tmpl.Finalize_Std <- function() : (preParam)
			{
				if( Def_Rule_SPSkillMvEnd_EraseCutIn && preParam.isSP_Init ) BMvEff.CutInProc_Erase(); //カットインがあったら消去する
				//if( preParam.isEX_Init ) BMvEff.PcAfterImage_Clear(); //残像の消去
				
				//キャラの立ちしゃがみなどの状態を見て分岐
				if( BCMDTbl.CheckPosState(_PosState_Stand) )
				{
					BMvTbl.SetNextMoveTable( "Mv_Neutral" );
				}
				else
				{
					//しゃがみや空中の場合はここ
					//空中はないはずなのと、大半は立ちなのでこの処理順
					BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
				}
			}
			
			//LastUpdate_Std
			mv_tmpl.LastUpdate_Std <- function() : (preParam)
			{
				if( preParam.isSparkDisableAttak )
				{
					_dpn("スパーク不可を消す");
					BMvTbl.SetSparkDisableAttack(0);// ヒットしたらスパーク不可の技を消す
				}
				
				if(BMvTbl.FromFinalize()==0) //Finalizeを通ってない
				{
					if( Def_Rule_SPSkillMvEnd_EraseCutIn && preParam.isSP_Init ) BMvEff.CutInProc_Erase(); //カットインがあったら消去する
					//if( preParam.isEX_Init ) BMvEff.PcAfterImage_Clear(); //残像の消去
				}
				else //暫定
				{
					if( Def_Rule_SPSkillMvEnd_EraseCutIn && preParam.isSP_Init ) BMvEff.CutInProc_Erase(); //カットインがあったら消去する
					//if( preParam.isEX_Init ) BMvEff.PcAfterImage_Clear(); //残像の消去				
				}
				
				if( preParam.isBC_Init || preParam.isEX_Init )
				{
					if( !Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_PaySkillCost ) )
					{
						if( BMvTbl.FromFinalize()==0 && ( Battle_Std.CheckPlayerisBound() || Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_Damaged ) ) )
						{
							//被弾で抜けたっぽいのでコスト消費
							if( preParam.isBC_Init )
							{
								Battle_Std.StartShortCutSkill(); //コスト消費
							}
							else if( preParam.isEX_Init )
							{
								Battle_Std.StartExSkill(); //コスト消費
							}
						}
					}
				}
				
				if( Def_Sys_MutekiHosei && !preParam.isSP && !Battle_Std.MoveCodeEx.CheckFlag( 3, def_MC3_SuccessHitFinalize ) && Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_MutekiAnnounce ) && Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_SidouHitSkill ) )
				{
					_dpn("無敵アナウンス後の抜けなので上書き補正:"+Def_Sys_MutekiHosei);
					BMvEff.ComboView_Set( { val=Def_Sys_MutekiHosei, type=0 } ); // 上書き補正
				}
				
			}
			
			//HitInterrupt_Std
			mv_tmpl.HitInterrupt_Std <- function() : (preParam)
			{
				Battle_Std.MvRule_Skill_HitInterrupt();
				
				if( !preParam.noSousai )
				{
					local is_moon_skill_param = (preParam.isBC)? 1 : 0;//MEMO:isBCとかは01じゃなくてfindなのでnullが入ってる
					// _dpn("ムーンスキル？:"+is_moon_skill_param);
					local mvhs = Battle_Std.Sousai.HitInterrupt( { isMoonSkill = is_moon_skill_param } );
					
					if( preParam.isBC && mvhs ) //ムーンスキル（意図的に検知は雑にしてある）
					{
						if( !Battle_Std.MoveCodeEx.CheckFlag( 3, def_MC3_MoonDriveSousai ) )
						{
							// ムーンドライブ中の相殺を起こした技かどうか
							// 月を何度も減らさないために入れる
							Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_MoonDriveSousai );
						
							if( Def_Sys_MoonDriveSousai_ReduceMDTime )
							{
								if( Battle_Std.MoonDrive_IsActive() )
								{
									_dpn("ムーンスキル、ムーンドライブ中の相殺だったら月をへらす:"+Def_Sys_MoonDriveSousai_ReduceMDTime);
									tDDC.Moon_AddValue( -1000*Def_Sys_MoonDriveSousai_ReduceMDTime ); // 空にする
								}
							}
						}
					}
				}
			}
			
			//最後にかんせー
			cmd_mvtmpl[mvname] <- mv_tmpl;	
		}
		else if( mvname.find("Mv_Obj_") ==0 || mvname.find("Mv_LandObj_") ==0 || mvname.find("Mv_AtkObj_") ==0 || mvname.find("Mv_AtkLandObj_") ==0 )
		{
			//オブジェクト
			local landObj = ( mvname.find("Mv_LandObj_") == 0 || mvname.find("Mv_AtkLandObj_") == 0 )? 1 : 0;
			local atkObj = ( mvname.find("Mv_Atk") == 0 )? 1 : 0;
			local word_pos = mvname.find("Obj_");
			local pat = mvname.slice( word_pos+4 );
			// _dpn("word_pos:"+word_pos+" pat:"+pat)
			
			// local pat = mvname.slice( (landObj)? 11 : 7 );
			local flags = 0;//未使用
			if( mvname in t )
			{
				local target_tmpl = t[mvname]; //該当tmplのテーブルの中身
				if( "usepat" in target_tmpl )
				{
					pat = target_tmpl.usepat;
				}
				if( "flags" in target_tmpl )
				{
					flags = target_tmpl.flags;
				}
			}
			
			local pat_num = BMvEff.GetPatternNum( { datatype=0, pat=pat } ); // パターン文字列のパターン番号を事前取得
			if( pat_num != -1 ) pat = pat_num; // 数字に変換
			
			//各関数がtmplに定義されていたら有効＆条件一致で呼ぶように参照する
			local tm_params = 
			{
				Sousai = ("Sousai" in t[mvname])? t[mvname].Sousai : 0,
				LandTiming = ("LandTiming" in t[mvname])? t[mvname].LandTiming : 0,
				Wall = ("Wall" in t[mvname])? t[mvname].Wall : 0,
				Blocked = ("Blocked" in t[mvname])? t[mvname].Blocked : 0,
			}
			
			//未使用だと思われる
			if( tm_params.Sousai )
			{
				mv_tmpl.OB_Sousai <- function() : (tm_params)
				{
					_dpn("【OB】Sousai");
					local isFirst = 0;
					if( !Battle_Std.MoveCodeEx.CheckFlag( 6, def_MC6_OB_OnceSousai ) )
					{
						isFirst = 1;
						Battle_Std.MoveCodeEx.AddFlag( 6, def_MC6_OB_OnceSousai );
					}
					if( isFirst )
					{
						tm_params.Sousai();
					}
				}
			}
			
			if( tm_params.LandTiming )
			{
				mv_tmpl.OB_LandTiming <- function() : (tm_params)
				{
					_dpn("【OB】LandTiming");
					tm_params.LandTiming();
				}
			}
			if( tm_params.Wall )
			{
				mv_tmpl.OB_Wall <- function() : (tm_params)
				{
					local isFirst = 0;
					if( !Battle_Std.MoveCodeEx.CheckFlag( 6, def_MC6_OB_OnceWall ) )
					{
						isFirst = 1;
						Battle_Std.MoveCodeEx.AddFlag( 6, def_MC6_OB_OnceWall );
					}
					if( isFirst )
					{
						_dpn("【OB】Wall");
						tm_params.Wall();
					}
				}
			}
			if( tm_params.Blocked )
			{
				mv_tmpl.OB_Blocked <- function() : (tm_params)
				{
					_dpn("【OB】Blocked");
					
					local isFirst = 0;
					if( !Battle_Std.MoveCodeEx.CheckFlag( 6, def_MC6_OB_OnceBlocked ) )
					{
						isFirst = 1;//フラグがたってなかったら初回ということにしてフラグもたてる
						Battle_Std.MoveCodeEx.AddFlag( 6, def_MC6_OB_OnceBlocked );
					}
					if( isFirst )
					{
						tm_params.Blocked();
					}
				}
			}			

			//Init_Std
			mv_tmpl.Init_Std <- function() : (pat, landObj, atkObj)
			{
				BMvTbl.SetPattern(pat);
				if( !landObj ) BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround } ); //オブジェクトは基本地面判定なし
				if( atkObj )
				{
					//色々引き継ぐ
					Battle_Std.PassPlayerToFireBallMvCode();// 親から引き継ぐコード
					if( Battle_Std.CheckParentIsSkill() )
					{
						Battle_Std.SetSkillMvChipDamage(); // 必殺技としての削りダメージを適用
						Battle_Std.SetVsAtkValueFromMvActionCode(); // MvActionCodeを見てVSダメージ削り値を設定
					}
					
					if( Def_Sys_SetSkillLvSousaiAtkObj )
					{
						local oya = BMvCore.GetParentCharaData();
						if( oya.push() )
						{
							local skill_lv = BMvTbl.GetSkillLv(); // 現在の技レベルを取得
							oya.pop();
							BMvTbl.SetSkillLv(skill_lv); // 技レベルを引き継ぐ
						}
					}
				}
				else
				{
					// Mv_Objでもこれは設定（あんまりよくないけど）
					if( Battle_Std.CheckParentIsSkill() )
					{
						Battle_Std.SetVsAtkValueFromMvActionCode(); // MvActionCodeを見てVSダメージ削り値を設定
					}
				}
			}
			
			
			//Update_Std
			mv_tmpl.Update_Std <- function() : (tm_params)
			{
				if( !Battle_Std.MoveCodeEx.CheckFlag( 6, def_MC6_FB_Vanish ) )
				{
					if( tm_params.Blocked )
					{
						if( Battle_Std.CheckPlayerisDamage() || Battle_Std.CheckEnemyIsSPActionProduction() ) // 被弾or相手が超技演出（パートナーで交代後だと被弾検知されないため）
						{
							OB_Blocked();
						}
					}
				}
			}			
			
			//FrameUpdate_Std
			mv_tmpl.FrameUpdate_Std <- function() : (tm_params, atkObj)
			{
				if( !Battle_Std.MoveCodeEx.CheckFlag( 6, def_MC6_FB_Vanish ) )
				{
					if( tm_params.LandTiming )
					{
						local s = BMvTbl.GetMvStatus();
						if( s.isLanding )
						{
							OB_LandTiming();
						}
					}
					if( tm_params.Wall ) //壁との接触チェック
					{
						local len = Battle_Std.GetGamenHajiDistance({flags=_Position_ToolShift});
						if( len<=0 )
						{
							OB_Wall();
						}
					}
				}
				if( atkObj )
				{
					if( Def_Sys_EraseObjHitBackFlags_UniqIDChange )
					{
						if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Parent } ) == 0 )
						{
							BMvEff.EraseObjectFlags( { flags=_ObjFlags_ToParentHitBack } );
						}
					}
				}
			}
			
			//Finalize_Std
			mv_tmpl.Finalize_Std <- function()
			{
				BMvTbl.SetNextMoveTable( "..." );			
			}			
			//最後にかんせー
			cmd_mvtmpl[mvname] <- mv_tmpl;				
		
		}
		else if( mvname.find("Mv_Null_") ==0 )
		{
			//ヌルオブジェクト

			//Init_Std
			mv_tmpl.Init_Std <- function()
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround } );
				BMvEff.SetExist( { level = _Exist_NoHantei } );
			}
			
			//Finalize_Std
			mv_tmpl.Finalize_Std <- function()
			{
				BMvTbl.SetNextMoveTable( "..." );			
			}			
			//最後にかんせー
			cmd_mvtmpl[mvname] <- mv_tmpl;		
		}
		else if( mvname.find("Mv_Atk_") ==0 )
		{
			// _dp("\n Atkの自動生成:"+mvname );
			//Atkとかそれ以外、今まで自動生成されてないもの
			local flags = 0; //tmplのフラグ設定
			local atkflags = 0; //tmplのatkフラグ設定
			local pat = mvname.slice(7);
			if( mvname in t )
			{
				local target_tmpl = t[mvname]; //該当tmplのテーブルの中身
				if( "usepat" in target_tmpl )
				{
					pat = target_tmpl.usepat;
				}
				if( "flags" in target_tmpl )
				{
					flags = target_tmpl.flags;
				}
				if( "atkflags" in target_tmpl )
				{
					atkflags = target_tmpl.atkflags;
				}
			}
			
			local isAir = 0;
			if( pat.find("Air") == 0 || pat.find("J") ==0 )
			{
				isAir = 1;
			}
			
			//TODO:コマンドの制限処理
			
			//全部のAtkやると今までの処理はちゃめちゃなので
			if( atkflags&def_AtkTmplFlags_Enable )
			{
				// _dp(" -> ★★処理開始" );
				
				local Voice = {};
				Voice.Init <- mvname+"_Init";
				Voice.FU <- mvname+"_FU";				
				
				local pat_num = BMvEff.GetPatternNum( { datatype=0, pat=pat } ); // パターン文字列のパターン番号を事前取得
				if( pat_num != -1 ) pat = pat_num; // 数字に変換
				
				local preParam =
				{
					pat = pat,
					Voice = Voice,
					isGround = !isAir,
					isAir = isAir,
				}

				//Init_Std
				mv_tmpl.Init_Std <- function() : (preParam)
				{
					//パターンを変更する前の処理
					Battle_Std.ClearHitStatus_SetChangeMv(); // ヒット情報のクリア

					//パターンを変更した後の処理
					BMvTbl.SetPattern(preParam.pat);
					Battle_Std.TypeSE_Play({ type=preParam.Voice.Init }); //発動ボイス
					
					//
					if( preParam.isAir )
					{
						Battle_Std.SetNormalXVecLimit(2000);
					}
					else
					{
						// Battle_Std.InitCharaVector() //慣性を残したベクトル初期化
						// XXX:危ないというか浮いてる技もあるみたいなので一旦廃止
					}
					
					Battle_Std.MoveCode.AddFlag( def_MC_Atk ); // 行動コード(通常技)を設定
					Battle_Std.InitAtkSkillMv(); // 通常技や必殺技の共通初期化
					Battle_Std.InitAtkMv();
					if( !Def_Sys_ComboRateSetStartTiming ) BMvTbl.AddComboRate(); // コンボレート加算
					
					// BMvTbl.SetHitCheckFlag( { type=1, val=_HitCheckFlag_Body, time=255, flag=_ClearFlag_ChangeMv } ); // 体無敵にスカる
					
					BMvTbl.SetNoUkemiTimeLimitFlag( { val=1, time=255, flag=_ClearFlag_ChangeMv } ); // 受け身不可時間の下限を1/2より下げる

					Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
				}
				
				//Start_Std
				mv_tmpl.Start_Std <- function() : (preParam)
				{
					if( Def_Sys_ComboRateSetStartTiming )
					{
						BMvTbl.AddComboRate(); // コンボレート加算
					}
				}
				
				mv_tmpl.FrameUpdate_Std <- function() : (preParam)
				{
					Battle_Std.TypeSE_Play({ type=preParam.Voice.FU }); //発動ボイス
				}
				
				//Finalize_Std
				mv_tmpl.Finalize_Std <- function()
				{
					//キャラの立ちしゃがみなどの状態を見て分岐
					if( BCMDTbl.CheckPosState(_PosState_Stand) )
					{
						BMvTbl.SetNextMoveTable( "Mv_Neutral" );
					}
					else
					{
						//しゃがみや空中の場合はここ
						//空中はないはずなのと、大半は立ちなのでこの処理順
						BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
					}
				}
				
				mv_tmpl.GetFinalizeCode_Std <- function()
				{
					return [ [0,"Mv_Neutral"] ];
				}
			
				//最後にかんせー
				cmd_mvtmpl[mvname] <- mv_tmpl;	
			
				
			}
		}
	}
	Battle_Std.MergeTable( cmd_mvtmpl, t );
	t = cmd_mvtmpl;

	//tはキャラで定義したＭｖが入っている
	//tをまわして、_FireBallなやつはそれようにStdをセット
	foreach(mvname, mv in t) //i スロット名　v スロットの中身
	{
		local mv_tmpl = {};
		if( ( mvname.find("Mv_FireBall") ==0 ) && ("flags" in t[mvname]) && t[mvname].flags&def_FBTmplFlags_NewTypeFireBall )
		{
			local tmpl = t[mvname];
			
			local fb_params = 
			{
				flags = ("flags" in t[mvname])? t[mvname].flags : 0,
				Sousai = ("Sousai" in t[mvname])? t[mvname].Sousai : 0,
				HitTiming = ("HitTiming" in t[mvname])? t[mvname].HitTiming : 0,
				DamageTiming = ("DamageTiming" in t[mvname])? t[mvname].DamageTiming : 0,
				GuardTiming = ("GuardTiming" in t[mvname])? t[mvname].GuardTiming : 0,
				LandTiming = ("LandTiming" in t[mvname])? t[mvname].LandTiming : 0,
				Wall = ("Wall" in t[mvname])? t[mvname].Wall : 0,
				Blocked = ("Blocked" in t[mvname])? t[mvname].Blocked : 0,
				AtkCountZero = ("AtkCountZero" in t[mvname])? t[mvname].AtkCountZero : 0,
				FirstHitTiming = ("FirstHitTiming" in t[mvname])? t[mvname].FirstHitTiming : 0,
			}
			
			//XXX:多段飛び道具関係の処理が適当だな…
			
			//FB_〜
			//各種条件が一致したときに呼び出される関数
			//勝手に追加される
			//飛び道具フラグの消滅など、重要な処理
			if( fb_params.Sousai )
			{
				t[mvname].FB_Sousai <- function() : (fb_params)
				{
					// _dpn("【FB】Sousai");
					fb_params.Sousai();
					if( !(fb_params.flags&def_FBTmplFlags_NoVanishSousai) )
					{
						Battle_Std.VanishFireBallStatus();
					}
				}
			}
			if( fb_params.FirstHitTiming )
			{
				t[mvname].FB_FirstHitTiming <- function() : (fb_params)
				{
					if( !Battle_Std.MoveCodeEx.CheckFlag( 6, def_MC6_FB_FirstHit ) )
					{
						// _dpn("【FB】FirstHitTiming");

						Battle_Std.MoveCodeEx.AddFlag( 6, def_MC6_FB_FirstHit );
						fb_params.FirstHitTiming();//ヒット時の処理
						
						if( !fb_params.HitTiming )
						{
							if( !(fb_params.flags&def_FBTmplFlags_NoVanishHit) )
							{
								Battle_Std.VanishFireBallStatus();
							}
						}
					}
				}
			}

			if( fb_params.HitTiming )
			{
				t[mvname].FB_HitTiming <- function() : (fb_params)
				{
					// _dpn("【FB】HitTiming");
					fb_params.HitTiming();//ヒット時の処理
					if( !(fb_params.flags&def_FBTmplFlags_NoVanishHit) )
					{
						Battle_Std.VanishFireBallStatus();
					}
				}
			}

			if( fb_params.DamageTiming )
			{
				t[mvname].FB_DamageTiming <- function() : (fb_params)
				{
					// _dpn("【FB】DamageTiming");
					fb_params.DamageTiming();
					if( !(fb_params.flags&def_FBTmplFlags_NoVanishDamage) )
					{
						Battle_Std.VanishFireBallStatus();
					}
				}
			}
			if( fb_params.GuardTiming )
			{
				t[mvname].FB_GuardTiming <- function() : (fb_params)
				{
					// _dpn("【FB】GuardTiming");
					fb_params.GuardTiming();
					if( !(fb_params.flags&def_FBTmplFlags_NoVanishGuard) )
					{
						Battle_Std.VanishFireBallStatus();
					}
				}
			}
			if( fb_params.LandTiming )
			{
				t[mvname].FB_LandTiming <- function() : (fb_params)
				{
					// _dpn("【FB】LandTiming");
					fb_params.LandTiming();
					if( !(fb_params.flags&def_FBTmplFlags_NoVanishLand) )
					{
						Battle_Std.VanishFireBallStatus();
					}
				}
			}
			if( fb_params.Wall )
			{
				t[mvname].FB_Wall <- function() : (fb_params)
				{
					// _dpn("【FB】Wall");
					fb_params.Wall();
					if( !(fb_params.flags&def_FBTmplFlags_NoVanishWall) )
					{
						Battle_Std.VanishFireBallStatus();
					}
				}
			}
			if( fb_params.Blocked )
			{
				t[mvname].FB_Blocked <- function() : (fb_params)
				{
					// _dpn("【FB】Blocked");
					fb_params.Blocked();
					if( !(fb_params.flags&def_FBTmplFlags_NoVanishBlocked) )
					{
						Battle_Std.VanishFireBallStatus();
					}
				}
			}
			
			if( fb_params.AtkCountZero )
			{
				t[mvname].FB_AtkCountZero <- function() : (fb_params)
				{
					// _dpn("【FB】AtkCountZero");
					fb_params.AtkCountZero();
					if( !(fb_params.flags&def_FBTmplFlags_NoVanishAtkCountZero) )
					{
						Battle_Std.VanishFireBallStatus();
					}
				}
			}
			
			//Init_Std
			local nochange_landmv = (fb_params.flags&def_FBTmplFlags_NoChangeLandMv);
				
			if( fb_params.LandTiming )
			{
				t[mvname].Init_Std <- function() : (fb_params)
				{
					//print("\nFireBall Init_Std");
					if( fb_params.Sousai ) Battle_Std.MoveCode.AddFlag( def_MC_Sousai ); // 相殺される
					Battle_Std.InitFireBall();
				}
			}
			else
			{
				t[mvname].Init_Std <- function() : (fb_params, nochange_landmv)
				{
					//print("\nFireBall Init_Std");
					if( !nochange_landmv ) BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround } ); //Landが無いなら地面判定はしない
					if( fb_params.Sousai ) Battle_Std.MoveCode.AddFlag( def_MC_Sousai ); // 相殺される
					Battle_Std.InitFireBall();
				}
			}
			
			//Update_Std
			t[mvname].Update_Std <- function() : (fb_params)
			{
				if( Battle_Std.CheckGamenGaiMuki() ) //画面外に行ったら消える（向き依存）
				{
					if( !(fb_params.flags&def_FBTmplFlags_NoVanishScreenOut) )
					{
						// _dm("画面外いったわ");
						BMvTbl.SetFinalize(0);			
					}
				}
				if( !Battle_Std.MoveCodeEx.CheckFlag( 6, def_MC6_FB_Vanish ) )
				{
					if( fb_params.Blocked )
					{
						if( Battle_Std.CheckPlayerisDamage() || Battle_Std.CheckEnemyIsSPActionProduction() )
						{
							FB_Blocked();
							// BMvTbl.SetFinalize( def_FC_FireBallBlocked );
						}
					}
				}
			}			
			
			//FrameUpdate_Std
			t[mvname].FrameUpdate_Std <- function() : (fb_params)
			{
				if( !Battle_Std.MoveCodeEx.CheckFlag( 6, def_MC6_FB_Vanish ) )
				{
					if( Battle_Std.GetFireBallFlags(def_BallFlags_Finalize) )
					{
						FB_Sousai();
						// BMvTbl.SetFinalize(def_FC_FireBallSousai); //相殺フラグたってれば消える
					}
					if( fb_params.Sousai )
					{
						if( Def_Sys_FireBallSousai )
						{
							Battle_Std.CheckSousai();
						}
					}
					if( fb_params.LandTiming )
					{
						local s = BMvTbl.GetMvStatus();
						if( s.isLanding )
						{
							FB_LandTiming();
							// BMvTbl.SetFinalize(def_FC_FireBallLand);
						}
					}
					if( fb_params.Wall ) //壁との接触チェック
					{
						local len = Battle_Std.GetGamenHajiDistance({flags=_Position_ToolShift});
						if( len<=0 )
						{
							FB_Wall();
							// BMvTbl.SetFinalize(def_FC_FireBallWall);
						}
					}

					if( fb_params.AtkCountZero ) // ヒット数がなくなったらのチェック
					{
						local count = BMvTbl.CalcHitValue(0);
						if( count<=0 )
						{
							FB_AtkCountZero();
						}
					}
					
					if( Def_Sys_EraseObjHitBackFlags_UniqIDChange )
					{
						// _ObjFlags_ToParentHitBackは親が殴ったことにするオプション
						// 親が別行動に移ったときにこの処理が入ると、ヒットしたMVが別行動になっていてかなりヤバいのでフラグを消し続ける
						if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Parent } ) == 0 )
						{
							BMvEff.EraseObjectFlags( { flags=_ObjFlags_ToParentHitBack } );
						}
					}
				}
			}
			
			t[mvname].HitInterrupt_Std <- function() : (fb_params)
			{
				if( !Battle_Std.MoveCodeEx.CheckFlag( 6, def_MC6_FB_Vanish ) )
				{
					if( fb_params.HitTiming )
					{
						if( Battle_Std.CheckHitTiming_WithPartner() )
						{
							FB_HitTiming();
							Battle_Std.AddFireBallFlags( def_BallFlags_NoSousaiVanish ); // ヒット数0になって相殺で消える処理をしない
							// BMvTbl.SetFinalize(def_FC_FireBallHit);
						}
					}
					if( fb_params.FirstHitTiming )
					{
						if( Battle_Std.CheckHitTiming_WithPartner() )
						{
							FB_FirstHitTiming();
							Battle_Std.AddFireBallFlags( def_BallFlags_NoSousaiVanish ); // ヒット数0になって相殺で消える処理をしない
						}
					}
					if( fb_params.DamageTiming )
					{
						if( Battle_Std.CheckDamageTiming() )
						{
							FB_DamageTiming();
							Battle_Std.AddFireBallFlags( def_BallFlags_NoSousaiVanish ); // ヒット数0になって相殺で消える処理をしない
							// BMvTbl.SetFinalize(def_FC_FireBallDamage);
						}
						else if( Battle_Std.CheckDamageTiming_OnlyPartner() )
						{
							//パートナーにヒットした時、ヒット処理をするとたいていおかしくなるのでガード処理に飛ぶようにする
							if( fb_params.GuardTiming )
							{
								FB_GuardTiming();
								Battle_Std.AddFireBallFlags( def_BallFlags_NoSousaiVanish ); // ヒット数0になって相殺で消える処理をしない
							}
							else if( fb_params.HitTiming )
							{
								FB_HitTiming();
								Battle_Std.AddFireBallFlags( def_BallFlags_NoSousaiVanish ); // ヒット数0になって相殺で消える処理をしない
							}
						}
					}
					if( fb_params.GuardTiming )
					{
						if( Battle_Std.CheckGuardTiming_WithPartner() )
						{
							FB_GuardTiming();
							Battle_Std.AddFireBallFlags( def_BallFlags_NoSousaiVanish ); // ヒット数0になって相殺で消える処理をしない
							// BMvTbl.SetFinalize(def_FC_FireBallGuard);
						}
					}				
					
					// 有効にするとヒット分岐する飛び道具があやしくなるので直した
					// この処理がないと飛び道具を相殺してヒット数が減ったときに消滅しないので注意
					/*
					if( fb_params.Sousai ) //相殺する飛び道具はヒットでヒット数が０になっても消滅する（hit分岐の方が優先なので先にかく）
					{
						if( !Battle_Std.CheckFireBallFlags( def_BallFlags_NoSousaiVanish ) ) // ヒット数0になって相殺で消える処理をしない
						{
							local count = BMvTbl.CalcHitValue(0);
							if( count<=0 )
							{
								FB_Sousai();
								Battle_Std.AddFireBallFlags( def_BallFlags_NoSousaiVanish ); // 何度も処理をしないためにフラグをたてる
								// BMvTbl.SetFinalize(def_FC_FireBallSousai);
							}
						}
					}
					*/
					
					// コンボレート加算
					if( Def_Rule_AddComboRateFireBallDamage )
					{
						if( BMvTbl.CalcHitValue(0)==0 && !Battle_Std.CheckFireBallFlags(def_BallFlags_AddComboRate) && Battle_Std.CheckDamageTiming() && !Battle_Std.CheckFireBallFlags( def_BallFlags_NoAddHitComboRate ) )
						{
							BMvTbl.AddComboRate();
							Battle_Std.AddFireBallFlags( def_BallFlags_AddComboRate );
							// _dp("\n レート加算")
						}
					}
				}
			}
			
			t[mvname].Finalize_Std <- function()
			{
				BMvTbl.SetDeleteMoveTable();
			}
			t[mvname].LastUpdate_Std <- function()
			{
				Battle_Std.ClearFireBallStatus(); //飛び道具属性と弾制限を解除
			}
		}
		else if( ( mvname.find("Mv_FireBall") ==0 ) && !( mvname.find("Sousai")) && !( mvname.find("_Hit")) && !( mvname.find("_Land")) && !( mvname.find("_Wall")) && !( mvname.find("_Blocked")) && !( mvname.find("_Damage")) && !( mvname.find("_Guard")) )
		{
			//相殺したら
			local mvsousai_name = mvname+"_Sousai";
			local flag_sousaicheck = (mvsousai_name in t);

			//ダメージしたorガードされたら
			local mvhit_name = mvname+"_Hit";
			local flag_hitcheck = (mvhit_name in t);

			//ダメージしたら
			local mvdamage_name = mvname+"_Damage";
			local flag_damagecheck = (mvdamage_name in t);

			//ガードされたら
			local mvguard_name = mvname+"_Guard";
			local flag_guardheck = (mvguard_name in t);
		 	
			//着地したら
			local mvland_name = mvname+"_Land";
			local flag_landcheck = (mvland_name in t);

			//壁にあたったら
			local mvwall_name = mvname+"_Wall";
			local flag_wallcheck = (mvwall_name in t);
			
			//天井にあたったら
			local mvceil_name = mvname+"_Ceil";
			local flag_ceilcheck = (mvceil_name in t);

			//操作親が殴られたら
			local mvblocked_name = mvname+"_Blocked";
			local flag_blockedcheck = (mvblocked_name in t);
			
			//エラーチェック
			if( flag_hitcheck )
			{
				if( flag_damagecheck || flag_guardheck ) 
				{
					btl_debError_CharacterMake("\n【警告】飛び道具のヒット分岐エラー");
				}
			}
			
			
			
			btl_debPrint_CharacterMake(format("Mv:%s 相殺Mv:%s ",mvname,mvsousai_name));
			btl_debPrint_CharacterMake("相殺:"+flag_sousaicheck+" ヒット:"+flag_hitcheck+" 着地:"+flag_landcheck+" 壁:"+flag_wallcheck+" 消:"+flag_blockedcheck+" ダ:"+flag_damagecheck+" ガ:"+flag_guardheck+"\n");
		
		
			//Init_Std
			local tmplflag_ball = ("flags" in t[mvname])? t[mvname].flags : 0;
			local nochange_landmv = (tmplflag_ball&def_FBTmplFlags_NoChangeLandMv);
				
			if( flag_landcheck )
			{
				t[mvname].Init_Std <- function() : (flag_sousaicheck)
				{
					//print("\nFireBall Init_Std");
					if( flag_sousaicheck ) Battle_Std.MoveCode.AddFlag( def_MC_Sousai ); // 相殺される
					Battle_Std.InitFireBall();
				}
			}
			else
			{
				t[mvname].Init_Std <- function() : (flag_sousaicheck, nochange_landmv)
				{
					//print("\nFireBall Init_Std");
					if( !nochange_landmv ) BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround } ); //Landが無いなら地面判定はしない
					if( flag_sousaicheck ) Battle_Std.MoveCode.AddFlag( def_MC_Sousai ); // 相殺される
					Battle_Std.InitFireBall();
				}
			}
			
			//Update_Std
			t[mvname].Update_Std <- function() : (flag_blockedcheck)
			{
				if( Battle_Std.CheckGamenGaiMuki() ) //画面外に行ったら消える（向き依存）
				//if( Battle_Std.CheckGamenGai() ) //画面外に行ったら消える
				{
					//_dm("画面外いったわ");
					BMvTbl.SetFinalize(0);			
				}
				if( flag_blockedcheck )
				{
					//操作親がダメージを受けたら消滅する
					if( Battle_Std.CheckPlayerisDamage() || Battle_Std.CheckEnemyIsSPActionProduction() ) BMvTbl.SetFinalize( def_FC_FireBallBlocked );
				
				}
			}			
			
			//FrameUpdate_Std
			//相殺時のテーブルが定義されてれば相殺チェックとかを行う
			t[mvname].FrameUpdate_Std <- function() : (flag_sousaicheck,flag_landcheck,flag_wallcheck,flag_ceilcheck)
			{
				if( Battle_Std.GetFireBallFlags(def_BallFlags_Finalize) ) BMvTbl.SetFinalize(def_FC_FireBallSousai); //相殺フラグたってれば消える
				if( flag_sousaicheck )
				{
					Battle_Std.CheckSousai();
				}
				if( flag_landcheck )
				{
					local s = BMvTbl.GetMvStatus();
					if( s.isLanding )
					{
						BMvTbl.SetFinalize(def_FC_FireBallLand);
					}
				}
				if( flag_wallcheck ) //壁との接触チェック
				{
					local len = Battle_Std.GetGamenHajiDistance({flags=_Position_ToolShift});
					if( len<=0 ) BMvTbl.SetFinalize(def_FC_FireBallWall);
				}
				if( flag_ceilcheck ) // 天井との接触チェック
				{
					local len = Battle_Std.GetCeilCprnerDistance();
					if( len<=0 )  BMvTbl.SetFinalize(def_FC_FireBallCeil);
				}
				
				/*
				// こっちは基本使ってないFireBallだから処理しないでおく
				if( Def_Sys_EraseObjHitBackFlags_UniqIDChange )
				{
					if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Parent } ) == 0 )
					{
						BMvEff.EraseObjectFlags( { flags=_ObjFlags_ToParentHitBack } );
					}
				}
				*/
			}
			
			// flag_hitcheck
			// flag_damagecheck
			// flag_guardheck
			
			t[mvname].HitInterrupt_Std <- function() : (flag_hitcheck, flag_sousaicheck, flag_damagecheck, flag_guardheck)
			{
				if( flag_sousaicheck ) //相殺する飛び道具はヒットでヒット数が０になっても消滅する（hit分岐の方が優先なので先にかく）
				{
					//print("\n.");
					local count = BMvTbl.CalcHitValue(0);
					if( count<=0 ) BMvTbl.SetFinalize(def_FC_FireBallSousai);	
				}
			
				if( flag_hitcheck )
				{
					//print("\n.");
					BMvTbl.SetFinalize(def_FC_FireBallHit);
				}
				if( flag_damagecheck )
				{
					local hs = BMvTbl.GetMvHitStatus();
					if( hs.Type&_HitType_Damage ) BMvTbl.SetFinalize(def_FC_FireBallDamage);
				}
				if( flag_guardheck )
				{
					local hs = BMvTbl.GetMvHitStatus();
					if( hs.Type&_HitType_Guard ) BMvTbl.SetFinalize(def_FC_FireBallGuard);
				}				
					
				// コンボレート加算
				// ※ヒット分岐先にも同じ処理あるから注意
				if( Def_Rule_AddComboRateFireBallDamage )
				{
					if( BMvTbl.CalcHitValue(0)==0 && !Battle_Std.CheckFireBallFlags(def_BallFlags_AddComboRate) && Battle_Std.CheckDamageTiming() && !Battle_Std.CheckFireBallFlags( def_BallFlags_NoAddHitComboRate ) )
					{
						BMvTbl.AddComboRate();
						Battle_Std.AddFireBallFlags( def_BallFlags_AddComboRate );
						// _dp("\n レート加算")
					}
				}
			}
			
			//Finalize_Std
			local far = []; //配列
			far.append( function(){
						Battle_Std.ClearFireBallStatus(); //飛び道具属性と弾制限を解除
						BMvTbl.SetDeleteMoveTable();
					} );
			if( flag_blockedcheck )
			{
				far.append([def_FC_FireBallBlocked,mvblocked_name]);
			}
			
			if( flag_sousaicheck )
			{
				far.append([def_FC_FireBallSousai,mvsousai_name]);
			}
			if( flag_hitcheck )
			{
				far.append([def_FC_FireBallHit,mvhit_name]);
			}
			if( flag_damagecheck )
			{
				far.append([def_FC_FireBallDamage,mvdamage_name]);
			}
			if( flag_guardheck )
			{
				far.append([def_FC_FireBallGuard,mvguard_name]);
			}
			if( flag_landcheck )
			{
				far.append([def_FC_FireBallLand,mvland_name]);
			}
			if( flag_wallcheck )
			{
				far.append([def_FC_FireBallWall,mvwall_name]);
			}
			if( flag_ceilcheck )
			{
				far.append([def_FC_FireBallCeil,mvceil_name]);
			}			
			
			//作成
			t[mvname].Finalize_Std <- function() : (far)
			{					
				Battle_Std.SwitchNextMoveTable_Array( far );
			}
			
			//相殺時のMvも一緒に作成
			//Init_Std
			if( flag_sousaicheck )
			{
				t[mvsousai_name].Init_Std <- function() : ()
				{
					//_dm("相殺Init");
					Battle_Std.ClearFireBallStatus(); //飛び道具属性と弾制限を解除
					Battle_Std.CopyBeforeMoveAction(); // 技タイプを引き継ぐ
				}
				
				//Finalize_Std
				t[mvsousai_name].Finalize_Std <- function()
				{
					BMvTbl.SetDeleteMoveTable();			
				}
				
			}
			
			//ヒット時のMvも一緒に作成
			//Init_Std
			if( flag_hitcheck )
			{
				t[mvhit_name].Init_Std <- function() : ()
				{
					//_dm("ヒットInit");
					Battle_Std.ClearFireBallStatus(); //飛び道具属性と弾制限を解除
					Battle_Std.CopyBeforeMoveAction(); // 技タイプを引き継ぐ
				}
				
				t[mvhit_name].HitInterrupt_Std <- function()
				{
					// コンボレート加算
					if( Def_Rule_AddComboRateFireBallDamage )
					{
						if( BMvTbl.CalcHitValue(0)==0 && !Battle_Std.CheckFireBallFlags(def_BallFlags_AddComboRate) && Battle_Std.CheckDamageTiming() && !Battle_Std.CheckFireBallFlags( def_BallFlags_NoAddHitComboRate ) )
						{
							BMvTbl.AddComboRate();
							Battle_Std.AddFireBallFlags( def_BallFlags_AddComboRate );
							// _dp("\n レート加算")
						}
					}
				}
				
				//Finalize_Std
				t[mvhit_name].Finalize_Std <- function()
				{
					BMvTbl.SetDeleteMoveTable();			
				}
			}
			//ダメージ時のMvも一緒に作成
			//Init_Std
			if( flag_damagecheck )
			{
				t[mvdamage_name].Init_Std <- function() : ()
				{
					//_dm("ヒットInit");
					Battle_Std.ClearFireBallStatus(); //飛び道具属性と弾制限を解除
				}
				
				//Finalize_Std
				t[mvdamage_name].Finalize_Std <- function()
				{
					BMvTbl.SetDeleteMoveTable();			
				}
			}			
			
			//ガード時のMvも一緒に作成
			//Init_Std
			if( flag_guardheck )
			{
				t[mvguard_name].Init_Std <- function() : ()
				{
					//_dm("ヒットInit");
					Battle_Std.ClearFireBallStatus(); //飛び道具属性と弾制限を解除
				}
				
				//Finalize_Std
				t[mvguard_name].Finalize_Std <- function()
				{
					BMvTbl.SetDeleteMoveTable();
				}
			}			
			

			//着地時のMvも一緒に作成
			//Init_Std
			if( flag_landcheck )
			{
				local tmplflag_land = ("flags" in t[mvland_name])? t[mvland_name].flags : 0;
				local noset_vec = (tmplflag_land&def_FBTmplFlags_NoClearVector);
				t[mvland_name].Init_Std <- function() : (noset_vec)
				{
					//_dm("着地Init");
					if( !noset_vec ) Battle_Std.InitVector(); //着地なので
					Battle_Std.ClearFireBallStatus(); //飛び道具属性と弾制限を解除
					Battle_Std.CopyBeforeMoveAction(); // 技タイプを引き継ぐ
				}
				
				//Finalize_Std
				t[mvland_name].Finalize_Std <- function()
				{
					BMvTbl.SetDeleteMoveTable();			
				}
			}

			//壁ヒット時のMvも一緒に作成
			//Init_Std
			if( flag_wallcheck )
			{
				t[mvwall_name].Init_Std <- function() : ()
				{
					//_dm("壁Init");
					Battle_Std.InitVector(); //壁なので？
					Battle_Std.ClearFireBallStatus(); //飛び道具属性と弾制限を解除
					Battle_Std.CopyBeforeMoveAction(); // 技タイプを引き継ぐ
				}
				
				//Finalize_Std
				t[mvwall_name].Finalize_Std <- function()
				{
					BMvTbl.SetDeleteMoveTable();			
				}
			}
			
			//天井ヒット時のMvも一緒に作成
			//Init_Std
			if( flag_ceilcheck )
			{
				t[mvceil_name].Init_Std <- function() : ()
				{
					// _dm("天井Init");
					Battle_Std.InitVector(); //天井なので
					Battle_Std.ClearFireBallStatus(); //飛び道具属性と弾制限を解除
					Battle_Std.CopyBeforeMoveAction(); // 技タイプを引き継ぐ
				}
				
				//Finalize_Std
				t[mvceil_name].Finalize_Std <- function()
				{
					BMvTbl.SetDeleteMoveTable();			
				}
			}			
			
			//操作親殴られて消滅するときのMvも一緒に作成
			//Init_Std
			if( flag_blockedcheck )
			{
				t[mvblocked_name].Init_Std <- function() : ()
				{
					//_dm("ブロックされたInit");
					Battle_Std.ClearFireBallStatus(); //飛び道具属性と弾制限を解除
					Battle_Std.CopyBeforeMoveAction(); // 技タイプを引き継ぐ
				}
				
				//Finalize_Std
				t[mvblocked_name].Finalize_Std <- function()
				{
					BMvTbl.SetDeleteMoveTable();			
				}
			}				

		}
	}
	
	
	//
	
	return t;
	

}




function Battle_Std::MakeCmdArray( tbl ) //CMD形式の配列を返す
{
	local cmn = Battle_Std.GetStdCommandTable();
	local z = []; //配列宣言
	foreach(i, v in tbl) //i スロット名　v スロットの中身
	{
	
		if (!( i in cmn)) //未登録の技がきちゃった
		{
			z.append(v); //配列にいれちゃうよ
		}
		else
		{	
			local tmpl = cmn[i]; //上書き予定のテンプレ
			//tblのスロットをまわして同名に上書き
			foreach(x, y in v) //x スロット名　y スロットの中身
			{
				//print("あったすろっと:"+x);
				if ( x in tbl[i])
				{
					//print("＠＠＠");
					tmpl[x] <- y;
				}								
			}			

			//i 該当するコマンド。これと同名のスロットをCMN_CommandTable2からもってくる。
			//tbl[i] = CMN_CommandTable2[i];
			z.append(tmpl); //配列の最後にぶっこみ
		}
		
	}
	return z;
}

//必殺技の投げ抜け待機Mv作成関数
Battle_Std.MakeMv <- {};

//	FrameID=512,
//	ThrowParam={ pattern=17, x=340, y=0 },
//	TechFrame = def_FL_BoundTech,
//	NextMv="Mv_Skill_214_Hit",

Battle_Std.MakeMv.TechWait <- function( tbl={} )
{
	local ret = {
		Init = 0,
		Update = 0,
		Finalize = 0,
		LastUpdate = 0,
	};
	
	local FrameID = ("FrameID" in tbl)? tbl.FrameID : -1;
	local ThrowParam = { pattern=17, x=200, y=0 }; //デフォルト
	local TechFrame = ("TechFrame" in tbl)? tbl.TechFrame : def_FL_BoundTech;
	local NextMv = tbl.NextMv;
	local TechedMv = ("TechedMv" in tbl)? tbl.TechedMv : "Mv_SkillTeched";
	
	if( "ThrowParam" in tbl)
	{
		if( "pattern" in tbl.ThrowParam ) ThrowParam.pattern = tbl.ThrowParam.pattern;
		if( "x" in tbl.ThrowParam ) ThrowParam.x = tbl.ThrowParam.x;
		if( "y" in tbl.ThrowParam ) ThrowParam.y = tbl.ThrowParam.y;

		//デフォルトに無いので <- で入れていく
		if( "flags" in tbl.ThrowParam ) ThrowParam.flags <- tbl.ThrowParam.flags;
		if( "hantei_rect" in tbl.ThrowParam ) ThrowParam.hantei_rect <- tbl.ThrowParam.hantei_rect;
	}
	

	ret.Init = function() : (FrameID, ThrowParam, TechFrame, NextMv, TechedMv)
	{
		Battle_Std.InitVector(); // ベクトル初期化(一応)
		Battle_Std.ThrowTech.SetMuteki(); //つかみ中は自分も相手も無敵にする
		Battle_Std.ThrowTech.SetPos(1); //つかむ前の自分と相手の座標を記憶する(0:逆投げもありうる 1:逆投げはない)	
		//BMvTbl.SetPattern(def_PAT_Throw_F_TechWait); //投げ抜け待機パターンに変更(ここで相手はのけぞる)
		if( FrameID!=-1 ) BMvTbl.JumpFrameID( FrameID );
		BMvEff.ThrowParam( ThrowParam );

		Battle_Std.ThrowTech.ShiftOverGamenHajiX(); //相手が画面外にいたら自分の座標ごと補正をかける			
		Battle_Std.ThrowTech.DrawThrowEffect(1); //ヒット座標につかみエフェクト表示
		
		BMvEff.ThrowChara_SetCamera( 1 ); //投げているキャラをカメラ処理に含める
		
		Battle_Std.PassHitMoveCodes(); // ヒット分岐でのMvCode引継ぎ
	}

	ret.Update = function() : (TechFrame) //投げぬけ猶予中
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( s.MvCount>TechFrame )
		{
			BMvTbl.SetFinalize(0); //投げ抜け猶予が終わったので終わる
			return; //先には進めない
		}
		//print( "\n"+s.MvCount );
		
		if ( Battle_Std.ThrowTech.CheckTechCommand() ) //相手が投げ抜けコマンドを入れた
		{
			Battle_Std.ThrowTech.DrawTechEffect(); //投げ抜け演出を表示
			Battle_Std.ThrowTech.TechRelease(); //投げ抜けされた時の開放処理
			
			local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
			if( enemy.IsDone )
			{
				BMvCore.PushCharaData( enemy ); // ここから敵の処理
					local delay = TechFrame - s.MvCount;
					Battle_Std.DrawDebugAttackInfo("TechSafe: "+delay+"F" );
				BMvCore.PopCharaData(); // 	
			}
			
			BMvTbl.SetFinalize(256);
		}
	}

	ret.Finalize = function() : (NextMv,TechedMv)
	{
		//Battle_Std.Create_TechDelayCheckObject
		Battle_Std.SwitchNextMoveTable(
		function() : (NextMv)
		{
			Battle_Std.Create_TechDelayCheckObject(); //投げ抜け失敗チェックオブジェクト生成 1:1Fズラす
			BMvTbl.SetNextMoveTable( NextMv );		
		}
		,[256,TechedMv]);
	}

	ret.LastUpdate = function()
	{
		BMvEff.ThrowChara_SetCamera( 0 ); //投げているキャラをカメラ処理に含めない
	
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );
		//相手の無敵は解除
		local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
		if( enemy.IsDone )
		{
			BMvCore.PushCharaData( enemy ); // ここから敵の処理
			{
				BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );
			}
			BMvCore.PopCharaData(); // 	
		}
	}

	return ret;
}

// ★サンプル
// local aniset_hara = 
// [
	// { Data = [307,0,6], Vector = { x=-2000, addx=100, flags=_Vector_Div } },
	// { Data = [307,1,255], },
// ];

// //垂直吹き飛び部分
// t.Mv_AniSet <- Battle_Std.MakeMv.SetCaptureCharaAnime( { animation = aniset_hara } );

Battle_Std.MakeMv.LastCharaAnimeEnd <- function( clear_vector = 0 )
{
	BMvTbl.SetPP(def_PP_AniSetObject, 1-BMvTbl.GetPP(def_PP_AniSetObject) );// 1 0 1 0 ...
	if( clear_vector )
	{
		local enemy = BMvCore.GetCaptureCharaData();
		if( enemy.push() )
		{
			Battle_Std.InitVector();
			enemy.pop();
		}
	}
}

//つかみ中の相手にアニメーションを設定し続けるMvを作る関数
Battle_Std.MakeMv.SetCaptureCharaAnime <- function( tbl )
{
	local tmpl = {};
	
	local animation = tbl.animation;
	
	// キャッシュのせ関数
	local set_NextAniCache = function( _startpos ) : (animation)
	{
		// _dp("\n [set_NextAniCache]");
		local total_frame = 0; // restを調節する用のトータルフレーム
		for( local pos=_startpos; pos<animation.len(); pos++ )
		{
			// pos0はこのフレームでSetPatternされるのでキャッシュにのせても意味が無い
			if( pos >= 1 )
			{
				local anipat = animation[pos].Data[0];
				local anifra = animation[pos].Data[1];
				local enemy = BMvCore.GetCaptureCharaData();
				if( enemy.push() )
				{
					local userest = (total_frame <= 0 )? 2 : total_frame; // 0Fで要求するのはアレなので
					BMvCore.CallEntryBCCachePreTransfer( { pat=anipat, frame=anifra, rest=userest } );
					// _dp( format("\nキャッシュ転送予約[%3d _ %3d]... %dF後",anipat, anifra, userest) );
					
					enemy.pop();
				}
			}
			// アニメーションのディレイを足していって、予約タイミングを調節する
			total_frame += animation[pos].Data[2]; // ディレイ値を足す
		}
		// _dp("\n ※total_frame:"+total_frame );
	}	

	tmpl.Init <- function() : (animation, set_NextAniCache)
	{
		//_dm("開始");

		BMvTbl.SetLP(0,0); //アニメ定義の位置(anipos)

		BMvTbl.SetLP(1,0); //aniposでの経過delay

		BMvTbl.SetLP(2,0); //ループカウンタ

		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } ); //基本的にMv内のみ
		
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		//BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		
		//相手にくっつく
		Battle_Std.MakeMv.LastCharaAnimeEnd(); // 前に生成してた自分を消す

		local check_pp = BMvTbl.GetPP( def_PP_AniSetObject );
		BMvTbl.SetLP(3,check_pp); //PPがこの値じゃなくなったら消滅する
		
		BMvTbl.SetLP(4,-1); //FrameUpdate的変数
		
		// 生成タイミングで必要なパターンをキャッシュにのせる
		if( Def_Dbg_DebugMessage ) // チェック用
		{
			local anipat = animation[0].Data[0];
			local anifra = animation[0].Data[1];
			local anidel = animation[0].Data[2];
			if( anifra != 0 || anidel <= 1 )
			{
				_dp( format("\n★キャッシュエラー[%3d _ %3d]",anipat, anifra, anidel) );
			}
		}
		if( animation.len() > 1 )
		{
			set_NextAniCache( 0 ); // 0個目からキャッシュ乗せ計算開始
		}
	}
	
	if( !( "endfunc" in tbl ) )
	{
		tbl.endfunc <- 0;
	}
	

	
	tmpl.FrameUpdate <- function() : (tbl, set_NextAniCache)
	{
		//if( "" )
		//local endcheck_funck = 
		
		local pp = BMvTbl.GetPP(def_PP_AniSetObject);
		if( pp!=BMvTbl.GetLP(3) )
		{
			//_dm("２つ目が出てきたので消える");
			BMvTbl.SetFinalize(0);
			return;
		}
	
		local anipos = BMvTbl.GetLP(0); // ダミーの現在のアニメポジション（この場所の絵を表示する）
		local anidelay = BMvTbl.GetLP(1); // ダミーの現在のアニメディレイ（これが設定を超えると次の絵に進む）
		BMvTbl.AddLP(1,1); //1F経過
		
		local frame_end = 0;// 1:終了 100:着地で終了
		local enemy_is_umari = 0; // 埋まりそうなら1

		local anifra = tbl.animation[anipos];
		
		//見やすいように割り当て
		//設定しようとしているパターン、フレーム、そのディレイ
		local set =
		{
			pat = anifra.Data[0],
			fra = anifra.Data[1],
			del = anifra.Data[2],
		}
		
		local end_check = tbl.endfunc;
		
		// ここから色々設定
		//print(format("\n☆ [%3d-%2d-%2d-%2d]",set.pat, set.fra, set.del, anidelay))
		
		local player = BMvCore.GetPlayerCharaData();
		local hitst;
		if( player.IsDone )
		{
			BMvCore.PushCharaData( player ); //
				hitst = BMvTbl.GetMvHitStatus();
			BMvCore.PopCharaData(); //					
		}		
		
		local enemy = BMvCore.GetCaptureCharaData();
		if( enemy.push() )
		{
			BMvTbl.SetPattern( set.pat );
			BMvTbl.Frame_Proc( set.fra, _ValSet );
			local cap_pos = BMvTbl.GetPosition();

			local last_FU = BMvTbl.GetLP(4);
			local frame_is_update = (last_FU != set.fra);
			if( frame_is_update )
			{
				BMvTbl.SetLP(4,set.fra); //最後に処理をしたフレームを記憶
				
				//１回しか行わない（同フレームに攻撃があたったりすると消えちゃうよ）
				if( "InitVector" in anifra )
				{
					BMvTbl.SetVector( anifra.InitVector );
				}
			}
			//何度も入ってくるベクトル
			if( "Vector" in anifra )
			{
				BMvTbl.SetVector( anifra.Vector );
			}

			local enemy_is_fall = 0; // 敵が落下っぽい挙動かどうか
			if( BMvTbl.GetVector().y > 0 ) enemy_is_fall = 1;
			
			if( "Move" in anifra )
			{
				BMvTbl.SetPosition( { x=anifra.Move.x, y=anifra.Move.y, flags=_Position_Add|_Position_ChangeMuki } );
				
				if( anifra.Move.y > 0 )
				{
					enemy_is_fall = 1;
				}
			}
			enemy.pop();
			
			BMvTbl.SetPosition( { x=cap_pos.x, y=cap_pos.y } );
			
			//埋まってる＆落下っぽい
			if( cap_pos.y > 0 && enemy_is_fall )
			{
				enemy_is_umari = 1;
			}
			
			if( frame_is_update )
			{
				// _dp("\n ※["+set.pat+"_"+set.fra+"]" );
				// 次以降を予約する
				set_NextAniCache( anipos ); // anipos個目からキャッシュ乗せ計算開始
			}
		}
		else
		{
			//_dm("つかんでるのがいなくなったっぽい")
			BMvTbl.SetFinalize(0);
			return;
		}
		
		if( end_check!=0 && end_check() )
		{
			//_dm("終了条件がきたので終わります");
			BMvTbl.SetFinalize(0);
			return;
		}
		
		if( anidelay>= set.del ) //ディレイがたった
		{
			frame_end = 1;
			BMvTbl.SetLP(1,0);
		}
		
		if( "LandRelJump" in anifra || "LandJump" in anifra )
		{
			//着地ジャンプの指定がある時は、埋まってる時にframeを終わらせる
			if( enemy_is_umari )
			{
				BMvTbl.SetLP(1,0); // ディレイを初期化
				frame_end = 100;
			}
		}
		
		if( frame_end )
		{
			if( frame_end == 100 && "LandRelJump" in anifra )
			{
				local jump = anipos + anifra.LandRelJump;
				BMvTbl.SetLP(0,jump); //すぐにはとばず次はここへいくよ
			}
			else if( frame_end == 100 && "LandJump" in anifra )
			{
				local jump = anifra.LandJump;
				BMvTbl.SetLP(0,jump); //すぐにはとばず次はここへいくよ
			}
			else if( "RelJump" in anifra )
			{
				local jump = anipos + anifra.RelJump;
				BMvTbl.SetLP(0,jump); //すぐにはとばず次はここへいくよ
			}
			else if( anipos< tbl.animation.len() ) //まだ最後まできてなければ進む
			{
				local jump = anipos + 1;
				BMvTbl.SetLP(0,jump); //すぐにはとばず次はここへいくよ				
			}
			else
			{
				BMvTbl.SetFinalize(0); //何もなければ終わる
			}
		}
		
	}

	tmpl.Finalize <- function()
	{
		//_dm("終了");
		BMvTbl.SetDeleteMoveTable();
	}
	
	return tmpl;
}


//つかみ中の相手にアニメーションを設定し続けるMvを作る関数2(こっちを使って下さい)
Battle_Std.MakeMv.SetCaptureCharaAnime2 <- function( tbl )
{
	local tmpl = {};
	
	local animation = tbl.animation;
	
	// キャッシュのせ関数
	local set_NextAniCache = function( _startpos ) : (animation)
	{
		// _dp("\n [set_NextAniCache]");
		local total_frame = 0; // restを調節する用のトータルフレーム
		for( local pos=_startpos; pos<animation.len(); pos++ )
		{
			// pos0はこのフレームでSetPatternされるのでキャッシュにのせても意味が無い
			if( pos >= 1 )
			{
				local anipat = animation[pos].Data[0];
				local anifra = animation[pos].Data[1];
				local enemy = BMvCore.GetCaptureCharaData();
				if( enemy.push() )
				{
					local userest = (total_frame <= 0 )? 2 : total_frame; // 0Fで要求するのはアレなので
					BMvCore.CallEntryBCCachePreTransfer( { pat=anipat, frame=anifra, rest=userest } );
					// _dp( format("\nキャッシュ転送予約[%3d _ %3d]... %dF後",anipat, anifra, userest) );
					
					enemy.pop();
				}
			}
			// アニメーションのディレイを足していって、予約タイミングを調節する
			total_frame += animation[pos].Data[2]; // ディレイ値を足す
		}
		// _dp("\n ※total_frame:"+total_frame );
	}	

	tmpl.Init <- function() : (animation, set_NextAniCache)
	{
		//_dm("開始");

		BMvTbl.SetLP(0,0); //アニメ定義の位置(anipos)

		BMvTbl.SetLP(1,0); //aniposでの経過delay

		BMvTbl.SetLP(2,0); //ループカウンタ

		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } ); //基本的にMv内のみ
		
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		//BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		
		//相手にくっつく
		Battle_Std.MakeMv.LastCharaAnimeEnd(); // 前に生成してた自分を消す

		local check_pp = BMvTbl.GetPP( def_PP_AniSetObject );
		BMvTbl.SetLP(3,check_pp); //PPがこの値じゃなくなったら消滅する
		
		BMvTbl.SetLP(4,-1); //FrameUpdate的変数　前回のfraが入ってる
		BMvTbl.SetLP(5,-1); //FrameUpdate的変数　前回のpatが入ってる
		
		BMvTbl.SetVector( { x=0, y=0, addx=0, addy=0, flags=_Vector_Keep } ); // やられベクトル記憶用
		
		// 生成タイミングで必要なパターンをキャッシュにのせる
		if( Def_Dbg_DebugMessage ) // チェック用
		{
			local anipat = animation[0].Data[0];
			local anifra = animation[0].Data[1];
			local anidel = animation[0].Data[2];
			if( anifra != 0 || anidel <= 1 )
			{
				if( animation.len() > 1 )
				{
					if( anipat == animation[1].Data[0] && anifra == animation[1].Data[1] && animation[1].Data[2]>=2 )
					{
						// 次の絵が０番目のやつと同じで、次の絵がdelay2F以上あれば安心
					}
					else
					{
						_dp( format("\n★キャッシュエラー[%3d _ %3d]",anipat, anifra, anidel) );
					}
				}
			}
		}
		if( animation.len() > 1 )
		{
			set_NextAniCache( 0 ); // 0個目からキャッシュ乗せ計算開始
		}
	}
	
	if( !( "endfunc" in tbl ) )
	{
		tbl.endfunc <- 0;
	}
	

	
	tmpl.Update <- function() : (tbl, set_NextAniCache)
	{
		//if( "" )
		//local endcheck_funck = 
		
		if( BMvTbl.GetPP(def_PP_AniSetObject) != BMvTbl.GetLP(3) )
		{
			//_dm("２つ目が出てきたので消える");
			BMvTbl.SetFinalize(0);
			return;
		}
	
		local anidelay = BMvTbl.GetLP(1); // ダミーの現在のアニメディレイ（これが設定を超えると次の絵に進む）
		BMvTbl.AddLP(1,1); //1F経過
		
		local frame_end = 0;// 1:終了 100:着地で終了
		local enemy_is_umari = 0; // 埋まりそうなら1

		local anipos = BMvTbl.GetLP(0); // ダミーの現在のアニメポジション（この場所の絵を表示する）
		local anifra = tbl.animation[ anipos ];
		
		//見やすいように割り当て
		//設定しようとしているパターン、フレーム、そのディレイ
		local set =
		{
			pat = anifra.Data[0],
			fra = anifra.Data[1],
			del = anifra.Data[2],
		}
		
		local end_check = tbl.endfunc;
		
		local isHitStopFrame = 0;
		local player = BMvCore.GetPlayerCharaData(); // 相手情報取得
		local playerMuki = 1;
		if( player.push() )
		{
			local mvs = BMvTbl.GetMvStatus();
			if( mvs.isUpdate == 0 ) isHitStopFrame = 1;
			playerMuki = BMvTbl.GetMuki();
			player.pop();
		}
		
		local enemy = BMvCore.GetCaptureCharaData();
		local last_fra = BMvTbl.GetLP(4); // 前のfra？
		local last_pat = BMvTbl.GetLP(5); // 前のfra？
		local isFrameUpdate = ( last_fra != set.fra || last_pat != set.pat ); // 前回処理したfraと違った＝フレームアップデート

		if( isFrameUpdate )
		{
			if( "HitVec" in anifra )
			{
				local flags = ("flags" in anifra.HitVec )? anifra.HitVec.flags : 0;
				if( flags&Def_SCCA_HitVec_InitVec )
				{
					BMvTbl.SetVector( { x=anifra.HitVec.x*playerMuki, y=anifra.HitVec.y, addx=anifra.HitVec.addx*playerMuki, addy=anifra.HitVec.addy, flags=_Vector_Keep } );
				}
			}
		}
		local objKeepVec = BMvTbl.GetVector( { flags=_Vector_Keep } );
		// _dp( format("\n %4d %4d %4d %4d", objKeepVec.x, objKeepVec.y, objKeepVec.addx, objKeepVec.addy ));
		
		if( enemy.push() )
		{
			BMvTbl.SetPattern( set.pat );
			if( set.fra != 0 ) BMvTbl.Frame_Proc( set.fra, _ValSet );
			local cap_pos = BMvTbl.GetPosition( 0 ); // 相手の座標

			if( isFrameUpdate )
			{
				//１回しか行わない（同フレームに攻撃があたったりすると消えちゃうよ）
				if( "InitVector" in anifra )
				{
					if( anifra.InitVector )
					{
						BMvTbl.SetVector( anifra.InitVector );
					}
					else
					{
						Battle_Std.InitVector();
					}
				}
			}
			//何度も入ってくるベクトル
			if( "Vector" in anifra )
			{
				if( anifra.Vector )
				{
					BMvTbl.SetVector( anifra.Vector );
				}
				else
				{
					Battle_Std.InitVector();
				}
			}

			local enemy_is_fall = 0; // 敵が落下っぽい挙動かどうか
			if( BMvTbl.GetVector().y > 0 ) enemy_is_fall = 1;
			
			if( "Move" in anifra )
			{
				BMvTbl.SetPosition( { x=anifra.Move.x, y=anifra.Move.y, flags=_Position_Add|_Position_ChangeMuki } );
				
				if( anifra.Move.y > 0 )
				{
					enemy_is_fall = 1;
				}
			}
			if( isHitStopFrame == 0 )
			{
				if( "HitMove" in anifra )
				{
					// これは自分の向き依存
					BMvTbl.SetPosition( { x=anifra.HitMove.x, y=anifra.HitMove.y, flags=_Position_Add|_Position_ChangeMuki } );
				}
			}
			if( isHitStopFrame == 0 )
			{
				if( "HitVec" in anifra )
				{
					local flags = ("flags" in anifra.HitVec )? anifra.HitVec.flags : 0;
					if( flags&Def_SCCA_HitVec_AutoMuki )
					{
						BMvTbl.SetMuki( _Direction_Auto );
					}
					// 相手の向き依存なのが分かりにくい気がする
					objKeepVec.x += objKeepVec.addx;
					objKeepVec.y += objKeepVec.addy;
					BMvTbl.SetPosition( { x=objKeepVec.x, y=objKeepVec.y, flags=_Position_Add } );
				}
			}			
			if( "Set" in anifra )
			{
				if( "x" in anifra.Set )
				{
					BMvTbl.SetPosition( { x=anifra.Set.x } );
				}
				if( "y" in anifra.Set )
				{
					BMvTbl.SetPosition( { y=anifra.Set.y } );
				}
			}
			
			if( isFrameUpdate && "Flash" in anifra )
			{
				BMvEff.SetCharaFlash( anifra.Flash );
			}
			
			if( isFrameUpdate && "Func" in anifra )
			{
				if( player.push() )
				{
					anifra.Func();
					
					player.pop();
				}
			}
			if( isFrameUpdate && "EnemyFunc" in anifra )
			{
				anifra.EnemyFunc();
			}

			enemy.pop();
			
			//埋まってる＆落下っぽい
			if( cap_pos.y > 0 && enemy_is_fall )
			{
				enemy_is_umari = 1;
			}
			
			if( isFrameUpdate )
			{
				// _dp("\n ※["+set.pat+"_"+set.fra+"]" );
				// 次以降を予約する
				set_NextAniCache( anipos ); // anipos個目からキャッシュ乗せ計算開始
				
				BMvTbl.SetLP(4, set.fra); // 最後に処理をしたfraを記憶
				BMvTbl.SetLP(5, set.pat); // 最後に処理をしたfraを記憶
			}
			
			// やられベクトル使った分更新
			BMvTbl.SetVector( { x=objKeepVec.x, y=objKeepVec.y, addx=objKeepVec.addx, addy=objKeepVec.addy, flags=_Vector_Keep } );
			
			if( player.push() )
			{
				local mvs = BMvTbl.GetMvStatus();
				if( "Throw" in anifra )
				{
					local flags = ("flags" in anifra.Throw )? anifra.Throw.flags : 0;
					
					local useX = anifra.Throw.x;
					if( flags & Def_SCCA_Throw_CheckFrontStage ) // 掴んだ相手が前方のステージ外にいかないようにする
					{
						local kyori = Battle_Std.GetFrontStageDistance()/128; // 前方の端までの距離
						if( useX > kyori ) useX = kyori;
					}
					
					// これでパターンが上書きされちゃうんだよなぁ
					BMvEff.ThrowParam( { x=useX, y=anifra.Throw.y } );
				}
				if( anidelay == 0 && "Camera" in anifra )
				{
					// { Move = { y=-450, frame=20, in=1 } }
					// anifra.Camera
					if( "Move" in anifra.Camera )
					{
						_dp("\n カメラ操作");
						local _x = ( "x" in anifra.Camera.Move )? anifra.Camera.Move.x : 0;
						local _y = ( "y" in anifra.Camera.Move )? anifra.Camera.Move.y : 0;
						local _frame = ( "frame" in anifra.Camera.Move )? anifra.Camera.Move.frame : 10;
						local _zoom = ( "zoom" in anifra.Camera.Move )? anifra.Camera.Move.zoom : 1.0;
						local pos = BMvTbl.GetPosition( 0 );
						BMvEff.SetCamera_Focus( { num=0, time=[0,999,15] } );
						BMvEff.SetCamera_Focus( { num=1, x=pos.x+(BMvTbl.GetMuki()*_x<<7), y=pos.y+(_y<<7), zoom=_zoom, time=[_frame,999,30], type_in=1 } );
					}
				}
				if( "FrameIDEnd" in anifra && mvs.FrameID == anifra.FrameIDEnd )
				{
					// アニメジャンプ
					frame_end = true; // 終わったことにする
				}
				player.pop();
			}
			BMvTbl.SetPosition( { x=cap_pos.x, y=cap_pos.y } ); // 相手の座標にくっつく
		}
		else
		{
			//_dm("つかんでるのがいなくなったっぽい")
			BMvTbl.SetFinalize(0);
			return;
		}
		
		if( end_check!=0 && end_check() )
		{
			//_dm("終了条件がきたので終わります");
			BMvTbl.SetFinalize(0);
			return;
		}
		
		if( anidelay +1 >= set.del ) //ディレイがたった
		{
			frame_end = 1;
			BMvTbl.SetLP(1,0);
		}
		
		if( "LandRelJump" in anifra || "LandJump" in anifra )
		{
			//着地ジャンプの指定がある時は、埋まってる時にframeを終わらせる
			if( enemy_is_umari )
			{
				BMvTbl.SetLP(1,0); // ディレイを初期化
				frame_end = 100;
			}
		}
		
		// _dm(format("\n☆ %2d [%3d-%2d-%2d-%2d]",anipos, set.pat, set.fra, set.del, anidelay));
		
		if( frame_end )
		{
			if( frame_end == 100 && "LandRelJump" in anifra )
			{
				local jump = anipos + anifra.LandRelJump;
				BMvTbl.SetLP(0,jump); //すぐにはとばず次はここへいくよ
			}
			else if( frame_end == 100 && "LandJump" in anifra )
			{
				local jump = anifra.LandJump;
				BMvTbl.SetLP(0,jump); //すぐにはとばず次はここへいくよ
			}
			else if( "RelJump" in anifra )
			{
				local jump = anipos + anifra.RelJump;
				BMvTbl.SetLP(0,jump); //すぐにはとばず次はここへいくよ
			}
			else if( anipos < tbl.animation.len()-1 ) //まだ最後まできてなければ進む
			{
				local jump = anipos + 1;
				BMvTbl.SetLP(0,jump); //すぐにはとばず次はここへいくよ				
			}
			else
			{
				BMvTbl.SetFinalize(0); //何もなければ終わる
			}
		}
		
	}

	tmpl.Finalize <- function()
	{
		//_dm("終了");
		BMvTbl.SetDeleteMoveTable();
	}
	
	return tmpl;
}


// コマンドリスト生成テスト
Battle_Std.WriteCommandList <- function( param={} )
{
	if( Def_Dbg_WriteCommandList == 0 ) return; // 何もしない
	
	local std = Battle_Std.GetStdCommandTable();

	local command_list = []; // 最終的に出力するコマンドリスト配列

	foreach( slot, val in param.cmdtmpl )
	{
		if( slot in std ) // あるはずだけど
		{
			local target = std[slot];
			local out = slot+" : " + target;
			
			local command = (typeof target.command == "array")? target.command[0] : target.command;
			local posstate = "Ground";
			if( "CmdCheck" in target )
			{
				if( "PosState" in target.CmdCheck ) posstate = target.CmdCheck.PosState;
			}

			local skill_tbl = 
			{
				num = target.num,
				name = target.name,
				command = command,
				posstate = posstate,
				usegauge = ("usegauge" in target)? target.usegauge/10000 : 0,
			}
			command_list.append( skill_tbl );

		}
	}

	local logfile = debuglog._LogsFile(); // 最後の括弧は必要、logという名前はたぶん算術関数にあるのでつくらないように
	
	local filename = "CLXX_Test.txt";
	if( "filename" in param ) filename = param.filename;

	logfile.opennew("./___NotProject/"+filename ); // 追記ではなく開く(exe位置から見たところに書く)

	// コマンド番号でソートしてから書き出す
	command_list.sort(function(a, b) { return a.num > b.num ? 1 : a.num < b.num ? -1 : 0; });

	local out = ""; // 最終的に書き出す文字
	for( local i = 0; i<command_list.len(); i++ )
	{
		local t = command_list[i];
		
		local out_command = "";
		if( t.posstate == "Air" ) out_command = "(空中)";
		if( t.posstate == "Always" ) out_command = "(空中可)";
		
		local gauge = "";
		if( t.usegauge != 0 ) gauge = format("(ゲージ%d以上)",t.usegauge);
		
		out += format("○%s\n　%s%s%s \n\n",t.name, gauge, out_command, t.command);
		
		//print( t.num + ", " + t.name +", " + t.command + ", " + t.posstate +"\n" );
	}
	//_dp1p( out );
	logfile.write( out );

	logfile.close(); // ファイルクローズ
}


const BCTF_AngleType_Random = 0;
const BCTF_AngleType_HitVector = 1;
const BCTF_AngleType_HitMuki = 2;
const BCTF_AngleType_HitMuki_SwitchAltInvisible = 3;//セイバー用

Battle_Std.AddHitEffects <- function( std, _ChrNo=0 )
{
	// ----------------------------------------------------------------------------
	// ヒットエフェクト
	// ----------------------------------------------------------------------------
	
	// ヒットエフェクト・ガードエフェクト仕様
	// VectorTable.txtでHitMarkListにLimitが設定してあると、勝手に間引きがでるようになった
	// なので通常と間引きで見た目以外の違いがあってはいけない（ＳＥが同じであること、ヒット効果？とかつけちゃダメ）

	//std.Mv_Eff_Hit_SlashC <- function():(CreateHitPar){ CreateHitPar(); }
	local makemv_Normal_HitEff = function( hitEff )
	{
		local base_hitEff = ( "base" in hitEff )? hitEff.base : 0;
		
		//angle_type
		//0(default):角度はランダム
		//1:角度は攻撃に合わせる
		//2:左右の向きだけ合わせて角度はランダム
		
		local retmv = function( info ){};
		
		local angleType = ("angle_type" in hitEff)? hitEff.angle_type : 0;
		
		local pat_num_HitPattern = BMvEff.GetPatternNum( { datatype=hitEff.datatype, pat=hitEff.pat } );//事前に取得して軽くする
		local pat_num_AddHitPattern = ( "addPat" in hitEff )? BMvEff.GetPatternNum( { datatype=hitEff.datatype, pat=hitEff.addPat } ) : -1;//事前に取得して軽くする
		
		local call_HitMukiEff = function( info, hitEff ) : (pat_num_HitPattern, pat_num_AddHitPattern)
		{
			local angleMukiType = BMvTbl.GetPP(def_PP_HitEffectMuki);
			BMvTbl.SetPP(def_PP_HitEffectMuki,1-angleMukiType);
			
			local tmpAngle = BMvEff.Random_Limit( 1000 );
			
			//(2500/2)-500 = 1250-500 750
			local randAngle = 5000 + (angleMukiType * 2500 + 750 + tmpAngle);
			
			//画面座標を相対座標に変更
			local createPos = Battle_Std.GetCreatePosition( BMvEff.GetAttackHitPos() );
			
			if( pat_num_HitPattern != -1 )
			{
				local eff = BMvEff.CreateObject( { datatype=hitEff.datatype, start_pat=pat_num_HitPattern, x=createPos.x, y=createPos.y } );
				if( eff.push() )
				{
					BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } ); //時間停止の影響を受けない
					BMvTbl.SetAngle( { angle=randAngle } );
					
					eff.pop();
				}
			}
			if( pat_num_AddHitPattern != -1 )
			{
				local eff = BMvEff.CreateObject( { datatype=hitEff.datatype, start_pat=pat_num_AddHitPattern, x=createPos.x, y=createPos.y } );
				if( eff.push() )
				{
					BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } ); //時間停止の影響を受けない
					BMvTbl.SetAngle( { angle=randAngle } );
					
					eff.pop();
				}
			}
		}
		
		//事前にPATを取得する関係で別関数に変更＆addpatは不要なので処理を削除
		local pat_num_BaseHitPattern = (base_hitEff)? BMvEff.GetPatternNum( { datatype=base_hitEff.datatype, pat=base_hitEff.pat } ) : pat_num_HitPattern;//事前に取得して軽くする
		
		local call_BaseHitMukiEff = function( info, hitEff ) : (pat_num_BaseHitPattern)
		{
			local angleMukiType = BMvTbl.GetPP(def_PP_HitEffectMuki);
			BMvTbl.SetPP(def_PP_HitEffectMuki,1-angleMukiType);
			
			local tmpAngle = BMvEff.Random_Limit( 1000 );
			
			//(2500/2)-500 = 1250-500 750
			local randAngle = 5000 + (angleMukiType * 2500 + 750 + tmpAngle);
			
			//画面座標を相対座標に変更
			local createPos = Battle_Std.GetCreatePosition( BMvEff.GetAttackHitPos() );
			
			if( pat_num_BaseHitPattern != -1 )
			{
				local eff = BMvEff.CreateObject( { datatype=hitEff.datatype, start_pat=pat_num_BaseHitPattern, x=createPos.x, y=createPos.y } );
				if( eff.push() )
				{
					BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } ); //時間停止の影響を受けない
					BMvTbl.SetAngle( { angle=randAngle } );
					
					eff.pop();
				}
			}
		}		
		
		switch( angleType )
		{
		case BCTF_AngleType_HitVector:// 1
			retmv = function( info ) : (hitEff, pat_num_HitPattern, pat_num_AddHitPattern)
			{
				local hitEffAngle = Battle_Std.GetHitEffectAngle( info );
				
				//画面座標を相対座標に変更
				local createPos = Battle_Std.GetCreatePosition( BMvEff.GetAttackHitPos() );
				
				if( pat_num_HitPattern != -1 )
				{
					local eff = BMvEff.CreateObject( { datatype=hitEff.datatype, start_pat=pat_num_HitPattern, x=createPos.x, y=createPos.y } );
					if( eff.push() )
					{
						BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } ); //時間停止の影響を受けない
						BMvTbl.SetAngle( { angle_float=hitEffAngle } );
						
						eff.pop();
					}
				}
				if( pat_num_AddHitPattern != -1 )
				{
					local eff = BMvEff.CreateObject( { datatype=hitEff.datatype, start_pat=pat_num_AddHitPattern, x=createPos.x, y=createPos.y } );
					if( eff.push() )
					{
						BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } ); //時間停止の影響を受けない
						BMvTbl.SetAngle( { angle_float=hitEffAngle } );
						
						eff.pop();
					}
				}
			}
			break;
		case BCTF_AngleType_HitMuki:// 2
			retmv = function( info ) : (hitEff, call_HitMukiEff)
			{
				call_HitMukiEff( info, hitEff );
			}
			break;
		case BCTF_AngleType_HitMuki_SwitchAltInvisible: //3 セイバー用
			retmv = function( info ) : (hitEff, base_hitEff, call_HitMukiEff, call_BaseHitMukiEff)
			{
				if( Battle_Std.Chr_Alt.IsInvisible() && base_hitEff )
				{
					call_BaseHitMukiEff( info, base_hitEff);
				}
				else
				{
					call_HitMukiEff( info, hitEff);
				}
			}
			break;
		case BCTF_AngleType_Random:// 0
		default:
			retmv = function( info ) : (hitEff, pat_num_HitPattern, pat_num_AddHitPattern)
			{
				//画面座標を相対座標に変更
				local createPos = Battle_Std.GetCreatePosition( BMvEff.GetAttackHitPos() );
				local randAngle = BMvEff.Random_Limit( 10000 );

				if( pat_num_HitPattern != -1 )
				{
					local eff = BMvEff.CreateObject( { datatype=hitEff.datatype, start_pat=pat_num_HitPattern, x=createPos.x, y=createPos.y } );
					if( eff.push() )
					{
						BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } ); //時間停止の影響を受けない
						BMvTbl.SetAngle( { angle=randAngle } );
						
						eff.pop();
					}
				}
				if( pat_num_AddHitPattern != -1 )
				{
					local eff = BMvEff.CreateObject( { datatype=hitEff.datatype, start_pat=pat_num_AddHitPattern, x=createPos.x, y=createPos.y } );
					if( eff.push() )
					{
						BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } ); //時間停止の影響を受けない
						BMvTbl.SetAngle( { angle=randAngle } );
						
						eff.pop();
					}
				}
			}
			break;
		}
		return retmv;
	}
	
	local makemv_UNISlash_HitEff = function( param={} )
	{
		local pat_num_HitPattern = BMvEff.GetPatternNum( { datatype=param.datatype, pat=param.pat } );
		
		local retmv = function( info ) : (param, pat_num_HitPattern)
		{
			if( pat_num_HitPattern != -1 )
			{
				// print("\n param.pat:"+param.pat+" pat_num_HitPattern:"+pat_num_HitPattern+" param.datatype:"+param.datatype);
				local pos = BMvEff.GetAttackHitPos(); //ヒットエフェクトの座標を取得
				local eff = BMvEff.CreateObject( { datatype=param.datatype, start_pat=pat_num_HitPattern, } );
				if( eff.push() )
				{
					BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } ); //時間停止の影響を受けない
					BMvTbl.SetPosition( pos );
					
					eff.pop();
				}
			}
		}
		return retmv;
	}
	
	//A:弱
	//B:中　制限時:
	//C:強　制限時:
	//D:特　制限時:
	//F:〆　※SEが違うだけ
	
	// Limit系を作るときの注意点
	// VectorTableにwordexだけでなくword側にも登録する…必要はない
	// 判定ツールにもからのデータ＋SE呼び出しを登録する
	
	// 仕様メモ
	// パンチ、キック、斬り、突きはSEが固定（もとのMvと同一名のPATから呼ばれるため）
	// 上記で変更できるのは見た目のみで、SEは変わらない
	// 専用SEを使いたい場合は、キャラ固有を使うこと
	
	std.Mv_Eff_Hit_PunchA <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_PunchA", angle_type=BCTF_AngleType_HitVector } );
	std.Mv_Eff_Hit_PunchB <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_PunchB", addPat="Grp_Hit_BackFireB", angle_type=BCTF_AngleType_HitVector } );
	std.Mv_Eff_Hit_PunchC <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_PunchC", addPat="Grp_Hit_BackFire", angle_type=BCTF_AngleType_HitVector } );
	std.Mv_Eff_Hit_PunchD <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_PunchD", addPat="Grp_Hit_BackFire", angle_type=BCTF_AngleType_HitVector } );
	std.Mv_Eff_Hit_PunchFinish <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_PunchD", addPat="Grp_Hit_BackFire", angle_type=BCTF_AngleType_HitVector } );
	std.Mv_Eff_Hit_PunchBLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_PunchBLimit", angle_type=BCTF_AngleType_HitVector } ); // 間引き
	std.Mv_Eff_Hit_PunchCLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_PunchCLimit", angle_type=BCTF_AngleType_HitVector } ); // 間引き

	std.Mv_Eff_Hit_Kick <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_Kick", angle_type=BCTF_AngleType_HitVector } );
	std.Mv_Eff_Hit_KickA <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_KickA", angle_type=BCTF_AngleType_HitVector } );
	std.Mv_Eff_Hit_KickB <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_KickB", addPat="Grp_Hit_BackFireB", angle_type=BCTF_AngleType_HitVector } );
	std.Mv_Eff_Hit_KickC <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_KickC", addPat="Grp_Hit_BackFire", angle_type=BCTF_AngleType_HitVector } );
	std.Mv_Eff_Hit_KickD <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_KickD", addPat="Grp_Hit_BackFire", angle_type=BCTF_AngleType_HitVector } );
	std.Mv_Eff_Hit_KickFinish <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_KickD", addPat="Grp_Hit_BackFire", angle_type=BCTF_AngleType_HitVector } );
	std.Mv_Eff_Hit_KickBLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_KickBLimit", angle_type=BCTF_AngleType_HitVector } ); // 間引き
	std.Mv_Eff_Hit_KickCLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_KickCLimit", angle_type=BCTF_AngleType_HitVector } ); // 間引き

	// std.Mv_Eff_Hit_SlashOld <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_SlashOld", angle_type=BCTF_AngleType_HitMuki } );
	std.Mv_Eff_Hit_SlashOld <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_SlashC", angle_type=BCTF_AngleType_HitMuki } );
	std.Mv_Eff_Hit_SlashOldLimit <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_SlashCLimit", angle_type=BCTF_AngleType_HitMuki } );//間引き
	
	std.Mv_Eff_Hit_Fire <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_Fire" } );
	std.Mv_Eff_Hit_Freeze <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_Freeze" } );
	std.Mv_Eff_Hit_Thunder <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_Thunder" } );
	std.Mv_Eff_Hit_FlashA <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_FlashB" } );
	std.Mv_Eff_Hit_FlashB <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_FlashB" } );
	// std.Mv_Eff_Hit_Flash <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_Flash" } );
	
	std.Mv_Eff_Hit_Catch <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_Catch" } );
	
	if( _ChrNo == Def_ChrNo_Chr000 )
	{
		
		
		std.Mv_Eff_Hit_Thrust <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_Chr000SlashCLimit", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustA <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_Chr000SlashA", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustB <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_Chr000SlashB", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustC <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_Chr000SlashC", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustD <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_Chr000SlashD", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustFinish <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_Chr000SlashD", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustBLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_Chr000SlashBLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き
		std.Mv_Eff_Hit_ThrustCLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_Chr000SlashCLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き
		
		std.Mv_Eff_Hit_Slash <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_Chr000SlashCLimit", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashA <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_Chr000SlashA", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashB <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_Chr000SlashB", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashC <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_Chr000SlashC", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashD <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_Chr000SlashD", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashFinish <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_Chr000SlashD", angle_type=BCTF_AngleType_HitMuki } );	
		std.Mv_Eff_Hit_SlashBLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_Chr000SlashBLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き
		std.Mv_Eff_Hit_SlashCLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_Chr000SlashCLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き
	}
	else if( _ChrNo == Def_ChrNo_Chr002 )
	{
		std.Mv_Eff_Hit_Thrust <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_Chr002SlashCLimit", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustA <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_Chr002SlashA", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustB <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_Chr002SlashB", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustC <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_Chr002SlashC", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustD <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_Chr002SlashD", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustFinish <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_Chr002SlashD", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustBLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_Chr002SlashBLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き
		std.Mv_Eff_Hit_ThrustCLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_Chr002SlashCLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き
		
		std.Mv_Eff_Hit_Slash <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_Chr002SlashCLimit", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashA <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_Chr002SlashA", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashB <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_Chr002SlashB", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashC <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_Chr002SlashC", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashD <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_Chr002SlashD", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashFinish <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_Chr002SlashD", angle_type=BCTF_AngleType_HitMuki } );	
		std.Mv_Eff_Hit_SlashBLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_Chr002SlashBLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き
		std.Mv_Eff_Hit_SlashCLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_Chr002SlashCLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き
	}
	else if( _ChrNo == Def_ChrNo_Chr003 )
	{
		std.Mv_Eff_Hit_Thrust <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_MaganCLimit", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustA <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_MaganA", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustB <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_MaganB", addPat="Grp_Hit_BackMaganB", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustC <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_MaganC", addPat="Grp_Hit_BackMaganC", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustD <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_MaganD", addPat="Grp_Hit_BackMaganC", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustFinish <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_MaganD", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustBLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_MaganBLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き
		std.Mv_Eff_Hit_ThrustCLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_MaganCLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き
		
		std.Mv_Eff_Hit_Slash <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_MaganCLimit", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashA <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_MaganA", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashB <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_MaganB", addPat="Grp_Hit_BackMaganB", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashC <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_MaganC", addPat="Grp_Hit_BackMaganC", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashD <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_MaganD", addPat="Grp_Hit_BackMaganC", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashFinish <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_MaganD", angle_type=BCTF_AngleType_HitMuki } );	
		std.Mv_Eff_Hit_SlashBLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_MaganBLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き
		std.Mv_Eff_Hit_SlashCLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_MaganCLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き
	}
	else if( _ChrNo == Def_ChrNo_Chr023 )
	{
		std.Mv_Eff_Hit_SlashA <- makemv_UNISlash_HitEff( { datatype=0, pat="Grp_Hit_HydSlashA" } );
		std.Mv_Eff_Hit_SlashB <- makemv_UNISlash_HitEff( { datatype=0, pat="Grp_Hit_HydSlashB" } );
		std.Mv_Eff_Hit_SlashC <- makemv_UNISlash_HitEff( { datatype=0, pat="Grp_Hit_HydSlashC" } );
		std.Mv_Eff_Hit_SlashD <- makemv_UNISlash_HitEff( { datatype=0, pat="Grp_Hit_HydSlashD" } );
		std.Mv_Eff_Hit_SlashFinish <- makemv_UNISlash_HitEff( { datatype=0, pat="Grp_Hit_HydSlashD" } );
		std.Mv_Eff_Hit_SlashBLimit <- makemv_UNISlash_HitEff( { datatype=0, pat="Grp_Hit_HydSlashBLimit" } );
		std.Mv_Eff_Hit_SlashCLimit <- makemv_UNISlash_HitEff( { datatype=0, pat="Grp_Hit_HydSlashCLimit" } );

		std.Mv_Eff_Hit_ThrustA <- makemv_UNISlash_HitEff( { datatype=0, pat="Grp_Hit_HydSlashA" } );
		std.Mv_Eff_Hit_ThrustB <- makemv_UNISlash_HitEff( { datatype=0, pat="Grp_Hit_HydSlashB" } );
		std.Mv_Eff_Hit_ThrustC <- makemv_UNISlash_HitEff( { datatype=0, pat="Grp_Hit_HydSlashC" } );
		std.Mv_Eff_Hit_ThrustD <- makemv_UNISlash_HitEff( { datatype=0, pat="Grp_Hit_HydSlashD" } );
		std.Mv_Eff_Hit_ThrustFinish <- makemv_UNISlash_HitEff( { datatype=0, pat="Grp_Hit_HydSlashD" } );
		std.Mv_Eff_Hit_ThrustBLimit <- makemv_UNISlash_HitEff( { datatype=0, pat="Grp_Hit_HydSlashBLimit" } );
		std.Mv_Eff_Hit_ThrustCLimit <- makemv_UNISlash_HitEff( { datatype=0, pat="Grp_Hit_HydSlashCLimit" } );
	}
	else if( _ChrNo == Def_ChrNo_Chr024 )
	{
		std.Mv_Eff_Hit_Thrust <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_NANMaganCLimit", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustA <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_NANMaganA", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustB <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_NANMaganB", addPat="Grp_Hit_NANBackMaganB", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustC <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_NANMaganC", addPat="Grp_Hit_NANBackMaganC", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustD <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_NANMaganD", addPat="Grp_Hit_NANBackMaganC", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustFinish <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_NANMaganD", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustBLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_NANMaganBLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き
		std.Mv_Eff_Hit_ThrustCLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_NANMaganCLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き
		
		std.Mv_Eff_Hit_Slash <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_NANMaganCLimit", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashA <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_NANMaganA", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashB <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_NANMaganB", addPat="Grp_Hit_NANBackMaganB", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashC <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_NANMaganC", addPat="Grp_Hit_NANBackMaganC", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashD <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_NANMaganD", addPat="Grp_Hit_NANBackMaganC", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashFinish <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_NANMaganD", angle_type=BCTF_AngleType_HitMuki } );	
		std.Mv_Eff_Hit_SlashBLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_NANMaganBLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き
		std.Mv_Eff_Hit_SlashCLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_NANMaganCLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き
	}
	else if( _ChrNo == Def_ChrNo_Chr011 )
	{
		std.Mv_Eff_Hit_Thrust <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_Thrust", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustA <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_KokkenA", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustB <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_KokkenB", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustC <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_KokkenC", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustD <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_KokkenD", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustFinish <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_KokkenD", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustBLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_KokkenBLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き
		std.Mv_Eff_Hit_ThrustCLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_KokkenCLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き
		
		std.Mv_Eff_Hit_Slash <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_Slash", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashA <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_KokkenA", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashB <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_KokkenB", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashC <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_KokkenC", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashD <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_KokkenD", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashFinish <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_KokkenD", angle_type=BCTF_AngleType_HitMuki } );	
		std.Mv_Eff_Hit_SlashBLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_KokkenBLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き
		std.Mv_Eff_Hit_SlashCLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_KokkenCLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き
	}
	else if( _ChrNo == Def_ChrNo_Chr012 )
	{
		std.Mv_Eff_Hit_Thrust <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_ExsSlashC", angle_type=BCTF_AngleType_HitMuki_SwitchAltInvisible, base = { datatype=1, pat="Grp_Hit_Thrust", angle_type=BCTF_AngleType_HitMuki } } );
		std.Mv_Eff_Hit_ThrustA <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_ExsSlashA", angle_type=BCTF_AngleType_HitMuki_SwitchAltInvisible, base = { datatype=1, pat="Grp_Hit_ThrustA", angle_type=BCTF_AngleType_HitMuki } } );
		std.Mv_Eff_Hit_ThrustB <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_ExsSlashB", angle_type=BCTF_AngleType_HitMuki_SwitchAltInvisible, base = { datatype=1, pat="Grp_Hit_ThrustB", angle_type=BCTF_AngleType_HitMuki } } );
		std.Mv_Eff_Hit_ThrustC <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_ExsSlashC", angle_type=BCTF_AngleType_HitMuki_SwitchAltInvisible, base = { datatype=1, pat="Grp_Hit_ThrustC", angle_type=BCTF_AngleType_HitMuki } } );
		std.Mv_Eff_Hit_ThrustD <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_ExsSlashD", angle_type=BCTF_AngleType_HitMuki_SwitchAltInvisible, base = { datatype=1, pat="Grp_Hit_ThrustD", angle_type=BCTF_AngleType_HitMuki } } );
		std.Mv_Eff_Hit_ThrustFinish <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_ExsSlashD", angle_type=BCTF_AngleType_HitMuki_SwitchAltInvisible, base = { datatype=1, pat="Grp_Hit_ThrustD", angle_type=BCTF_AngleType_HitMuki } } );
		std.Mv_Eff_Hit_ThrustBLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_ExsSlashBLimit", angle_type=BCTF_AngleType_HitMuki_SwitchAltInvisible, base = { datatype=1, pat="Grp_Hit_ThrustBLimit", angle_type=BCTF_AngleType_HitMuki } } ); // 間引き
		std.Mv_Eff_Hit_ThrustCLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_ExsSlashCLimit", angle_type=BCTF_AngleType_HitMuki_SwitchAltInvisible, base = { datatype=1, pat="Grp_Hit_ThrustCLimit", angle_type=BCTF_AngleType_HitMuki } } ); // 間引き
		
		std.Mv_Eff_Hit_Slash <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_ExsSlashC", angle_type=BCTF_AngleType_HitMuki_SwitchAltInvisible, base = { datatype=1, pat="Grp_Hit_Slash", angle_type=BCTF_AngleType_HitMuki } } );
		std.Mv_Eff_Hit_SlashA <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_ExsSlashA", angle_type=BCTF_AngleType_HitMuki_SwitchAltInvisible, base = { datatype=1, pat="Grp_Hit_SlashA", angle_type=BCTF_AngleType_HitMuki } } );
		std.Mv_Eff_Hit_SlashB <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_ExsSlashB", angle_type=BCTF_AngleType_HitMuki_SwitchAltInvisible, base = { datatype=1, pat="Grp_Hit_SlashB", angle_type=BCTF_AngleType_HitMuki } } );
		std.Mv_Eff_Hit_SlashC <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_ExsSlashC", angle_type=BCTF_AngleType_HitMuki_SwitchAltInvisible, base = { datatype=1, pat="Grp_Hit_SlashC", angle_type=BCTF_AngleType_HitMuki } } );
		std.Mv_Eff_Hit_SlashD <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_ExsSlashD", angle_type=BCTF_AngleType_HitMuki_SwitchAltInvisible, base = { datatype=1, pat="Grp_Hit_SlashD", angle_type=BCTF_AngleType_HitMuki } } );
		std.Mv_Eff_Hit_SlashFinish <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_ExsSlashD", angle_type=BCTF_AngleType_HitMuki_SwitchAltInvisible, base = { datatype=1, pat="Grp_Hit_SlashD", angle_type=BCTF_AngleType_HitMuki } } );	
		std.Mv_Eff_Hit_SlashBLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_ExsSlashBLimit", angle_type=BCTF_AngleType_HitMuki_SwitchAltInvisible, base = { datatype=1, pat="Grp_Hit_SlashBLimit", angle_type=BCTF_AngleType_HitMuki } } ); // 間引き
		std.Mv_Eff_Hit_SlashCLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_ExsSlashCLimit", angle_type=BCTF_AngleType_HitMuki_SwitchAltInvisible, base = { datatype=1, pat="Grp_Hit_SlashCLimit", angle_type=BCTF_AngleType_HitMuki } } ); // 間引き
	}
	else
	{
		std.Mv_Eff_Hit_Thrust <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_Thrust", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustA <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_ThrustA", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustB <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_ThrustB", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustC <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_ThrustC", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustD <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_ThrustD", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustFinish <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_ThrustD", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_ThrustBLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_ThrustBLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き
		std.Mv_Eff_Hit_ThrustCLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_ThrustCLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き
		
		std.Mv_Eff_Hit_Slash <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_Slash", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashA <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_SlashA", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashB <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_SlashB", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashC <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_SlashC", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashD <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_SlashD", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_SlashFinish <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_SlashD", angle_type=BCTF_AngleType_HitMuki } );	
		std.Mv_Eff_Hit_SlashBLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_SlashBLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き
		std.Mv_Eff_Hit_SlashCLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_SlashCLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き
	}
	
	std.Mv_Eff_Hit_FireA <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_FireA", angle_type=BCTF_AngleType_HitMuki } );
	std.Mv_Eff_Hit_FireB <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_FireB", angle_type=BCTF_AngleType_HitMuki } );
	std.Mv_Eff_Hit_FireC <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_FireC", angle_type=BCTF_AngleType_HitMuki } );
	std.Mv_Eff_Hit_FireD <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_FireD", angle_type=BCTF_AngleType_HitMuki } );
	std.Mv_Eff_Hit_FireBLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_FireBLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き
	std.Mv_Eff_Hit_FireCLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_FireCLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き

	std.Mv_Eff_Hit_FreezeA <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_FreezeA", angle_type=BCTF_AngleType_HitMuki } );
	std.Mv_Eff_Hit_FreezeB <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_FreezeB", angle_type=BCTF_AngleType_HitMuki } );
	std.Mv_Eff_Hit_FreezeC <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_FreezeC", angle_type=BCTF_AngleType_HitMuki } );
	std.Mv_Eff_Hit_FreezeD <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_FreezeD", angle_type=BCTF_AngleType_HitMuki } );
	std.Mv_Eff_Hit_FreezeBLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_FreezeBLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き
	std.Mv_Eff_Hit_FreezeCLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_FreezeCLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き

	std.Mv_Eff_Hit_ThunderA <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_ThunderA", angle_type=BCTF_AngleType_HitVector } );
	std.Mv_Eff_Hit_ThunderB <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_ThunderB", angle_type=BCTF_AngleType_HitVector } );
	std.Mv_Eff_Hit_ThunderC <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_ThunderC", angle_type=BCTF_AngleType_HitVector } );
	std.Mv_Eff_Hit_ThunderD <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_ThunderD", angle_type=BCTF_AngleType_HitVector } );
	std.Mv_Eff_Hit_ThunderBLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_ThunderBLimit", angle_type=BCTF_AngleType_HitVector } ); // 間引き
	std.Mv_Eff_Hit_ThunderCLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_ThunderCLimit", angle_type=BCTF_AngleType_HitVector } ); // 間引き

	std.Mv_Eff_Hit_ThSlashA <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_ThSlashA", angle_type=BCTF_AngleType_HitMuki } );
	std.Mv_Eff_Hit_ThSlashB <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_ThSlashB", angle_type=BCTF_AngleType_HitMuki } );
	std.Mv_Eff_Hit_ThSlashC <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_ThSlashC", angle_type=BCTF_AngleType_HitMuki } );
	std.Mv_Eff_Hit_ThSlashD <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_ThSlashD", angle_type=BCTF_AngleType_HitMuki } );
	std.Mv_Eff_Hit_ThSlashBLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_ThSlashBLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き
	std.Mv_Eff_Hit_ThSlashCLimit <- makemv_Normal_HitEff(  { datatype=1, pat="Grp_Hit_ThSlashCLimit", angle_type=BCTF_AngleType_HitMuki } ); // 間引き

	std.Mv_BoundEffPar_Fire <- {};
	std.Mv_BoundEffPar_Ice <- {};
	std.Mv_BoundEffPar_Thunder <- {};
	std.Mv_BoundEffPar_BlackFire <- {};
	
	local pat_num_Grp_Hit_GuardLimit = BMvEff.GetPatternNum( { datatype=1, pat="Grp_Hit_GuardLimit" } );
	local pat_num_Grp_Hit_Guard = BMvEff.GetPatternNum( { datatype=1, pat="Grp_Hit_Guard" } );
	local pat_num_Grp_Par_GuardA = BMvEff.GetPatternNum( { datatype=1, pat="Grp_Par_GuardA" } );
	local pat_num_Grp_Par_GuardB = BMvEff.GetPatternNum( { datatype=1, pat="Grp_Par_GuardB" } );
	local pat_num_Grp_Par_GuardMinA = BMvEff.GetPatternNum( { datatype=1, pat="Grp_Par_GuardMinA" } );
	local pat_num_Grp_Par_GuardMinB = BMvEff.GetPatternNum( { datatype=1, pat="Grp_Par_GuardMinB" } );

	local call_guard_effect = function( info, limit ) : (pat_num_Grp_Hit_GuardLimit,pat_num_Grp_Hit_Guard,pat_num_Grp_Par_GuardA,pat_num_Grp_Par_GuardB,pat_num_Grp_Par_GuardMinA,pat_num_Grp_Par_GuardMinB)
	{
		local createPos = Battle_Std.GetCreatePosition( BMvEff.GetAttackHitPos() );
		
		//ガードエフェクトのサイズ切り替え
		local bvs = BtlMvStd.GetBoundVectorStatus( info.vectortype, 0 );
		local pw = bvs.GetPower();
		// _dpn("pw:"+pw);
		
		local effect_param = {
			size = 13000,
			par_pat = [pat_num_Grp_Par_GuardA,pat_num_Grp_Par_GuardB],
			par_size = 13000,
		}		
		
		if( pw&(def_BS_Pow_LV1|def_BS_Pow_LV0) )
		{
			// _dpn("弱");
			
			effect_param.size = 10000;
			effect_param.par_pat = [pat_num_Grp_Par_GuardMinA,pat_num_Grp_Par_GuardMinB];
			effect_param.par_size = 10000;
		}
		else if( pw&def_BS_Pow_LV3 )
		{
			// _dpn("強");
			effect_param.size = 16000;
			effect_param.par_size = 16000;
		}
		// else
		// {
			// _dpn("中");
		// }
		
		//このときのパターンだったりMvだったりはプレイヤーや飛び道具の判定側になってしまう
		local use_pat = (limit)? pat_num_Grp_Hit_GuardLimit : pat_num_Grp_Hit_Guard;
		// print("\n p:"+effect_param.size+" use_pat:"+use_pat+" my:"+BMvTbl.GetMvName() );
		
		local eff = BMvEff.CreateObject( { datatype=1, start_pat=use_pat, x=createPos.x, y=createPos.y } );
		if( eff.push() )
		{
			BMvTbl.SetScale( { x=effect_param.size, y=effect_param.size } );
			BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround } ); //時間停止の影響を受けない
			
			if( !limit )
			{
				local use_pat = effect_param.par_pat[ BMvEff.Random_Limit(effect_param.par_pat.len()) ];
				local eff = BMvEff.CreateObject( { datatype=1, start_pat=use_pat } );
				if( eff.push() )
				{
					BMvTbl.SetScale( { x=effect_param.par_size, y=effect_param.par_size } );
					BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround } ); //時間停止の影響を受けない
					
					eff.pop();
				}
			}
			
			eff.pop();
		}		
	}
	
	local pat_num_Grp_Hit_GuardExLimit = BMvEff.GetPatternNum( { datatype=1, pat="Grp_Hit_GuardExLimit" } ); // パターン文字列のパターン番号を事前取得
	local pat_num_Grp_Hit_GuardEx = BMvEff.GetPatternNum( { datatype=1, pat="Grp_Hit_GuardEx" } ); // パターン文字列のパターン番号を事前取得
	
	local call_shield_effect = function( info, limit ) : (pat_num_Grp_Hit_GuardExLimit,pat_num_Grp_Hit_GuardEx)
	{
		local createPos = Battle_Std.GetCreatePosition( BMvEff.GetAttackHitPos() );
		
		//エフェクトのサイズ切り替え
		local bvs = BtlMvStd.GetBoundVectorStatus( info.vectortype, 0 );
		local pw = bvs.GetPower();
		// _dpn("pw:"+pw);
		
		local effect_param = {
			size = 13000,
			par_num = 10,
		}		
		
		if( pw&(def_BS_Pow_LV1|def_BS_Pow_LV0) )
		{
			// _dpn("弱");
			
			effect_param.size = 10000;
			effect_param.par_num = 8;
		}
		else if( pw&def_BS_Pow_LV3 )
		{
			// _dpn("強");
			effect_param.size = 16000;
			effect_param.par_num = 14;
		}
		
		//このときのパターンだったりMvだったりはプレイヤーや飛び道具の判定側になってしまう
		local use_pat = (limit)? pat_num_Grp_Hit_GuardExLimit : pat_num_Grp_Hit_GuardEx;
		// print("\n p:"+effect_param.size+" use_pat:"+use_pat+" my:"+BMvTbl.GetMvName() );
		
		local eff = BMvEff.CreateObject( { datatype=1, mvname="Mv_ShieldGuardEffect", start_pat=use_pat, x=createPos.x, y=createPos.y } );
		if( eff.push() )
		{
			BMvTbl.SetScale( { x=effect_param.size, y=effect_param.size } );
			BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround } ); //時間停止の影響を受けない
			
			BMvTbl.SetLP(0, (limit)? 1 : 0 );
			BMvTbl.SetLP(1, effect_param.par_num );
			eff.pop();
		}
	}	

	// ガード
	std.Mv_Eff_Hit_Guard <- function( info ) : (call_guard_effect)
	{
		call_guard_effect( info, 0 );
	};
	std.Mv_Eff_Hit_GuardEx <- function( info ) : (call_shield_effect)
	{
		call_shield_effect( info, 0 );
	};
	
	std.Mv_Eff_Hit_GuardLimit <- function( info ) : (call_guard_effect)
	{
		call_guard_effect( info, 1 );
	}; // ガード間引き
	std.Mv_Eff_Hit_GuardExLimit <- function( info ) : (call_shield_effect)
	{
		call_shield_effect( info, 1 );
	}; // ガード間引き
	
	std.Mv_Eff_Hit_Counter <- function( info ) {};
	
	std.Mv_Eff_Sousai <- function( info )
	{
	}
	
	// キャラクター固有ヒットエフェクト定義
	
	// 固有エフェクトに、通常のエフェクトを重ねて呼び出す
	// SEはならないので注意
	// パンチとかキックはMvと同一名のPAT側でSEを呼んでいるが、こっちは鳴らない
	// 専用SEを使いたい場合などは必ずこっちを使うことになる
	
	local makemv_ChaAtk_HitEff = function( chrhiteff )
	{
		local retmv = function( info ) : (chrhiteff)
		{
			local hitEffAngle = Battle_Std.GetHitEffectAngle( info );
			//画面座標を相対座標に変更
			local createPos = Battle_Std.GetCreatePosition( BMvEff.GetAttackHitPos() );
			
			local eff = BMvEff.CreateObject( { datatype=chrhiteff.datatype, start_pat=chrhiteff.pat, x=createPos.x, y=createPos.y } );
			if( eff.push() )
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } ); //時間停止の影響を受けない
				if( chrhiteff.MaxFrameID ) BMvTbl.JumpFrameID( BMvEff.Random_Limit(chrhiteff.MaxFrameID) );
				BMvTbl.SetAngle( { angle_float=hitEffAngle } );
				
				eff.pop();
			}
			//addpat
			eff = BMvEff.CreateObject( { datatype=1, start_pat=chrhiteff.addpat, x=createPos.x, y=createPos.y } );
			if( eff.push() )
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } ); //時間停止の影響を受けない
				BMvTbl.SetAngle( { angle_float=hitEffAngle } );
				
				eff.pop();
			}
		}
		return retmv;
	}
	
	// 固有ヒットエフェクト処理
	// if( _ChrNo == Def_ChrNo_Cha )
	{
		// std.Mv_Eff_Hit_Chr1Atk  <- makemv_ChaAtk_HitEff( { datatype=0, pat="eff_DahHitFlash", MaxFrameID=1, addpat="Grp_Hit_Slash" } ); // 間引き
		// std.Mv_Eff_Hit_Chr1AtkLow  <- makemv_ChaAtk_HitEff( { datatype=0, pat="eff_DahHitFlash", MaxFrameID=1, addpat="Grp_Hit_SlashLow" } ); // 中間引き
		// std.Mv_Eff_Hit_Chr1AtkA <- makemv_ChaAtk_HitEff( { datatype=0, pat="eff_DahHitFlashA", MaxFrameID=1, addpat="Grp_Hit_SlashA" } ); // 弱
		// std.Mv_Eff_Hit_Chr1AtkB <- makemv_ChaAtk_HitEff( { datatype=0, pat="eff_DahHitFlashA", MaxFrameID=1, addpat="Grp_Hit_SlashB" } ); // 中
		// std.Mv_Eff_Hit_Chr1AtkC <- makemv_ChaAtk_HitEff( { datatype=0, pat="eff_DahHitFlashB", MaxFrameID=1, addpat="Grp_Hit_SlashC" } ); // 強
		// std.Mv_Eff_Hit_Chr1AtkD <- makemv_ChaAtk_HitEff( { datatype=0, pat="eff_DahHitFlashB", MaxFrameID=1, addpat="Grp_Hit_SlashD" } ); // 特大
	}

	//完全な差し替え
	local makemv_ChaAtk_HitEff_Type2 = function( chrhiteff )
	{
		local pat_num_HitPattern = BMvEff.GetPatternNum( { datatype=chrhiteff.datatype, pat=chrhiteff.pat } );
		
		local retmv = function( info ) : (chrhiteff, pat_num_HitPattern)
		{
			if( pat_num_HitPattern != -1 )
			{
				local hitEffAngle = Battle_Std.GetHitEffectAngle( info );
				local createPos = Battle_Std.GetCreatePosition( BMvEff.GetAttackHitPos() );
				local eff = BMvEff.CreateObject( { datatype=chrhiteff.datatype, start_pat=chrhiteff.pat, x=createPos.x, y=createPos.y } );
				if( eff.push() )
				{
					BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } ); //時間停止の影響を受けない
					BMvTbl.SetAngle( { angle_float=hitEffAngle } );
					
					eff.pop();
				}
			}
			// ↑は共通なのでSEとかは外で呼び出す
			if( "se" in chrhiteff )
			{
				BSound.SE_Play( {type = _SeType_Player, num = chrhiteff.se } );
			}
		}
		return retmv;
	}	
	
	// このオブジェクトは1Pのものなので、SEとか再生しようとすると1PのSEがなってしまうようだ
	if( _ChrNo == Def_ChrNo_Chr000 )
	{
		std.Mv_Eff_Hit_Chr1Atk  <-    makemv_ChaAtk_HitEff_Type2( { datatype=1, pat="Grp_Hit_Tsuta" } ); // 間引き
		// std.Mv_Eff_Hit_Chr1AtkLow  <- makemv_ChaAtk_HitEff_Type2( { datatype=1, pat="Grp_Hit_SlashLow", } ); // 中間引き
		// std.Mv_Eff_Hit_Chr1AtkA <-    makemv_ChaAtk_HitEff_Type2( { datatype=1, pat="Grp_Hit_SlashA", } ); // 弱
		// std.Mv_Eff_Hit_Chr1AtkB <-    makemv_ChaAtk_HitEff_Type2( { datatype=1, pat="Grp_Hit_SlashB", } ); // 中
		std.Mv_Eff_Hit_Chr1AtkC  <-    makemv_ChaAtk_HitEff_Type2( { datatype=1, pat="Grp_Hit_Blood" } ); // 強
		std.Mv_Eff_Hit_Chr1AtkD  <-    makemv_ChaAtk_HitEff_Type2( { datatype=1, pat="Grp_Hit_BloodFinish" } ); // 特大
		// std.Mv_Eff_Hit_Chr1AtkC <- makemv_ChaAtk_HitEff( { datatype=0, pat="Grp_Hit_StarC", MaxFrameID=0, addpat="Grp_Hit_PunchC" } ); // 強
		// std.Mv_Eff_Hit_Chr1AtkC <- makemv_ChaAtk_HitEff( { datatype=0, pat="Grp_Hit_StarC", MaxFrameID=0, addpat="Grp_Hit_PunchC" } ); // 強
		// std.Mv_Eff_Hit_Chr1AtkD <-    makemv_ChaAtk_HitEff_Type2( { datatype=0, pat="Grp_Hit_LA" } ); // 特大
	}
	
	if( _ChrNo == Def_ChrNo_Chr001 )
	{
		std.Mv_Eff_Hit_Chr1Atk  <-      makemv_ChaAtk_HitEff_Type2( { datatype=0, pat="Grp_Hit_Star", } ); // 間引き　通常投げ★
		std.Mv_Eff_Hit_Chr1AtkD <-      makemv_ChaAtk_HitEff_Type2( { datatype=0, pat="Grp_Hit_LA", } ); // 特大　LAの乱舞
		std.Mv_Eff_Hit_Chr1AtkA <-      makemv_ChaAtk_HitEff_Type2( { datatype=1, pat="Grp_Hit_Kagu", } ); // 弱
		std.Mv_Eff_Hit_Chr1AtkB <-      makemv_ChaAtk_HitEff_Type2( { datatype=1, pat="Grp_Hit_Doku", } ); // 中
		std.Mv_Eff_Hit_Chr1AtkC <-      makemv_ChaAtk_HitEff( { datatype=0, pat="Grp_Hit_StarC", MaxFrameID=0, addpat="Grp_Hit_PunchC" } ); // 強
		
		// std.Mv_Eff_Hit_Chr2Atk  <-      makemv_ChaAtk_HitEff_Type2( { datatype=0, pat="Grp_Hit_Star", } ); // 間引き　通常投げ★
		// std.Mv_Eff_Hit_Chr2AtkD <-      makemv_ChaAtk_HitEff_Type2( { datatype=0, pat="Grp_Hit_LA", } ); // 特大　LAの乱舞
		std.Mv_Eff_Hit_Chr2AtkA <-      makemv_ChaAtk_HitEff_Type2( { datatype=1, pat="Grp_Hit_Kagu", } ); // 弱
		std.Mv_Eff_Hit_Chr2AtkB <-      makemv_ChaAtk_HitEff_Type2( { datatype=1, pat="Grp_Hit_Dust", } ); // 中
		std.Mv_Eff_Hit_Chr2AtkC <-      makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_FryingPan", angle_type=BCTF_AngleType_HitVector } );	
	}
	
	if( _ChrNo == Def_ChrNo_Chr004 )
	{
		std.Mv_Eff_Hit_Chr1Atk  <-      makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_Harisen", angle_type=BCTF_AngleType_HitVector } ); // 間引き　ハリセン
		std.Mv_Eff_Hit_Chr1AtkD <-      makemv_ChaAtk_HitEff_Type2( { datatype=1, pat="Grp_Hit_ComicalD", } ); // 特大
		std.Mv_Eff_Hit_Chr1AtkA <-      makemv_ChaAtk_HitEff_Type2( { datatype=1, pat="Grp_Hit_SoundWave", } ); // 弱
		std.Mv_Eff_Hit_Chr1AtkB <-      makemv_ChaAtk_HitEff_Type2( { datatype=1, pat="Grp_Hit_ComicalB", } ); // 中
		std.Mv_Eff_Hit_Chr1AtkC <-      makemv_ChaAtk_HitEff_Type2( { datatype=1, pat="Grp_Hit_ComicalC", } ); // 強
	}
	
	if( _ChrNo == Def_ChrNo_Chr008 )
	{
		std.Mv_Eff_Hit_Chr1AtkD <-      makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_BloodBlowD", angle_type=BCTF_AngleType_HitVector } ); // 特大
		// std.Mv_Eff_Hit_Chr1AtkA <-      makemv_ChaAtk_HitEff_Type2( { datatype=1, pat="Grp_Hit_SoundWave", } ); // 弱
		std.Mv_Eff_Hit_Chr1AtkB <-      makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_BloodBlowB", angle_type=BCTF_AngleType_HitVector } ); // 中
		std.Mv_Eff_Hit_Chr1AtkC <-      makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_BloodBlowC", angle_type=BCTF_AngleType_HitVector } ); // 強
	}
	
	if( _ChrNo == Def_ChrNo_Chr009 )
	{
		std.Mv_Eff_Hit_Chr1Atk  <-    makemv_ChaAtk_HitEff_Type2( { datatype=1, pat="Grp_Hit_BloodSplash" } ); // 間引き
	}	
	
	if( _ChrNo == Def_ChrNo_Chr010 || _ChrNo == Def_ChrNo_Chr019 )
	{
		std.Mv_Eff_Hit_Chr1AtkD <-      makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_WindD", angle_type=BCTF_AngleType_HitMuki } ); // 特大
		std.Mv_Eff_Hit_Chr1AtkB <-      makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_WindB", angle_type=BCTF_AngleType_HitMuki } ); // 中
		std.Mv_Eff_Hit_Chr1AtkC <-      makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_WindC", angle_type=BCTF_AngleType_HitMuki } ); // 強
	}
	
	if( _ChrNo == Def_ChrNo_Chr014 )
	{
		std.Mv_Eff_Hit_Chr1AtkC  <-    makemv_ChaAtk_HitEff_Type2( { datatype=1, pat="Grp_Hit_Blood" } ); // 強　投げ・空中投げ
		std.Mv_Eff_Hit_Chr1AtkD  <-    makemv_ChaAtk_HitEff_Type2( { datatype=1, pat="Grp_Hit_BloodFinish" } ); // 特大　LAとか用？
	}	
	
	if( _ChrNo == Def_ChrNo_Chr017 )
	{
		//LAの虹色ヒットエフェクト
		std.Mv_Eff_Hit_Chr1AtkB <-      makemv_ChaAtk_HitEff( { datatype=0, pat="Grp_Hit_SisterSlashB", MaxFrameID=0, addpat="Grp_Hit_SlashB" } ); // 中
		std.Mv_Eff_Hit_Chr1AtkC <-      makemv_ChaAtk_HitEff( { datatype=0, pat="Grp_Hit_SisterSlashC", MaxFrameID=0, addpat="Grp_Hit_SlashC" } ); // 強
		std.Mv_Eff_Hit_Chr2AtkC <-      makemv_ChaAtk_HitEff( { datatype=0, pat="Grp_Hit_SisterPunchC", MaxFrameID=0, addpat="Grp_Hit_PunchC" } ); // 強
	}
	
	if( _ChrNo == Def_ChrNo_Chr020 )
	{
		//盾による攻撃全般
		std.Mv_Eff_Hit_Chr1AtkB <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_ShieldSlashB", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_Chr1AtkC <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_ShieldSlashC", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_Chr1AtkD <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_ShieldSlashD", angle_type=BCTF_AngleType_HitMuki } );

		std.Mv_Eff_Hit_Chr1AtkBLimit <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_ShieldSlashBLimit", angle_type=BCTF_AngleType_HitMuki } );
		std.Mv_Eff_Hit_Chr1AtkCLimit <- makemv_Normal_HitEff( { datatype=1, pat="Grp_Hit_ShieldSlashCLimit", angle_type=BCTF_AngleType_HitMuki } );
	}
	
	//固有が定義されてるのに間引きエフェクト未定義ならコピーして同じものを入れておく
	//本当に間引きたい場合はキャラ別にちゃんと定義する。しないと同じものを出す
	if( !("Mv_Eff_Hit_Chr1AtkBLimit" in std ) && "Mv_Eff_Hit_Chr1AtkB" in std )
	{
		std.Mv_Eff_Hit_Chr1AtkBLimit <- std.Mv_Eff_Hit_Chr1AtkB;
	}
	if( !("Mv_Eff_Hit_Chr1AtkCLimit" in std ) && "Mv_Eff_Hit_Chr1AtkC" in std )
	{
		std.Mv_Eff_Hit_Chr1AtkCLimit <- std.Mv_Eff_Hit_Chr1AtkC;
	}
	if( !("Mv_Eff_Hit_Chr2AtkBLimit" in std ) && "Mv_Eff_Hit_Chr2AtkB" in std )
	{
		std.Mv_Eff_Hit_Chr2AtkBLimit <- std.Mv_Eff_Hit_Chr2AtkB;
	}
	if( !("Mv_Eff_Hit_Chr2AtkCLimit" in std ) && "Mv_Eff_Hit_Chr2AtkC" in std )
	{
		std.Mv_Eff_Hit_Chr2AtkCLimit <- std.Mv_Eff_Hit_Chr2AtkC;
	}
	
	
	//黒鍵ヒットエフェクト
	local throwKeyHitEff = function( chrhiteff )
	{
		//ヒット時に呼ぶエフェクト
		local HitEffects = {
			Normal = ["bkey_eff_hit","bkey_eff_hit2",],
			Limit = ["bkey_eff_hit_l","bkey_eff_hit2_l",],
		}
		
		local pat_num_ChrHitEff = BMvEff.GetPatternNum( { datatype=1, pat=chrhiteff.pat } );
		local pat_num_ChrHitAddEff0 = BMvEff.GetPatternNum( { datatype=0, pat=chrhiteff.addpat[0] } );
		local pat_num_ChrHitAddEff1 = BMvEff.GetPatternNum( { datatype=0, pat=chrhiteff.addpat[1] } );
		
		local retmv = function( info ) : (chrhiteff, HitEffects, pat_num_ChrHitEff, pat_num_ChrHitAddEff0, pat_num_ChrHitAddEff1)
		{
			// local hitEffAngle = Battle_Std.GetHitEffectAngle( info );
			local createPos = Battle_Std.GetCreatePosition( BMvEff.GetAttackHitPos() );
			
			//ヒットエフェクト
			local vec = BMvTbl.GetVector( { flags=_Vector_Normal } );
			local posst = BMvEff.GetAngle_FromVector( { x=vec.x, y=vec.y } );

			//黒鍵のヒットエフェクトを呼ぶ
			local bkey_limit = ( "limit" in chrhiteff)? chrhiteff.limit : 0;
			local eff = BMvEff.CreateObject( { datatype=1, start_pat=pat_num_ChrHitEff, x=createPos.x, y=createPos.y } );
			if( eff.push() )
			{
				BMvTbl.SetAngle( { angle_float=posst.angle } );
				BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
				eff.pop();
			}
			
			//その他のヒットエフェクト
			local create_param = { start_pat = pat_num_ChrHitAddEff0, x=createPos.x, y=createPos.y };
			local eff = BMvEff.CreateObject( create_param );
			if( eff.push() )
			{
				BMvTbl.SetAngle( { angle_float=posst.angle } );
				BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll |_ObjFlags_NoGround } );
				eff.pop();
			}

			local create_param = { start_pat = pat_num_ChrHitAddEff1, x=createPos.x, y=createPos.y };
			local eff = BMvEff.CreateObject( create_param );
			if( eff.push() )
			{
				BMvTbl.SetAngle( { angle_float=posst.angle } );
				BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll |_ObjFlags_NoGround } );
				eff.pop();
			}
		}
		return retmv;
	}
	if( _ChrNo == Def_ChrNo_Chr008 || _ChrNo == Def_ChrNo_Chr011 || _ChrNo == Def_ChrNo_Chr019 )
	{
		std.Mv_Eff_Hit_Chr2AtkC <-      throwKeyHitEff( { datatype=1, pat="Grp_Hit_ThrowKeyC", addpat=["bkey_eff_hit","bkey_eff_hit2"] } ); //
		std.Mv_Eff_Hit_Chr2AtkCLimit <- throwKeyHitEff( { datatype=1, pat="Grp_Hit_ThrowKeyCLimit", addpat=["bkey_eff_hit_l","bkey_eff_hit2_l"] } ); //
	}
	
	/*
	if( _ChrNo == Def_ChrNo_Chr003 )
	{
		// std.Mv_Eff_Hit_Chr1Atk  <-    makemv_ChaAtk_HitEff_Type2( { datatype=1, pat="Grp_Hit_MaganA", } ); // 強間引き
		// std.Mv_Eff_Hit_Chr1AtkLow  <- makemv_ChaAtk_HitEff_Type2( { datatype=1, pat="Grp_Hit_MaganA", } ); // 中間引き
		std.Mv_Eff_Hit_Chr1AtkA <-    makemv_ChaAtk_HitEff_Type2( { datatype=1, pat="Grp_Hit_MaganA", } ); // 弱
		std.Mv_Eff_Hit_Chr1AtkB <-    makemv_ChaAtk_HitEff_Type2( { datatype=1, pat="Grp_Hit_MaganB", } ); // 中
		std.Mv_Eff_Hit_Chr1AtkC <-    makemv_ChaAtk_HitEff_Type2( { datatype=1, pat="Grp_Hit_MaganC", } ); // 強
		std.Mv_Eff_Hit_Chr1AtkD <-    makemv_ChaAtk_HitEff_Type2( { datatype=1, pat="Grp_Hit_MaganD", } ); // 特大
	}
	*/
	
	/*
	st[0]  = { volumetype=0, type=-1, file=path+"Hit_PunchA" }; // 攻撃ヒット　弱パンチ
	st[1]  = { volumetype=0, type=-1, file=path+"Hit_PunchB" }; // 攻撃ヒット　中パンチ
	st[2]  = { volumetype=0, type=-1, file=path+"Hit_PunchC" }; // 攻撃ヒット　強パンチ
	st[3]  = { volumetype=0, type=-1, file=path+"Hit_PunchD" }; // 攻撃ヒット　特大パンチ

	st[4]  = { volumetype=0, type=-1, file=path+"Hit_KickA"  }; // 攻撃ヒット　弱キック
	st[5]  = { volumetype=0, type=-1, file=path+"Hit_KickB"  }; // 攻撃ヒット　中キック
	st[6]  = { volumetype=0, type=-1, file=path+"Hit_KickC"  }; // 攻撃ヒット　強キック
	st[7]  = { volumetype=0, type=-1, file=path+"Hit_KickD"  }; // 攻撃ヒット　特大キック

	st[8]  = { volumetype=0, type=-1, file=path+"Hit_SlashA" }; // 攻撃ヒット　弱斬り
	st[9]  = { volumetype=0, type=-1, file=path+"Hit_SlashB" }; // 攻撃ヒット　中斬り
	st[10] = { volumetype=0, type=-1, file=path+"Hit_SlashC" }; // 攻撃ヒット　強斬り
	st[11] = { volumetype=0, type=-1, file=path+"Hit_SlashD" }; // 攻撃ヒット　特大斬り

	st[12] = { volumetype=0, type=-1, file=path+"Hit_ThrustA"}; // 攻撃ヒット　弱突き
	st[13] = { volumetype=0, type=-1, file=path+"Hit_ThrustB"}; // 攻撃ヒット　中突き
	st[14] = { volumetype=0, type=-1, file=path+"Hit_ThrustC"}; // 攻撃ヒット　強突き
	st[15] = { volumetype=0, type=-1, file=path+"Hit_ThrustD"}; // 攻撃ヒット　特大突き
	*/

}

//よくある飛び道具のMvを簡易的に作成する
//着地、ヒット、相殺、被弾でのFrameIDを指定すると、そこに飛ぶようになる
//ヒット後に時間停止をなくしたりした方がいい弾が多いので、あまり多様はしないこと
//相殺は仕様がなくなったので動かないようにした
Battle_Std.MakeFireBallTmpl <- function( param={} )
{
	local retMv = {
		flags = def_FBTmplFlags_NewTypeFireBall,
	};
	
	local mvParam = {
		LandJumpID = ( "LandJumpID" in param )? param.LandJumpID : 0,
		HitJumpID = ( "HitJumpID" in param )? param.HitJumpID : 0,
		SousaiJumpID = 0, // SousaiJumpID = ( "SousaiJumpID" in param )? param.SousaiJumpID : 0,
		BlockedJumpID = ( "BlockedJumpID" in param )? param.BlockedJumpID : 0,
	}
	
	retMv.Init_After <- function()
	{
	}
	
	if( mvParam.LandJumpID )
	{
		retMv.LandTiming <- function() : (mvParam)
		{
			BMvTbl.JumpFrameID( mvParam.LandJumpID );
		}
	}
	if( mvParam.HitJumpID )
	{
		retMv.HitTiming <- function() : (mvParam)
		{
			BMvTbl.JumpFrameID( mvParam.HitJumpID );
		}
	}
	/*
	if( mvParam.SousaiJumpID )
	{
		retMv.Sousai <- function() : (mvParam)
		{
			BMvTbl.JumpFrameID( mvParam.SousaiJumpID );
		}
	}
	*/
	if( mvParam.BlockedJumpID )
	{
		retMv.Blocked <- function() : (mvParam)
		{
			if( BMvTbl.GetMvStatus().FrameID != mvParam.BlockedJumpID )
			{
				BMvTbl.JumpFrameID( mvParam.BlockedJumpID );
			}
		}
	}
	
	return retMv;
}

print("\n btl_MakeChrTableFunc.....OK");
