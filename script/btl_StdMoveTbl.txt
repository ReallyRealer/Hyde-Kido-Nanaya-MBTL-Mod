btl_debPrint2( "\n>>> [btl_StdMoveTbl]" );


//すごい長い関数
//_ChrNo:キャラ番号を指定する

function Battle_Std::GetStdMoveTable( _ChrNo=0, ) {

local _TagCharaNo = BMvCore.GetCharaNo();//ヒスコハなら7みたいなタッグ番号を返す

// ----------------------------------------------------------------------------
//キャラクター別のmvを作るとき用の関数
// ----------------------------------------------------------------------------
_dp1p("\n[btl_ChrParamFunc]");
local CHRMAX = 100; //キャラ番号最大値
local chrparam = {};

chrparam.Param <- {}; //キャラ別の細かいフレームとかのテーブル
chrparam.Get <- function( tbl={} ) //chrparam.Paramから作成中のキャラ番号の値を取ってくる
{
	local checktype = tbl.type;
	local checkchrnum = tbl.chrnum;
	
	if( checktype in Param )
	{
		local ret = Param[checktype][checkchrnum];
		btl_debPrint_CharacterMake("【定義】chrparam:"+checktype+" chr:"+checkchrnum+" -> "+ret);
		return ret;
	}
	else
	{
		btl_debError_CharacterMake("【警告】chrparamで未定義:"+checktype+" chr:"+checkchrnum);
		return 0;
	}
}

{	// ダッシュ停止不能Ｆ
	//ダッシュのタメを抜けてから、とまれるようになるまでの時間）
	//行動可能になってからどれだけの間停止に移行できないか
	//FrameID100があって停止できるMvでないと意味がない
	//これが長いと小刻みな動きができなくなる
	//少なすぎると慣性つけたダッシュ弱攻撃をやるのがやや難しくなる
	//停止モーションまでいけばリセット（ガードできる）ので"ダッシュガード不能Ｆ"より長くてもＯＫ
	
	//"ダッシュ攻撃不能Ｆ だけ硬直で、その後は行動可能だがガードはできない。dashstop_frame を超えるとダッシュ停止に進めるのでガードができる。
	
	local type = "ダッシュ停止不能Ｆ";
	chrparam.Param[type] <- array(CHRMAX, 8); // 1.2X:10
	// chrparam.Param[type][Def_ChrNo_Chr011] = 8; // 1.2X:10
	// chrparam.Param[type][Def_ChrNo_Chr014] = 8; // 1.2X:10	
	
	if( _TagCharaNo == Def_ChrNo_Chr007 ) // ヒスコハ
	{
		chrparam.Param[type][Def_ChrNo_Chr001] = 6;
		chrparam.Param[type][Def_ChrNo_Chr004] = 6;
	}	
}

{
	//ダッシュしてから技が出せるようになるまでのF
	//＝行動不能フレーム
	//先行入力はきくけど、微ダッシュ攻撃をできないようにする仕様
	//ダッシュ停止不能Ｆより長い値を入れても意味がない
	local type = "ダッシュ攻撃不能Ｆ";
	chrparam.Param[type] <- array(CHRMAX, 4); // 1.2X:8
	chrparam.Param[type][Def_ChrNo_Chr011] = 6; // ダッシュ自体が高性能なので弱く 1.2X:10
	chrparam.Param[type][Def_ChrNo_Chr014] = 6; // ダッシュ自体が高性能なので弱く 1.2X:10
}

{	//ダッシュジャンプの慣性+加算ベクトル
	//ダッシュから抜ける時、ジャンプ移行なら40%のベクトルになり、さらにそこから入る値
	//ベクトル * この値 / 100
	//加算は単純に加算される割合
	local type = "ダッシュジャンプ慣性";
	chrparam.Param[type] <- array(CHRMAX, [40,20]);
}

{	//ダッシュのタメを抜けてから、ガードできるようになるまでの時間）
	//行動可能になってからどれだけガードできないか（同じでいいような気がするが、FrameID100ない組向け）
	//★これが短くて停止不能Ｆが長いと、ガードしつつダッシュができてかなり強い
	//短いとダッシュ近づくのが弱くなる。（不快な弱さ）
	//とみせかけてガード可能が反転するだけなので、↑が残ってるうちは何故かガードできる
	//↑がなくなった後は停止モーションにいけるのでガードできる
	//↑がなくなって停止モーションがない場合ガードできない
	// local type = "ダッシュガード不能Ｆ";
	// chrparam.Param[type] <- array(CHRMAX, 6);
}


if(Def_Sys_ChangeExtraBackStepMuteki){	//バックダッシュの無敵時間
	local type = "バクステ打撃無敵Ｆ";
	chrparam.Param[type] <- array(CHRMAX, 14);//〜1.15 10F ある程度キャラ差をつけたいが12Fぐらいは担保してもよさそう
	chrparam.Param[type][Def_ChrNo_Chr000] = 12;//32 437 202
	chrparam.Param[type][Def_ChrNo_Chr001] = 14;//34 424 197
	chrparam.Param[type][Def_ChrNo_Chr002] = 14;//31 355 187
	chrparam.Param[type][Def_ChrNo_Chr003] = 13;//28 332 179
	chrparam.Param[type][Def_ChrNo_Chr004] = 13;//35 368 153
	chrparam.Param[type][Def_ChrNo_Chr005] = 12;//27 338 197
	chrparam.Param[type][Def_ChrNo_Chr006] = 14;//31 428 225
	chrparam.Param[type][Def_ChrNo_Chr008] = 14;//33 351 202
	chrparam.Param[type][Def_ChrNo_Chr009] = 14;//36 462 239
	chrparam.Param[type][Def_ChrNo_Chr010] = 12;//32 416 199
	chrparam.Param[type][Def_ChrNo_Chr011] = 12;//33 490 190
	chrparam.Param[type][Def_ChrNo_Chr012] = 13;//31 352 209
	chrparam.Param[type][Def_ChrNo_Chr013] = 13;//29 475 164
	chrparam.Param[type][Def_ChrNo_Chr014] = 12;//37 518 202
	chrparam.Param[type][Def_ChrNo_Chr015] = 13;//28 319 184
	chrparam.Param[type][Def_ChrNo_Chr016] = 12;//37 503 203
	chrparam.Param[type][Def_ChrNo_Chr017] = 14;//31 376 177
	chrparam.Param[type][Def_ChrNo_Chr019] = 13;//27 280 117
	chrparam.Param[type][Def_ChrNo_Chr020] = 14;//32 327 142
	chrparam.Param[type][Def_ChrNo_Chr021] = 13;//35 473 182
	chrparam.Param[type][Def_ChrNo_Chr022] = 14;//33 328 211
	chrparam.Param[type][Def_ChrNo_Chr023] = 10;//32
	//硬直は37Fあたりを限度にしておきたい
	//コメントは「全体F, 移動距離, 無敵距離」
}
else
{
	local type = "バクステ打撃無敵Ｆ";
	chrparam.Param[type] <- array(CHRMAX, 12);//〜1.15 10F ある程度キャラ差をつけたいが12Fぐらいは担保してもよさそう
	chrparam.Param[type][Def_ChrNo_Chr000] = 10;//32 437 148>148
	chrparam.Param[type][Def_ChrNo_Chr001] = 12;//34 424 119>158
	chrparam.Param[type][Def_ChrNo_Chr002] = 12;//31 355 109>148
	chrparam.Param[type][Def_ChrNo_Chr003] = 10;//28 332 133>133
	chrparam.Param[type][Def_ChrNo_Chr004] = 11;//35 368 105>122
	chrparam.Param[type][Def_ChrNo_Chr005] = 10;//27 338 148>148
	chrparam.Param[type][Def_ChrNo_Chr006] = 12;//31 428 108>168
	chrparam.Param[type][Def_ChrNo_Chr008] = 12;//33 351 125>164
	chrparam.Param[type][Def_ChrNo_Chr009] = 12;//36 462 140>191
	chrparam.Param[type][Def_ChrNo_Chr010] = 10;//32 416 148>148
	chrparam.Param[type][Def_ChrNo_Chr011] = 10;//33 490 150>150
	chrparam.Param[type][Def_ChrNo_Chr012] = 11;//31 352 136>161
	chrparam.Param[type][Def_ChrNo_Chr013] = 10;//29 475 117>117
	chrparam.Param[type][Def_ChrNo_Chr014] = 10;//37 518 148>148
	chrparam.Param[type][Def_ChrNo_Chr015] = 11;//28 319 121>142
	chrparam.Param[type][Def_ChrNo_Chr016] = 10;//37 503 153
	chrparam.Param[type][Def_ChrNo_Chr017] = 11;//31 360 161
	chrparam.Param[type][Def_ChrNo_Chr019] = 11;
	chrparam.Param[type][Def_ChrNo_Chr020] = 10;//32
	chrparam.Param[type][Def_ChrNo_Chr021] = 10;
	chrparam.Param[type][Def_ChrNo_Chr022] = 11;
	chrparam.Param[type][Def_ChrNo_Chr023] = 12;//32
	//硬直は37Fあたりを限度にしておきたい
}

{	// バクステの投げ無敵フレーム
	local type = "バクステ投げ無敵Ｆ";
	chrparam.Param[type] <- array(CHRMAX, 10);
}

//歩きやダッシュの足音ＳＥ定義
{
	//Param0が10のタイミングでＡ→Ｂ→Ａ→Ｂと再生される
	//定義が-1だと再生されない
	// st[170] =	{  file=path+"SE170_Walk_ShoesA", type=-1  }; // 歩き
	// st[171] =	{  file=path+"SE171_Walk_ShoesB", type=-1  }; // 歩き
	// st[172] =	{  file=path+"SE172_Walk_BootsA", type=-1  }; // 歩き
	// st[173] =	{  file=path+"SE173_Walk_BootsB", type=-1  }; // 歩き
	// st[174] =	{  file=path+"SE174_Walk_HeelsA", type=-1  }; // 歩き
	// st[175] =	{  file=path+"SE175_Walk_HeelsB", type=-1  }; // 歩き
	// これ未使用
	local _FSST_Shoes = 170;//足音（靴）
	// local _FSST_Boots = 170;
	// local _FSST_Heels = 170;
	local _FSST_Foot = 171;//足音（裸足）
	
	local typeA = "足音Ａ_ＳＥ番号";

	chrparam.Param[typeA] <- array(CHRMAX, _FSST_Shoes);
	chrparam.Param[typeA][Def_ChrNo_Chr006] = _FSST_Foot;
	chrparam.Param[typeA][Def_ChrNo_Chr021] = [_SeType_Player, 50];

	local typeB = "足音Ｂ_ＳＥ番号";
	
	chrparam.Param[typeB] <- array(CHRMAX, _FSST_Shoes);
	chrparam.Param[typeB][Def_ChrNo_Chr006] = _FSST_Foot;
	chrparam.Param[typeB][Def_ChrNo_Chr021] = [_SeType_Player, 50];
}

{
	local type = "空中受け身バリアタイプ";
	chrparam.Param[type] <- array(CHRMAX, Def_Sys_RecoverBarrierType);
}

{
	local type = "地上受け身着地エフェクトタイプ";
	chrparam.Param[type] <- array(CHRMAX, 0);
}

{
	local type = "立ち挑発タイプ";
	chrparam.Param[type] <- array(CHRMAX, 2); // 0:モーション無し・挑発無し 1:モーションあり(512)・挑発あり　2:モーション無し・挑発あり
	chrparam.Param[type][Def_ChrNo_Chr000] = 1;
	chrparam.Param[type][Def_ChrNo_Chr001] = 1;
	chrparam.Param[type][Def_ChrNo_Chr002] = 1;
	chrparam.Param[type][Def_ChrNo_Chr003] = 1;
	chrparam.Param[type][Def_ChrNo_Chr004] = 1;
	chrparam.Param[type][Def_ChrNo_Chr005] = 1;
	chrparam.Param[type][Def_ChrNo_Chr006] = 1; // ムキムキ動作
	chrparam.Param[type][Def_ChrNo_Chr008] = 1;
	chrparam.Param[type][Def_ChrNo_Chr009] = 1;
	chrparam.Param[type][Def_ChrNo_Chr010] = 1;
	chrparam.Param[type][Def_ChrNo_Chr011] = 1;
	chrparam.Param[type][Def_ChrNo_Chr012] = 1;
	chrparam.Param[type][Def_ChrNo_Chr013] = 1;
	chrparam.Param[type][Def_ChrNo_Chr014] = 1;
	chrparam.Param[type][Def_ChrNo_Chr015] = 1;
	chrparam.Param[type][Def_ChrNo_Chr016] = 1;
	chrparam.Param[type][Def_ChrNo_Chr017] = 1;
	chrparam.Param[type][Def_ChrNo_Chr019] = 1;
	chrparam.Param[type][Def_ChrNo_Chr020] = 1;
	chrparam.Param[type][Def_ChrNo_Chr021] = 1;
	chrparam.Param[type][Def_ChrNo_Chr022] = 1;
	chrparam.Param[type][Def_ChrNo_Chr023] = 1;
}

{
	local type = "しゃがみ挑発タイプ";
	chrparam.Param[type] <- array(CHRMAX, 0); // 0:モーション無し・挑発無し 1:モーションあり(512)・挑発あり　2:モーション無し・挑発あり
	chrparam.Param[type][Def_ChrNo_Chr004] = 1;
}

{
	//最小の値から行動可能になる（必殺技とかも出せる）
	//特殊技はABCによって分けられるので注意（J2CはJCのフレームになる）
	//同じフレームにしないとJ2Cを入れたのにJCが出たりして不快
	local type = "地上アサルト硬直"; // デフォ値6。飛ぶまでが4Fなので、4+値+ジャンプ攻撃のフレームが最速
	chrparam.Param[type] <- array(CHRMAX, [-1,-1,-1]); // JA, JB, JC
}

{
	//最小の値から行動可能になる（必殺技とかも出せる）
	//特殊技はABCによって分けられるので注意（J2CはJCのフレームになる）
	//同じフレームにしないとJ2Cを入れたのにJCが出たりして不快
	local type = "空中アサルト硬直"; // デフォ値9。飛ぶまでが5Fなので、5+値+ジャンプ攻撃のフレームが最速
	chrparam.Param[type] <- array(CHRMAX, [-1,-1,-1]); // JA, JB, JC
}

//パターン定義
{	// 空中ガードからの戻りパターン
	local type = "空中ガードからの戻りパターン";
	chrparam.Param[type] <- array(CHRMAX, 20);
}

{	// 空中ガードからの戻りパターン
	local type = "空中シールドからの戻りパターン";
	chrparam.Param[type] <- array(CHRMAX, 20);
	chrparam.Param[type][Def_ChrNo_Chr000] = 41;
}

{	// 起き上がりのフリーモーション
	local type = "起き上がりのフリーモーションパターン";
	chrparam.Param[type] <- array(CHRMAX, [0,0,0]);
	chrparam.Param[type][Def_ChrNo_Chr016] = [596,596,596];
	chrparam.Param[type][Def_ChrNo_Chr018] = [596,596,596];
}

{
	// 起き上がりのフリーモーションのFinalize先Mv名
	local type = "起き上がりのフリーモーションFinalize先";
	chrparam.Param[type] <- array(CHRMAX, "Mv_Crouch_Wait");
	chrparam.Param[type][Def_ChrNo_Chr018] = "PatMv_Neutral";//しゃがみがない
	chrparam.Param[type][Def_ChrNo_Chr019] = "Mv_Neutral";//直で起きる
}

{
	// シールドのフリーモーションパターン
	// BaseDataで動いているのでアニメ枚数が違う時はこれを使う
	local type = "シールドのフリーモーションパターン";
	chrparam.Param[type] <- array(CHRMAX, [0,0]);
	chrparam.Param[type][Def_ChrNo_Chr020] = [83,84];
}
local pat_ShieldFreeMotionAr = chrparam.Get( { type="シールドのフリーモーションパターン", chrnum=_ChrNo } );
local pat_StdShieldFreeMotion = pat_ShieldFreeMotionAr[0];
local pat_CroShieldFreeMotion = pat_ShieldFreeMotionAr[1];

_dp1p("\n[btl_ChrParamFunc] -> end");

//local test = chrparam.Get( { type="地上アサルト硬直", chrnum=_ChrNo } );
//print("test:"+test);

{	// 歩きベクトル定義
	local type = "歩きベクトル";
	chrparam.Param[type] <- array(CHRMAX,    [512, 1250, -512,  -900] );// 前進はじめ, 前進, 後退はじめ, 後退 // [400, 1000, -400, -700]

	chrparam.Param[type][Def_ChrNo_Chr000] = [512, 1250, -512,  -800]; // [400, 1000, -400, -600];
	chrparam.Param[type][Def_ChrNo_Chr001] = [512, 1450, -512, -1000]; // [400, 1200, -400, -800];
	chrparam.Param[type][Def_ChrNo_Chr002] = [512, 1080, -512,  -800]; // [400,  800, -400, -600];
	chrparam.Param[type][Def_ChrNo_Chr003] = [512,  980, -512,  -800]; // [400,  700, -400, -600];
	chrparam.Param[type][Def_ChrNo_Chr004] = [512, 1180, -512, -1100]; // [400,  900, -400, -900];
	chrparam.Param[type][Def_ChrNo_Chr005] = [512, 1180, -512,  -900]; // [400,  900, -400, -700];
	chrparam.Param[type][Def_ChrNo_Chr006] = [512, 1180, -512,  -900]; // [400,  900, -400, -700];
	chrparam.Param[type][Def_ChrNo_Chr008] = [512, 1080, -512,  -900]; // [400,  800, -400, -700];
	chrparam.Param[type][Def_ChrNo_Chr009] = [512,  980, -512,  -700]; // [400,  700, -400, -500];
	chrparam.Param[type][Def_ChrNo_Chr010] = [512, 1250, -512,  -800]; // [400, 1000, -400, -600];
	chrparam.Param[type][Def_ChrNo_Chr011] = [512, 1250, -512,  -800]; // [400, 1000, -400, -600];
	chrparam.Param[type][Def_ChrNo_Chr012] = [512, 1080, -512,  -800]; // [400,  800, -400, -600];
	chrparam.Param[type][Def_ChrNo_Chr013] = [512, 1650, -512, -1100]; // [400, 1400, -400, -900];
	chrparam.Param[type][Def_ChrNo_Chr014] = [512, 1180, -512,  -900]; // [400,  900, -400, -700];
	chrparam.Param[type][Def_ChrNo_Chr015] = [512, 1180, -512,  -800]; // [400,  900, -400, -600];
	chrparam.Param[type][Def_ChrNo_Chr016] = [512, 1230, -512,  -750]; // [400,  950, -400, -550];
	chrparam.Param[type][Def_ChrNo_Chr017] = [512, 1250, -512,  -900]; // [400, 1000, -400, -700];
	chrparam.Param[type][Def_ChrNo_Chr019] = [512, 1180, -512, -1000]; // [400,  900, -400, -900];
	chrparam.Param[type][Def_ChrNo_Chr020] = [512, 1080, -512,  -800]; // [400,  800, -400, -600];
	chrparam.Param[type][Def_ChrNo_Chr021] = [512, 1180, -512,  -900];
	chrparam.Param[type][Def_ChrNo_Chr022] = [512, 1180, -512,  -900];
	
	if( _TagCharaNo == Def_ChrNo_Chr007 ) // ヒスコハ
	{
	chrparam.Param[type][Def_ChrNo_Chr001] = [400, 1150, -400, -650];
	chrparam.Param[type][Def_ChrNo_Chr004] = [400,  850, -400, -850];
	}
}

{	// 前ダッシュベクトル定義
	// [frame] = {}でベクトルを定義　初速とループ開始時のフレームを指定する
	// effect = "前ダッシュエフェクト"を呼び出す
	local type = "前ダッシュベクトル";
	chrparam.Param[type] <- array(CHRMAX,    { [0]={ x=128, addx=32 }, [3]={ x= 700, addx=200                     }, [4]={ x=1800, addx=240, max=5300, effect=1 } } );
	chrparam.Param[type][Def_ChrNo_Chr000] = { [0]={ x=128, addx=32 }, [3]={ x= 700, addx=200                     }, [4]={ x=1700, addx=320, max=6600, effect=1 } };//超     z:速
	chrparam.Param[type][Def_ChrNo_Chr001] = { [0]={ x=128, addx=32 }, [3]={ x=1900, addx=220, max=5200, effect=1 } };//人     z:並
	chrparam.Param[type][Def_ChrNo_Chr002] = { [0]={ x=128, addx=32 }, [3]={ x= 600, addx=200                     }, [4]={ x=1500, addx=250, max=5300, effect=1 } };//人+    z:遅
	chrparam.Param[type][Def_ChrNo_Chr003] = { [0]={ x=128, addx=32 }, [3]={ x=1600, addx=200, max=5500, effect=1 } };//人+    z:並
	chrparam.Param[type][Def_ChrNo_Chr004] = { [0]={ x=128, addx=32 }, [3]={ x= 700, addx=230                     }, [5]={ x=1600, addx=270, max=5700, effect=1 } };//人     z:速
	chrparam.Param[type][Def_ChrNo_Chr005] = { [0]={ x=128, addx=32 }, [3]={ x= 700, addx=200                     }, [4]={ x=1700, addx=230, max=5800, effect=1 } };//       z:速
	chrparam.Param[type][Def_ChrNo_Chr006] = { [0]={ x=128, addx=32 }, [3]={ x= 600, addx=240                     }, [5]={ x=1500, addx=280, max=5500, effect=1 } };//人+    z:並
	chrparam.Param[type][Def_ChrNo_Chr008] = { [0]={ x=128, addx=32 }, [3]={ x= 800, addx=200                     }, [4]={ x=1600, addx=230, max=5500, effect=1 } };//       z:並
	chrparam.Param[type][Def_ChrNo_Chr009] = { [0]={ x=128, addx=32 }, [3]={ x= 700, addx=230                     }, [5]={ x=1600, addx=260, max=5700, effect=1 } };//超(重) z:遅
	chrparam.Param[type][Def_ChrNo_Chr010] = { [0]={ x=128, addx=32 }, [3]={ x= 700, addx=200                     }, [4]={ x=1700, addx=310, max=6600, effect=1 } };//超     z:速
	chrparam.Param[type][Def_ChrNo_Chr011] = { [0]={ x=128, addx=32 }, [3]={ x=1700, addx=270, max=6300, effect=1 } };//超     z:速
	chrparam.Param[type][Def_ChrNo_Chr012] = { [0]={ x=128, addx=32 }, [3]={ x=1500, addx=270                     }, [5]={ x=2100, addx=290, max=6300, effect=1 } };//超     z:並
	chrparam.Param[type][Def_ChrNo_Chr013] = { [0]={ x=128, addx=32 }, [3]={ x=2000, addx=220, max=5400, effect=1 } };//人+    z:並
	chrparam.Param[type][Def_ChrNo_Chr014] = { [0]={ x=128, addx=32 }, [3]={ x=1300, addx=270, max=6300, effect=1 } };//超     z:速
	chrparam.Param[type][Def_ChrNo_Chr015] = { [0]={ x=128, addx=32 }, [3]={ x=1600, addx=220, max=5500, effect=1 } };//人+    z:並
	chrparam.Param[type][Def_ChrNo_Chr016] = { [0]={ x=128, addx=32 }, [3]={ x= 900, addx=220                     }, [4]={ x=1700, addx=290, max=6200, effect=1 } };//超     z:速
	chrparam.Param[type][Def_ChrNo_Chr017] = { [0]={ x=128, addx=32 }, [3]={ x= 600, addx=230                     }, [4]={ x=1600, addx=240, max=5500, effect=1 } };
	chrparam.Param[type][Def_ChrNo_Chr019] = { [0]={ x=128, addx=32 }, [3]={ x= 600, addx=200                     }, [4]={ x=1500, addx=240, max=4900, effect=1 } };//人+    z:遅
	chrparam.Param[type][Def_ChrNo_Chr020] = { [0]={ x=128, addx=32 }, [3]={ x=1500, addx=270                     }, [5]={ x=2100, addx=290, max=5700, effect=1 } };//超     z:並
	chrparam.Param[type][Def_ChrNo_Chr021] = { [0]={ x=128, addx=32 }, [3]={ x=1600, addx=260                     }, [4]={ x=2000, addx=290, max=5800, effect=1 } };//超     z:並
	chrparam.Param[type][Def_ChrNo_Chr022] = { [0]={ x=128, addx=32 }, [3]={ x= 700, addx=200                     }, [4]={ x=1800, addx=240, max=5700, effect=1 } };
	
	if( _TagCharaNo == Def_ChrNo_Chr007 ) // ヒスコハ
	{
	chrparam.Param[type][Def_ChrNo_Chr001] = { [0]={ x=128, addx=32 }, [4]={ x=1800, addx=220, max=4000, effect=1 } };//人     z:並
	chrparam.Param[type][Def_ChrNo_Chr004] = { [0]={ x=128, addx=32 }, [4]={ x= 600, addx=230                     }, [6]={ x=1500, addx=270, max=4400, effect=1 } };//人     z:速
	}
	/*
	chrparam.Param[type] <- array(CHRMAX,    { [0]={ x=128, addx=32 }, [4]={ x= 700, addx=200                     }, [5]={ x=1800, addx=240, max=4000, effect=1 } } );
	chrparam.Param[type][Def_ChrNo_Chr000] = { [0]={ x=128, addx=32 }, [4]={ x= 700, addx=200                     }, [5]={ x=1700, addx=320, max=5300, effect=1 } };//超     z:速
	chrparam.Param[type][Def_ChrNo_Chr001] = { [0]={ x=128, addx=32 }, [4]={ x=1900, addx=220, max=3900, effect=1 } };//人     z:並
	chrparam.Param[type][Def_ChrNo_Chr002] = { [0]={ x=128, addx=32 }, [4]={ x= 600, addx=200                     }, [5]={ x=1500, addx=250, max=4000, effect=1 } };//人+    z:遅
	chrparam.Param[type][Def_ChrNo_Chr003] = { [0]={ x=128, addx=32 }, [4]={ x=1600, addx=200, max=4200, effect=1 } };//人+    z:並
	chrparam.Param[type][Def_ChrNo_Chr004] = { [0]={ x=128, addx=32 }, [4]={ x= 700, addx=230                     }, [6]={ x=1600, addx=270, max=4400, effect=1 } };//人     z:速
	chrparam.Param[type][Def_ChrNo_Chr005] = { [0]={ x=128, addx=32 }, [4]={ x= 700, addx=200                     }, [5]={ x=1700, addx=230, max=4500, effect=1 } };//       z:速
	chrparam.Param[type][Def_ChrNo_Chr006] = { [0]={ x=128, addx=32 }, [4]={ x= 600, addx=240                     }, [6]={ x=1500, addx=280, max=4200, effect=1 } };//人+    z:並
	chrparam.Param[type][Def_ChrNo_Chr008] = { [0]={ x=128, addx=32 }, [4]={ x= 800, addx=200                     }, [5]={ x=1600, addx=230, max=4200, effect=1 } };//       z:並
	chrparam.Param[type][Def_ChrNo_Chr009] = { [0]={ x=128, addx=32 }, [4]={ x= 700, addx=230                     }, [6]={ x=1600, addx=260, max=4400, effect=1 } };//超(重) z:遅
	chrparam.Param[type][Def_ChrNo_Chr010] = { [0]={ x=128, addx=32 }, [4]={ x= 700, addx=200                     }, [5]={ x=1700, addx=310, max=5300, effect=1 } };//超     z:速
	chrparam.Param[type][Def_ChrNo_Chr011] = { [0]={ x=128, addx=32 }, [4]={ x=1700, addx=270, max=5000, effect=1 } };//超     z:速
	chrparam.Param[type][Def_ChrNo_Chr012] = { [0]={ x=128, addx=32 }, [4]={ x= 700, addx=260                     }, [6]={ x=2000, addx=290, max=5000, effect=1 } };//超     z:並
	chrparam.Param[type][Def_ChrNo_Chr013] = { [0]={ x=128, addx=32 }, [4]={ x=2000, addx=220, max=4100, effect=1 } };//人+    z:並
	chrparam.Param[type][Def_ChrNo_Chr014] = { [0]={ x=128, addx=32 }, [4]={ x=1300, addx=270, max=5000, effect=1 } };//超     z:速
	chrparam.Param[type][Def_ChrNo_Chr015] = { [0]={ x=128, addx=32 }, [4]={ x=1600, addx=220, max=4200, effect=1 } };//人+    z:並
	chrparam.Param[type][Def_ChrNo_Chr016] = { [0]={ x=128, addx=32 }, [4]={ x= 900, addx=220                     }, [5]={ x=1700, addx=290, max=4900, effect=1 } };//超     z:速
	chrparam.Param[type][Def_ChrNo_Chr017] = { [0]={ x=128, addx=32 }, [4]={ x= 600, addx=230                     }, [5]={ x=1600, addx=240, max=4200, effect=1 } };
	chrparam.Param[type][Def_ChrNo_Chr019] = { [0]={ x=128, addx=32 }, [4]={ x= 700, addx=230                     }, [6]={ x=1600, addx=270, max=4400, effect=1 } };//人     z:速
	chrparam.Param[type][Def_ChrNo_Chr020] = { [0]={ x=128, addx=32 }, [4]={ x=1600, addx=220, max=4200, effect=1 } };//人+    z:並
	
	if( _TagCharaNo == Def_ChrNo_Chr007 )
	{
	chrparam.Param[type][Def_ChrNo_Chr001] = { [0]={ x=128, addx=32 }, [4]={ x=1800, addx=220, max=3800, effect=1 } };//人     z:並
	chrparam.Param[type][Def_ChrNo_Chr004] = { [0]={ x=128, addx=32 }, [4]={ x= 600, addx=230                     }, [6]={ x=1500, addx=270, max=4200, effect=1 } };//人     z:速
	}	
	*/
	
	//デバッグ
	if( Def_Dbg_DebugMessage && 0 )
	{
		// for( local i=0; i<CHRMAX; i++ )
		for( local i=0; i<=20; i++ )
		{
			local tmp = chrparam.Param[type][i];
			if( tmp )
			{
				_dpn("キャラ:"+i+",");
				local x = 0;
				local vec = { x=0, addx=0, max=-1 };
				for( local fra=0; fra<=20; fra++ )
				{
					if( fra in tmp )
					{
						if( "x" in tmp[fra] ) vec.x = tmp[fra].x;
						if( "addx" in tmp[fra] ) vec.addx = tmp[fra].addx;
						if( "max" in tmp[fra] ) vec.max = tmp[fra].max;
					}
					vec.x = vec.x + vec.addx;
					if( vec.max != -1 && vec.x > vec.max ) vec.x = vec.max;
					x += vec.x;
					_dp(x+",");
				}
			}
		}
	}
}


{	// 前ダッシュ時によびだすＭｖ定義
	local type = "前ダッシュエフェクト"; // スライドダッシュのみ"Mv_Null_SlideDashEff"にする
	chrparam.Param[type] <- array(CHRMAX, { mv="Mv_Null_RundDashEff", param=[ 60,0,0,0,0]  } );
	chrparam.Param[type][Def_ChrNo_Chr000] = { mv="Mv_Null_RundDashEff",  param=[100,0,0,0,0]  };
	chrparam.Param[type][Def_ChrNo_Chr001] = { mv="Mv_Null_RundDashEff",  param=[ 60,0,0,0,0]  };
	chrparam.Param[type][Def_ChrNo_Chr002] = { mv="Mv_Null_RundDashEff",  param=[ 70,0,0,0,0]  };
	chrparam.Param[type][Def_ChrNo_Chr003] = { mv="Mv_Null_RundDashEff",  param=[ 70,0,0,0,0]  };
	chrparam.Param[type][Def_ChrNo_Chr004] = { mv="Mv_Null_SlideDashEff", param=[ 60,0,0,0,0]  };
	chrparam.Param[type][Def_ChrNo_Chr005] = { mv="Mv_Null_SlideDashEff", param=[ 80,0,0,0,0]  };
	chrparam.Param[type][Def_ChrNo_Chr006] = { mv="Mv_Null_RundDashEff",  param=[ 70,0,0,0,0]  };
	chrparam.Param[type][Def_ChrNo_Chr008] = { mv="Mv_Null_RundDashEff",  param=[ 80,0,0,0,0]  };
	chrparam.Param[type][Def_ChrNo_Chr009] = { mv="Mv_Null_SlideDashEff", param=[ 90,0,0,0,0]  };
	chrparam.Param[type][Def_ChrNo_Chr010] = { mv="Mv_Null_RundDashEff",  param=[100,0,0,0,0]  };
	chrparam.Param[type][Def_ChrNo_Chr011] = { mv="Mv_Null_SlideDashEff", param=[100,0,0,0,0]  };
	chrparam.Param[type][Def_ChrNo_Chr012] = { mv="Mv_Null_RundDashEff",  param=[100,0,0,0,0]  };
	chrparam.Param[type][Def_ChrNo_Chr013] = { mv="Mv_Null_RundDashEff",  param=[ 80,0,0,0,0]  };
	chrparam.Param[type][Def_ChrNo_Chr014] = { mv="Mv_Null_SlideDashEff", param=[100,0,0,0,0]  };
	chrparam.Param[type][Def_ChrNo_Chr015] = { mv="Mv_Null_RundDashEff",  param=[ 90,0,0,0,0]  };
	chrparam.Param[type][Def_ChrNo_Chr016] = { mv="Mv_Null_RundDashEff",  param=[100,0,0,0,0]  };
	chrparam.Param[type][Def_ChrNo_Chr017] = { mv="Mv_Null_RundDashEff",  param=[ 90,0,0,0,0]  };
	chrparam.Param[type][Def_ChrNo_Chr019] = { mv="Mv_Null_SlideDashEff", param=[ 60,0,0,0,0]  };
	chrparam.Param[type][Def_ChrNo_Chr020] = { mv="Mv_Null_RundDashEff",  param=[ 90,0,0,0,0]  };
	chrparam.Param[type][Def_ChrNo_Chr021] = { mv="Mv_Null_RundDashEff",  param=[100,0,0,0,0]  };
	chrparam.Param[type][Def_ChrNo_Chr022] = { mv="Mv_Null_SlideDashEff", param=[ 90,0,0,0,0]  };
	// chrparam.Param[type] <- array(CHRMAX, "Mv_Null_SlideDashEff");
}

{	// バックダッシュ時によびだすＭｖ定義
	local type = "バックダッシュエフェクト";
	chrparam.Param[type] <- array(CHRMAX, "Mv_Null_BackStepEff");
}

{	// バックダッシュ停止時によびだすＭｖ定義
	local type = "バックダッシュ停止エフェクト";
	chrparam.Param[type] <- array(CHRMAX, "Mv_Null_JumpLandEff");
}

{	// ジャンプベクトル値定義
	local type = "ジャンプベクトル";
	chrparam.Param[type] <- array(CHRMAX, [-4300, 250, 1300, 0, -1200] );// y, addy, 前X, 垂直X, 後X

	// y : 4600 を超えるとジャンプ連打でカメラが上にあがりがちになる
	chrparam.Param[type][Def_ChrNo_Chr000] = [-4300, 250, 1400, 0, -1300];
	chrparam.Param[type][Def_ChrNo_Chr001] = [-4600, 250, 1500, 0, -1400];
	chrparam.Param[type][Def_ChrNo_Chr002] = [-4650, 250, 1200, 0, -1100];
	chrparam.Param[type][Def_ChrNo_Chr003] = [-4600, 250, 1300, 0, -1200];
	chrparam.Param[type][Def_ChrNo_Chr004] = [-4650, 250, 1400, 0, -1300];
	chrparam.Param[type][Def_ChrNo_Chr005] = [-4500, 250, 1300, 0, -1200];
	chrparam.Param[type][Def_ChrNo_Chr006] = [-4600, 250, 1200, 0, -1100];
	chrparam.Param[type][Def_ChrNo_Chr008] = [-4200, 250, 1200, 0, -1100];
	chrparam.Param[type][Def_ChrNo_Chr009] = [-4800, 250, 1200, 0, -1100];
	chrparam.Param[type][Def_ChrNo_Chr010] = [-4980, 250, 1400, 0, -1300];
	chrparam.Param[type][Def_ChrNo_Chr011] = [-4480, 250, 1200, 0, -1100];
	chrparam.Param[type][Def_ChrNo_Chr012] = [-4650, 250, 1200, 0, -1100];
	chrparam.Param[type][Def_ChrNo_Chr013] = [-4480, 250, 1300, 0, -1200];
	chrparam.Param[type][Def_ChrNo_Chr014] = [-4700, 250, 1200, 0, -1100];
	chrparam.Param[type][Def_ChrNo_Chr015] = [-4600, 250, 1300, 0, -1200];
	chrparam.Param[type][Def_ChrNo_Chr016] = [-4600, 250, 1300, 0, -1200];
	chrparam.Param[type][Def_ChrNo_Chr017] = [-4650, 250, 1200, 0, -1200];
	chrparam.Param[type][Def_ChrNo_Chr019] = [-4300, 250, 1400, 0, -1300];
	chrparam.Param[type][Def_ChrNo_Chr020] = [-4600, 250, 1200, 0, -1100];
	chrparam.Param[type][Def_ChrNo_Chr021] = [-4300, 250, 1300, 0, -1200];
	chrparam.Param[type][Def_ChrNo_Chr022] = [-4300, 250, 1300, 0, -1200];
	

}

{	// ２段ジャンプベクトル値定義
	local type = "２段ジャンプベクトル";
	chrparam.Param[type] <- array(CHRMAX, [-3700, 250,  970, 0,  -730] );// y, addy, 前X, 垂直X, 後X
	chrparam.Param[type][Def_ChrNo_Chr000] = [-3900, 250, 1060, 0, -1000];
	chrparam.Param[type][Def_ChrNo_Chr001] = [-3800, 250, 1160, 0,  -800];
	chrparam.Param[type][Def_ChrNo_Chr002] = [-3700, 250,  850, 0,  -640];
	chrparam.Param[type][Def_ChrNo_Chr003] = [-3700, 250, 1080, 0,  -730];
	chrparam.Param[type][Def_ChrNo_Chr004] = [-4000, 250, 1060, 0,  -800];
	chrparam.Param[type][Def_ChrNo_Chr005] = [-3700, 250,  980, 0,  -750];
	chrparam.Param[type][Def_ChrNo_Chr006] = [-3800, 250, 1080, 0,  -830];
	chrparam.Param[type][Def_ChrNo_Chr008] = [-3700, 250,  900, 0,  -730];
	chrparam.Param[type][Def_ChrNo_Chr009] = [-4000, 250,  850, 0,  -660];
	chrparam.Param[type][Def_ChrNo_Chr010] = [-3900, 250, 1060, 0,  -850];
	chrparam.Param[type][Def_ChrNo_Chr011] = [-3700, 250,  850, 0,  -640];
	chrparam.Param[type][Def_ChrNo_Chr012] = [-3800, 250, 1060, 0,  -800];
	chrparam.Param[type][Def_ChrNo_Chr013] = [-3700, 250, 1060, 0,  -640];
	chrparam.Param[type][Def_ChrNo_Chr014] = [-4000, 250,  850, 0,  -640];
	chrparam.Param[type][Def_ChrNo_Chr015] = [-3700, 250, 1080, 0,  -730];
	chrparam.Param[type][Def_ChrNo_Chr016] = [-3700, 250,  970, 0,  -730];
	chrparam.Param[type][Def_ChrNo_Chr017] = [-3700, 250,  970, 0,  -730];
	chrparam.Param[type][Def_ChrNo_Chr019] = [-3900, 250, 1060, 0, -1000];
	chrparam.Param[type][Def_ChrNo_Chr020] = [-3800, 250,  850, 0,  -660];
	chrparam.Param[type][Def_ChrNo_Chr021] = [-3700, 250,  970, 0,  -730];
	chrparam.Param[type][Def_ChrNo_Chr022] = [-3700, 250,  970, 0,  -730];
	chrparam.Param[type][Def_ChrNo_Chr023] = [-3800, 250,  850, 0,  -660];
}

{	// ３段ジャンプベクトル値定義
	local type = "３段ジャンプベクトル";
	chrparam.Param[type] <- array(CHRMAX, [-3000, 250, 800, 0, -600] );// y, addy, 前X, 垂直X, 後X
}

{	// ４段ジャンプベクトル値定義
	local type = "４段ジャンプベクトル";
	chrparam.Param[type] <- array(CHRMAX, [-3000, 250, 800, 0, -600] );// y, addy, 前X, 垂直X, 後X
}

{	// ハイジャンプベクトル値定義
	local type = "ハイジャンプベクトル";
	// chrparam.Param[type] <- array(CHRMAX, [-4800, 250, 3200, 0, -1300] );// y, addy, 前X, 垂直X, 後X
	chrparam.Param[type] <- array(CHRMAX, [-4400, 250, 3600, 0, -1300] );// y, addy, 前X, 垂直X, 後X
}

{	// ハイジャンプベクトル値定義
	local type = "２段ハイジャンプベクトル";
	// chrparam.Param[type] <- array(CHRMAX, [-4650, 200, 1700, 0, -600] );// y, addy, 前X, 垂直X, 後X
	chrparam.Param[type] <- array(CHRMAX, [-3900, 200, 2000, 0, -600] );// y, addy, 前X, 垂直X, 後X
}

{	// エリアルジャンプベクトル値定義
	local type = "エリアルジャンプベクトル";
	chrparam.Param[type] <- array(CHRMAX, [-4600, 200, 1000, 0, -1300] );// y, addy, 前X, 垂直X, 後X
}

{	// エリアルジャンプベクトル値定義
	local type = "失敗エリアルジャンプベクトル";
	chrparam.Param[type] <- array(CHRMAX, [-3800, 200, 1000, 0, -500] );// y, addy, 前X, 垂直X, 後X
}

{	// 空中ダッシュでかかり硬直定義
	local type = "空中後ダッシュでかかり硬直";
	// chrparam.Param[type] <- array(CHRMAX, 12 );
	chrparam.Param[type] <- array(CHRMAX, 16 );
	chrparam.Param[type][Def_ChrNo_Chr000] = 17;
	chrparam.Param[type][Def_ChrNo_Chr001] = 16;
	chrparam.Param[type][Def_ChrNo_Chr002] = 16;
	chrparam.Param[type][Def_ChrNo_Chr003] = 18;
	chrparam.Param[type][Def_ChrNo_Chr004] = 18;
	chrparam.Param[type][Def_ChrNo_Chr005] = 16;
	chrparam.Param[type][Def_ChrNo_Chr006] = 16;
	chrparam.Param[type][Def_ChrNo_Chr008] = 17;
	chrparam.Param[type][Def_ChrNo_Chr009] = 18;
	chrparam.Param[type][Def_ChrNo_Chr010] = 17;
	chrparam.Param[type][Def_ChrNo_Chr011] = 17;
	chrparam.Param[type][Def_ChrNo_Chr012] = 16;
	chrparam.Param[type][Def_ChrNo_Chr013] = 16;
	chrparam.Param[type][Def_ChrNo_Chr014] = 17;
	chrparam.Param[type][Def_ChrNo_Chr015] = 16;
	chrparam.Param[type][Def_ChrNo_Chr016] = 16;
	chrparam.Param[type][Def_ChrNo_Chr017] = 16;
	chrparam.Param[type][Def_ChrNo_Chr019] = 17;
	chrparam.Param[type][Def_ChrNo_Chr020] = 16;
	chrparam.Param[type][Def_ChrNo_Chr021] = 16;
	chrparam.Param[type][Def_ChrNo_Chr022] = 16;
}

{	// 空中ダッシュ抜け重力定義
	local type = "空中ダッシュ抜け重力";
	chrparam.Param[type] <- array(CHRMAX, 220 );// addy
}

{	// 空中ダッシュ抜け重力タイプ定義
	local type = "空中ダッシュ抜け重力タイプ";//水平タイプのダッシュのみ
	chrparam.Param[type] <- array(CHRMAX, 0 );//0:Mvが抜けたら重力がかかる 1〜 そのフレームが経過したら重力がかかる（通常技の間のみ）
	chrparam.Param[type][Def_ChrNo_Chr000] = 0;
	chrparam.Param[type][Def_ChrNo_Chr001] = 0;
	chrparam.Param[type][Def_ChrNo_Chr002] = 0;
	chrparam.Param[type][Def_ChrNo_Chr003] = 0;
	chrparam.Param[type][Def_ChrNo_Chr004] = 0;
	chrparam.Param[type][Def_ChrNo_Chr005] = 18;
	chrparam.Param[type][Def_ChrNo_Chr006] = 18;
	chrparam.Param[type][Def_ChrNo_Chr008] = 0;
	chrparam.Param[type][Def_ChrNo_Chr009] = [20,20,19];
	chrparam.Param[type][Def_ChrNo_Chr010] = 0;
	chrparam.Param[type][Def_ChrNo_Chr011] = 0;
	chrparam.Param[type][Def_ChrNo_Chr012] = [20,22,20];//JA/JB/JCで分ける　デフォは最小のものになる
	chrparam.Param[type][Def_ChrNo_Chr013] = 0;
	chrparam.Param[type][Def_ChrNo_Chr014] = 18;
	chrparam.Param[type][Def_ChrNo_Chr015] = 14;
	chrparam.Param[type][Def_ChrNo_Chr016] = 0;
	chrparam.Param[type][Def_ChrNo_Chr017] = 0;
	chrparam.Param[type][Def_ChrNo_Chr019] = 0;
	chrparam.Param[type][Def_ChrNo_Chr020] = 0;
	chrparam.Param[type][Def_ChrNo_Chr021] = 0;
	chrparam.Param[type][Def_ChrNo_Chr022] = 18;
}

local val_AirDash_F_GravityType = chrparam.Get( { type="空中ダッシュ抜け重力タイプ", chrnum=_ChrNo } );
local val_AirDash_F_GravityTypeTbl = { a = 0, b = 0, c = 0, min = 0, type=0 };//type:0 普通空中ダッシュ !=0:水平ダッシュ

if( typeof val_AirDash_F_GravityType == "array" && val_AirDash_F_GravityType.len() == 3 )
{
	val_AirDash_F_GravityTypeTbl.a = val_AirDash_F_GravityType[0];
	val_AirDash_F_GravityTypeTbl.b = val_AirDash_F_GravityType[1];
	val_AirDash_F_GravityTypeTbl.c = val_AirDash_F_GravityType[2];
	val_AirDash_F_GravityTypeTbl.min = val_AirDash_F_GravityType[0];
	val_AirDash_F_GravityTypeTbl.type = 1;//水平
	
	if( val_AirDash_F_GravityTypeTbl.min > val_AirDash_F_GravityTypeTbl.b ) val_AirDash_F_GravityTypeTbl.min = val_AirDash_F_GravityTypeTbl.b;
	if( val_AirDash_F_GravityTypeTbl.min > val_AirDash_F_GravityTypeTbl.c ) val_AirDash_F_GravityTypeTbl.min = val_AirDash_F_GravityTypeTbl.c;
}
else
{
	val_AirDash_F_GravityTypeTbl.a = val_AirDash_F_GravityType;
	val_AirDash_F_GravityTypeTbl.b = val_AirDash_F_GravityType;
	val_AirDash_F_GravityTypeTbl.c = val_AirDash_F_GravityType;
	val_AirDash_F_GravityTypeTbl.min = val_AirDash_F_GravityType;
	if( val_AirDash_F_GravityType != 0 )
	{
		val_AirDash_F_GravityTypeTbl.type = 1;//水平
	}
}
// _dpn("空ダ定義 min:"+val_AirDash_F_GravityTypeTbl.min+", A:"+val_AirDash_F_GravityTypeTbl.a+", B:"+val_AirDash_F_GravityTypeTbl.b+", C:"+val_AirDash_F_GravityTypeTbl.c+" Type:"+val_AirDash_F_GravityTypeTbl.type );

{	// 空中ダッシュでの２段ジャンプ消費
	// 0にすると２段ジャンプしたことにならないので、空ダ→二段ジャンプが可能になる
	local type = "空中ダッシュでの２段ジャンプ消費";
	chrparam.Param[type] <- array(CHRMAX, 0 );// y, addy, 前X, 垂直X, 後X
}

{
	//最小の値から行動可能になる（必殺技とかも出せる）
	//特殊技はABCによって分けられるので注意（J2CはJCのフレームになる）
	//同じフレームにしないとJ2Cを入れたのにJCが出たりして不快
	//20Fぐらい目安
	local type = "空中ダッシュ硬直";
	chrparam.Param[type] <- array(CHRMAX, [16,14,12]); // JA, JB, JC
	chrparam.Param[type][Def_ChrNo_Chr000] = [16,15,15];//4 5 6
	chrparam.Param[type][Def_ChrNo_Chr001] = [15,15,12];//4 5 9
	chrparam.Param[type][Def_ChrNo_Chr002] = [13,13,12];//4 7 9
	chrparam.Param[type][Def_ChrNo_Chr003] = [13,15,12];//4 5 9
	chrparam.Param[type][Def_ChrNo_Chr004] = [13,13,15];//4 8 9
	chrparam.Param[type][Def_ChrNo_Chr005] = [13,14,14];//4 6 7
	chrparam.Param[type][Def_ChrNo_Chr006] = [13,14,11];//4 5 10
	chrparam.Param[type][Def_ChrNo_Chr008] = [13,14,12];//4 7 9
	chrparam.Param[type][Def_ChrNo_Chr009] = [13,13,10];//5 9 11
	chrparam.Param[type][Def_ChrNo_Chr010] = [16,15,11];//4 4 9
	chrparam.Param[type][Def_ChrNo_Chr011] = [13,15,14];//4 6 7
	chrparam.Param[type][Def_ChrNo_Chr012] = [13,14,11];//5 6 10
	chrparam.Param[type][Def_ChrNo_Chr013] = [15,14,14];//4 5 7
	chrparam.Param[type][Def_ChrNo_Chr014] = [15,13,12];//5 9 10
	chrparam.Param[type][Def_ChrNo_Chr015] = [16,15,14];//4 6 9
	chrparam.Param[type][Def_ChrNo_Chr016] = [14,13,12];//4 7 13
	chrparam.Param[type][Def_ChrNo_Chr017] = [14,13,12];//6 7 8
	chrparam.Param[type][Def_ChrNo_Chr019] = [18,17,17];//4 7 13
	chrparam.Param[type][Def_ChrNo_Chr020] = [15,14,13];//5 7 9
	chrparam.Param[type][Def_ChrNo_Chr021] = [15,13,12];//4 7 9
	chrparam.Param[type][Def_ChrNo_Chr022] = [15,14,13];//5 7 9
	//XXX:AとBに12以下を設定すると、コンボ中に空中ダッシュを6AB押しっぱなしにするだけでジャンプ攻撃が漏れてしまう
	//XXX:Cでも6ABCとすると最速でJCが漏れたりして結構よくないが、キャラ性能変わりすぎるので今回はそのままにする
}

local val_AirDash_F_AirJumpCount = chrparam.Get( { type="空中ダッシュでの２段ジャンプ消費", chrnum=_ChrNo } );

{	// ラピッドビートの半ロック性能
	local type = "ラピッドビートの半ロック性能";
	chrparam.Param[type] <- array(CHRMAX,    {} );
	chrparam.Param[type][Def_ChrNo_Chr011] = { flags=(1<<0)|(1<<8) }; // X無効|最低保障Y
}

local tbl_RapidRelayAtkLockStatus = chrparam.Get( { type="ラピッドビートの半ロック性能", chrnum=_ChrNo } );

{	// 連打コンボの浮かせ技の性能…というかヒット時のズーム性能
	local type = "連打コンボ浮かせ性能";
	chrparam.Param[type] <- array(CHRMAX,    { aerial=1, frameid=100, offx=100, offy=-100, hosei={val=100, max=70} } );
	chrparam.Param[type][Def_ChrNo_Chr000] = { aerial=1, frameid=100, offx=100, offy=-100, hosei={val=100, max=70} };
	chrparam.Param[type][Def_ChrNo_Chr001] = { aerial=1, frameid=100, offx=100, offy=-100, hosei={val=100, max=70} };
	chrparam.Param[type][Def_ChrNo_Chr002] = { aerial=1, frameid=100, offx=100, offy=-100, hosei={val=100, max=70} };
	chrparam.Param[type][Def_ChrNo_Chr003] = { aerial=1, frameid=100, offx=200, offy=-100, hosei={val=100, max=70} };
	chrparam.Param[type][Def_ChrNo_Chr004] = { aerial=1, frameid=200, offx=150, offy=-100, hosei={val=100, max=70} };
	chrparam.Param[type][Def_ChrNo_Chr005] = { aerial=1, frameid=100, offx=200, offy=-100, hosei={val=100, max=70} };
	chrparam.Param[type][Def_ChrNo_Chr006] = { aerial=1, frameid=100, offx=200, offy= -50, hosei={val=100, max=70} };
	chrparam.Param[type][Def_ChrNo_Chr008] = { aerial=1, frameid=100, offx=100, offy=-100, hosei={val=100, max=70} };
	chrparam.Param[type][Def_ChrNo_Chr009] = { aerial=1, frameid=100, offx=100, offy=-100, hosei={val=100, max=70} };
	chrparam.Param[type][Def_ChrNo_Chr010] = { aerial=1, frameid=100, offx=100, offy=-100, hosei={val=100, max=70} };
	chrparam.Param[type][Def_ChrNo_Chr011] = { aerial=1, frameid=100, offx=100, offy=-100, hosei={val=100, max=70} };
	chrparam.Param[type][Def_ChrNo_Chr012] = { aerial=1, frameid=100, offx=100, offy=-100, hosei={val=100, max=70} };
	chrparam.Param[type][Def_ChrNo_Chr013] = { aerial=1, frameid=100, offx=100, offy=-100, hosei={val=100, max=70} };
	chrparam.Param[type][Def_ChrNo_Chr014] = { aerial=1, frameid=100, offx=100, offy=-100, hosei={val=100, max=70} };
	chrparam.Param[type][Def_ChrNo_Chr015] = { aerial=1, frameid=100, offx=100, offy=-100, hosei={val=100, max=70} };
	chrparam.Param[type][Def_ChrNo_Chr016] = { aerial=1, frameid=100, offx=100, offy=-100, hosei={val=100, max=70} };
	chrparam.Param[type][Def_ChrNo_Chr017] = { aerial=1, frameid=100, offx=100, offy=-100, hosei={val=100, max=70} };
	chrparam.Param[type][Def_ChrNo_Chr019] = { aerial=1, frameid=100, offx= 50, offy= -50, hosei={val=100, max=70} };
	chrparam.Param[type][Def_ChrNo_Chr020] = { aerial=1, frameid=100, offx=100, offy=-100, hosei={val=100, max=70} };
	chrparam.Param[type][Def_ChrNo_Chr021] = { aerial=1, frameid=100, offx=100, offy=-100, hosei={val=100, max=70} };
	chrparam.Param[type][Def_ChrNo_Chr022] = { aerial=1, frameid=100, offx=100, offy=-100, hosei={val=100, max=70} };
}

local tbl_RapidAtkFinishStatus = chrparam.Get( { type="連打コンボ浮かせ性能", chrnum=_ChrNo } );

{	// ネットワーク対戦でのHereYouAre表示の高さ
	local type = "オンラインYOU表示座標オフセット";//0=-435 1:-435+(-25)*n
	chrparam.Param[type] <- array(CHRMAX, 0 );
	chrparam.Param[type][Def_ChrNo_Chr000] = 0;
	chrparam.Param[type][Def_ChrNo_Chr001] = 0;
	chrparam.Param[type][Def_ChrNo_Chr002] = 0;
	chrparam.Param[type][Def_ChrNo_Chr003] = -1;
	chrparam.Param[type][Def_ChrNo_Chr004] = 0;
	chrparam.Param[type][Def_ChrNo_Chr005] = -1;
	chrparam.Param[type][Def_ChrNo_Chr006] = -2;
	chrparam.Param[type][Def_ChrNo_Chr008] = 0;
	chrparam.Param[type][Def_ChrNo_Chr009] = -3;
	chrparam.Param[type][Def_ChrNo_Chr010] = 0;
	chrparam.Param[type][Def_ChrNo_Chr011] = 0;
	chrparam.Param[type][Def_ChrNo_Chr012] = 0;
	chrparam.Param[type][Def_ChrNo_Chr013] = 1;
	chrparam.Param[type][Def_ChrNo_Chr014] = 0;//モーションによっては打点が高いので0にする
	chrparam.Param[type][Def_ChrNo_Chr015] = 0;
	chrparam.Param[type][Def_ChrNo_Chr016] = 0;
	chrparam.Param[type][Def_ChrNo_Chr017] = 1;
	chrparam.Param[type][Def_ChrNo_Chr019] = 1;
	chrparam.Param[type][Def_ChrNo_Chr020] = 0;
	chrparam.Param[type][Def_ChrNo_Chr021] = 0;
	chrparam.Param[type][Def_ChrNo_Chr022] = 0;
}
local tbl_OnlineHereYouAreYPosOffSet = chrparam.Get( { type="オンラインYOU表示座標オフセット", chrnum=_ChrNo } );


{	// 覚醒エフェクトY座標
	local type = "覚醒エフェクトY座標";
	chrparam.Param[type] <- array(CHRMAX, -250 );
	chrparam.Param[type][Def_ChrNo_Chr019] = -150;
}
local val_KakuseiStartEffectYpos = chrparam.Get( { type="覚醒エフェクトY座標", chrnum=_ChrNo } );

{	// 強制開放エフェクトY座標　※判定の高さが変わりキャラ性能も変化するので基本的にはいじらないこと
	local type = "強制開放エフェクトY座標";
	chrparam.Param[type] <- array(CHRMAX, -250 );
	chrparam.Param[type][Def_ChrNo_Chr019] = -150;
}
local val_BlastEffectYpos = chrparam.Get( { type="強制開放エフェクトY座標", chrnum=_ChrNo } );

{	// 空中ダッシュエフェクトY座標(前後ダッシュ)
	local type = "空中ダッシュエフェクトY座標";
	chrparam.Param[type] <- array(CHRMAX, -250 );
	chrparam.Param[type][Def_ChrNo_Chr019] = -150;
}
local val_AirDashEffectYpos = chrparam.Get( { type="空中ダッシュエフェクトY座標", chrnum=_ChrNo } );

{	// 強制開放とムーンドライブエフェクト倍率
	local type = "強制開放とムーンドライブエフェクト倍率";
	chrparam.Param[type] <- array(CHRMAX, 100 );
	chrparam.Param[type][Def_ChrNo_Chr019] = 70;
}
local val_PowerUpEffectScalePar = chrparam.Get( { type="強制開放とムーンドライブエフェクト倍率", chrnum=_ChrNo } );

{	// 投げ抜けられエフェクトY座標
	local type = "投げ抜けられエフェクトY座標";
	chrparam.Param[type] <- array(CHRMAX, [-250,-250] );
	chrparam.Param[type][Def_ChrNo_Chr019] = [-170,-170];
}
local val_TechHitEffectYposAr = chrparam.Get( { type="投げ抜けられエフェクトY座標", chrnum=_ChrNo } );

{
	// 立ちシールドカウンターのFinalize先Mv名
	local type = "立ちシールドカウンターのFinalize先";
	chrparam.Param[type] <- array(CHRMAX, "Mv_Neutral");
	chrparam.Param[type][Def_ChrNo_Chr017] = "Mv_Crouch_Wait";
}
local val_ShieldCounterGro_FinalizeMv = chrparam.Get( { type="立ちシールドカウンターのFinalize先", chrnum=_ChrNo } );

local CommonStandbyParams = array(CHRMAX,0);

//Enemy[] : 抽選に入れるキャラ。専用セリフ。未指定だと誰でもになるが、duetがあるときは相手もEnemyがないと抽選されない（enemy+commonよりduetが優先される）
//ExcludeEnemy[] : 抽選から除外するキャラ
//
// delay : 次に進む時間
// time : セリフの長さ・字幕表示時間
// camera_time : 話者に合うカメラのスクロール時間。未指定時はdelay、あればtimeを使う

// アルクェイド
// achievement_slot 61：遠野志貴
// 64：ロア
// 60：ヴローヴ
// 63：暴走アルクェイド
// 66：シエル
CommonStandbyParams[Def_ChrNo_Chr000] =
[
	{ ExcludeEnemy=[5,11,15], WaitPAT = 905, timeline =	[ { PAT=905, delay=60, SE=100, time=125 }, { PAT=906, delay=65, }, { PAT=907, delay=10, } ], }, // 戦いになるといいけど
	{ ExcludeEnemy=[1,2,3,4,6,7,12,13,15,20], WaitPAT=905, timeline = [ { SE=101, time=120, PAT=905, delay=120 }, ], }, // 目障りよ、貴方
	{ ExcludeEnemy=[11,15], WaitPAT=905, timeline = [ { SE=102, time=155, PAT=905, delay=60 }, { PAT=906, delay=100, }, { PAT=907, delay=10, } ], }, // いいわ、相手になってあげる
	{ ExcludeEnemy=[5,11], WaitPAT=905, timeline = [ { SE=103, time=133, PAT=905, delay=60 }, { PAT=906, delay=80,  }, { PAT=907, delay=10, } ], }, // へえ、面白そう（不敵に）
	{ ExcludeEnemy=[3,5,11], WaitPAT=905, timeline = [ { SE=108, time=152, PAT=905, delay=60 }, { PAT=906, delay=92,  }, { PAT=907, delay=10, } ], }, // 「寄り道するつもりはないんだけど。」
	{ ExcludeEnemy=[5,11], WaitPAT=905, timeline = [ { SE=109, time=216, PAT=905, delay=60 }, { PAT=906, delay=156, }, { PAT=907, delay=10, } ], }, // 「かかる火の粉ってヤツ？　うん、払う払う！」
	
	//シエル
	{ Enemy=[Def_ChrNo_Chr011], WaitPAT=905, timeline = [ { SE=650, time=200, PAT=905, delay=60, achievement_slot = 66 }, { PAT=906, delay=140, }, { PAT=907, delay=10, } ], }, // 「いい度胸ね。色々厚いんじゃない？」
	{ Enemy=[Def_ChrNo_Chr011], WaitPAT=905, timeline = [ { SE=651, time=184, PAT=905, delay=60, achievement_slot = 66 }, { PAT=906, delay=124, }, { PAT=907, delay=10, } ], }, // 「じゃ、遊びはなしで遊ぼっか？」
	{ Enemy=[Def_ChrNo_Chr011], WaitPAT=905, timeline = [ { SE=652, time=168, PAT=905, delay=60, achievement_slot = 66 }, { PAT=906, delay=108, }, { PAT=907, delay=10, } ], }, // 「本気、だしちゃおっかなぁ？」（シリアス、怖く、妖しく）
	{ Enemy=[Def_ChrNo_Chr011], WaitPAT=905, timeline = [ { SE=653, time=166, PAT=905, delay=166, achievement_slot = 66 } ], }, // 「そんな武装で、舐めてるの？」（イラッ）
	
	//ヴローヴ（duet先achievement_slot 60）
	{ Enemy=[Def_ChrNo_Chr009], WaitPAT = [902,901], duet_timeline =
		[
			{ PL=1, delay=210, SE=104, achievement_slot= 60 }, // その心臓を、おれによこせ
			{ PL=0, delay=180, SE=104, achievement_slot= 60 }, // 冗談。百年早いんじゃない？
		],
	},

	//遠野志貴（duet先achievement_slot 63）
	{ Enemy=[Def_ChrNo_Chr003], WaitPAT = [900,904],
		duet_timeline =
		[
			{ PL=0, delay=140, SE=106, achievement_slot = 61 }, // はい、いっちょ揉んでもらいましょう！
			{ PL=1, delay=200, SE=107, achievement_slot = 63 }, // とにかく遊びたいだけだろ、おまえ！
		],
		checkfunc = function()
		{
			if( Battle_Std.GetEnemyBossFlag()==8 ) return 0;//七夜風志貴なので掛け合いなし
			return 1;
		}
	},
	{ Enemy=[Def_ChrNo_Chr003], WaitPAT = [900,904],
		duet_timeline =
		[
			{ PL=0, delay=180, SE=105, achievement_slot = 61 }, // わたしを殺した責任、とってもらうんだから
			{ PL=1, delay=200, SE=107, achievement_slot = 63 }, // とにかく遊びたいだけだろ、おまえ！
		],
		checkfunc = function()
		{
			if( Battle_Std.GetEnemyBossFlag()==8 ) return 0;//七夜風志貴なので掛け合いなし
			return 1;
		}
	},

	//ロア（duet先achievement_slot 61）
	{
		Enemy=[Def_ChrNo_Chr005], WaitPAT = [901,900],
		duet_timeline =
		[
			{ PL=1, delay=230, SE=105, achievement_slot = 61 }, // 嬉しいねぇ、十七度目の婚姻だ……！
			{ PL=0, delay=160, SE=630, achievement_slot = 64}, // 戦いになると思う？
		],
	},
	{
		Enemy=[Def_ChrNo_Chr005], WaitPAT = [901,900],
		duet_timeline =
		[
			{ PL=1, delay=230, SE=105, achievement_slot = 61 }, // 嬉しいねぇ、十七度目の婚姻だ……！
			{ PL=0, delay=160, SE=631, achievement_slot = 64}, // また品のない器になったわね
		],
	},
	{
		Enemy=[Def_ChrNo_Chr005], WaitPAT = [901,900],
		duet_timeline =
		[
			{ PL=1, delay=230, SE=105, achievement_slot = 61 }, // 嬉しいねぇ、十七度目の婚姻だ……！
			{ PL=0, delay=160, SE=632, achievement_slot = 64}, // この国に染まりすぎよ
		],
	},

	// 暴走アルクェイド（duet先achievement_slot 64）
	{
		Enemy=[Def_ChrNo_Chr010], WaitPAT = [903,905],
		duet_timeline =
		[
			{ PL=0, PAT=904, delay=210, SE=107, achievement_slot = 63 }, // うそ、わたしあんなにキレないんですけどぉ！
			{ PL=1, PAT=906, delay=200, SE=102, achievement_slot = 64 }, // … 早く私を止めないと、タイヘンよ？
		],
	},
];


// 翡翠
// achievement_slot 62：遠野秋葉
// 60：遠野志貴
// 63；琥珀
// 61：セイバー
CommonStandbyParams[Def_ChrNo_Chr001] =
[
	{ ExcludeEnemy=[3], WaitPAT = 920, timeline = [ { PAT=921,SE=100, time=82 , delay=72  }, { PAT=922, delay=15 } ] }, // 失礼いたします
	{ ExcludeEnemy=[2,3], WaitPAT = 923, timeline = [ { PAT=924,SE=101, time=101, delay=101  }, { PAT=925, delay=10 } ] }, // 私でよろしいのですか？
	{ ExcludeEnemy=[2,3], WaitPAT = 920, timeline = [ { PAT=921,SE=102, time=121, delay=111 }, { PAT=922, delay=15 } ] }, // すみやかにお帰りいただきます
	{ ExcludeEnemy=[2,3], WaitPAT = 920, timeline = [ { PAT=921,SE=103, time=122, delay=112 }, { PAT=922, delay=15 } ] }, // お掃除、開始します
	{ WaitPAT = 920, timeline = [ { PAT=921,SE=107, time=147, delay=137 }, { PAT=922, delay=15 } ] }, // 「立て込んでおりますので、手短に」
	{ WaitPAT = 0,   timeline = [ { PAT=928,SE=108, time=120, delay=120 }, ] }, // 「珍しい催しものなのですね」
	
	//XXX:秋葉側にenemyがなくduet優先のためこれらが抽選されることがないので、duetを作るべき
	//XXX:下二つ秋葉専用セリフをduetに入れる場合は合わせてアチーブメントにも追加する
	{ Enemy=[Def_ChrNo_Chr002], WaitPAT = 920, timeline = [ { PAT=921, SE=810,time=76 , delay=66  }, { PAT=922, delay=15 } ] }, // 「失礼いたします」（ニュアンス違い）
	{ Enemy=[Def_ChrNo_Chr002], WaitPAT = 920, timeline = [ { PAT=921, SE=811,time=128, delay=118 }, { PAT=922, delay=15 } ] }, // 「お呼びでしょうか、秋葉さま」

	{ Enemy=[Def_ChrNo_Chr004], WaitPAT = 920, timeline = [ { PAT=926, SE=106,time=229, delay=215, achievement_slot = 63 }, { PAT=927, delay=15 } ] }, // ね、姉さん……い、いきます……！
	
	// セイバー（duet先achievement_slot 60）
	{
		Enemy=[Def_ChrNo_Chr012], WaitPAT = [901,0],
		duet_timeline =
		[
			{ PL=0, delay=220, SE=104, achievement_slot = 61 } // お腹がすいているのでしたらこちらの梅サンドなどいかがでしょうか
			{ PL=1, PAT=935, delay=220, SE=104, achievement_slot = 60 }, // ウメサンド……私の故郷の気配がしますね
		],
	},

	// 遠野志貴（duet先achievement_slot 65）
	{
		Enemy=[Def_ChrNo_Chr003], WaitPAT = [900,900],
		duet_timeline =
		[
			{ PL=0, delay=150, SE=105, achievement_slot = 60 } // 志貴さま、お休みの時間です
			{ PL=1, delay=140, SE=106, achievement_slot = 65 }, // … 軽い手合わせってコト？
		],
		checkfunc = function()
		{
			if( Battle_Std.GetEnemyBossFlag()==8 ) return 0;//七夜風志貴なので掛け合いなし
			return 1;
		}
	},
	{
		Enemy=[Def_ChrNo_Chr003], WaitPAT = [900,902],
		duet_timeline =
		[
			{ PL=0, delay=150, SE=105, achievement_slot = 60 } // 志貴さま、お休みの時間です
			{ PL=1, delay=140, SE=101, achievement_slot = 65 }, // 気は乗らないけど、仕方ない (汎用セリフだけどアチーブメント単体翡翠との固有のやり取りなので追加)
		],
		checkfunc = function()
		{
			if( Battle_Std.GetEnemyBossFlag()==8 ) return 0;//七夜風志貴なので掛け合いなし
			return 1;
		}
	},
];
	

// 遠野秋葉
//918:920>立ちループのアニメ
// achievement_slot 60：遠野志貴
// 70：琥珀
// 62：翡翠、琥珀
CommonStandbyParams[Def_ChrNo_Chr002] =
[
	{ ExcludeEnemy=[1,3,4], WaitPAT = 920, timeline = [ { PAT=920, SE=100, delay=94  }, { PAT=921, delay=15 } ] }, // 準備はいいですか？
	{ ExcludeEnemy=[1,3,4], WaitPAT = 920, timeline = [ { PAT=920, SE=101, delay=162 }, { PAT=921, delay=15 } ] }, // ……ほんとう、どうしてこんな……
	{ ExcludeEnemy=[1,3,4], WaitPAT = 920, timeline = [ { PAT=920, SE=102, delay=162 }, { PAT=921, delay=15 } ] }, // 私、甘くありませんから
	{ ExcludeEnemy=[0,5,9,10,14], WaitPAT = 920, timeline = [ { PAT=920, SE=103, time=96, delay=36  }, { PAT=918, delay=60 } ] }, // よろしくお願いします
	{ ExcludeEnemy=[0,5,9,10,14], WaitPAT = 920, timeline = [ { PAT=920, SE=104, delay=161 }, { PAT=921, delay=15 } ] }, // 怖いもの知らず、なのね
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=106, delay=117 }, { PAT=921, delay=15 } ] }, // 「覚悟はできているようね」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=107, delay=172 }, { PAT=921, delay=15 } ] }, // 「そう。手短にお願いします」

	// 翡翠（duet先achievement_slot 62）
	{
		Enemy=[Def_ChrNo_Chr001], WaitPAT = [900,900],
		duet_timeline =
		[
			{ PL=1, delay=187, SE=812, achievement_slot = 62 }, // 「昇給試験の時ですね。分かります」
			{ PL=0, delay=263, SE=630, achievement_slot = 62 }, // 「そういう話ではないのだけど……はあ。」
		],
	},
	{
		Enemy=[Def_ChrNo_Chr001], WaitPAT = [900,900],
		duet_timeline =
		[
			{ PL=0, delay=180, SE=631, achievement_slot = 62 }, // 「いいわ。当主として受けて立ちます」
			{ PL=1, delay=195, SE=813, achievement_slot = 62 }, // 「はい。清掃の技、お見せします」
		],
	},

	// MEMO:翡翠とのduetを追加したいが難しい
	// { Enemy=[Def_ChrNo_Chr002], WaitPAT = 920, timeline = [ { PAT=921, SE=810,time=76 , delay=66  }, { PAT=922, delay=15 } ] }, // 「失礼いたします」（ニュアンス違い）
	// { Enemy=[Def_ChrNo_Chr002], WaitPAT = 920, timeline = [ { PAT=921, SE=811,time=128, delay=118 }, { PAT=922, delay=15 } ] }, // 「お呼びでしょうか、秋葉さま」
	

	// 琥珀（duet先achievement_slot 62）※ボイスは翡翠と共通
	{
		Enemy=[Def_ChrNo_Chr004], WaitPAT = [900,903],
		duet_timeline =
		[
			{ PL=0, delay=180, SE=631, achievement_slot = 62 }, // 「いいわ。当主として受けて立ちます」
			{ PL=1, delay=154, SE=782, achievement_slot = 62 }, // 「まさか……昨日のアレがバレ……」（ばれたのかな？）
		],
	},
	{
		Enemy=[Def_ChrNo_Chr004], WaitPAT = [900,902],
		duet_timeline =
		[
			{ PL=1, delay=170, SE=780, achievement_slot = 62 }, // 「抜き打ちテストですね、秋葉さま！」
			{ PL=0, delay=263, SE=630, achievement_slot = 62 }, // 「そういう話ではないのだけど……はあ。」
		],
	},
	{
		Enemy=[Def_ChrNo_Chr004], WaitPAT = [900,905],
		duet_timeline =
		[
			{ PL=0, delay=180, SE=631, achievement_slot = 62 }, // 「いいわ。当主として受けて立ちます」
			{ PL=1, delay=190, SE=783, achievement_slot = 62 }, // 「志貴さんはお預かりしていませんよ？」
		],
	},
	// 琥珀（duet先achievement_slot 62）※このボイスは対琥珀のみ
	{
		Enemy=[Def_ChrNo_Chr004], WaitPAT = [900,905],
		duet_timeline =
		[
			{ PL=1, delay=190, SE=781, achievement_slot = 62 }, // 「これも遠野家の平和を守るため……」
			{ PL=0, delay=180, SE=108, achievement_slot = 70 }, // 「ところで仕事はいいのかしら？」※MEMO:元挑発ボイス
		],
	},

	// 遠野志貴（duet先achievement_slot 60）
	{
		Enemy=[Def_ChrNo_Chr003], WaitPAT = [900,904],
		duet_timeline =
		[
			{ PL=0, delay= 60, SE=105, achievement_slot = 60 } // ………………（※むすっとしたブレス芝居）
			{ PL=1, delay=140, SE=105, achievement_slot = 60 }, // 家庭内暴力反対！
		],
		checkfunc = function()
		{
			if( Battle_Std.GetEnemyBossFlag()==8 ) return 0;//七夜風志貴なので掛け合いなし
			return 1;
		}
	},
	{
		Enemy=[Def_ChrNo_Chr003], WaitPAT = [900,902],
		duet_timeline =
		[
			{ PL=1, delay=150, SE=104, achievement_slot = 60 } // 兄貴として心配だよ……
			{ PL=0, delay= 60, SE=105, achievement_slot = 60 }, // ………………（※むすっとしたブレス芝居）
		],
		checkfunc = function()
		{
			if( Battle_Std.GetEnemyBossFlag()==8 ) return 0;//七夜風志貴なので掛け合いなし
			return 1;
		}
	},
];

// 遠野志貴
//通常登場　921:80
//シリアス　924:40
// achievement_slot 63：アルクェイド
// 65：翡翠
// 60：遠野秋葉
// 64：琥珀
// 72：ノエル
// 67：暴走アルクェイド
// 71：シエル
// 62：翡翠、琥珀、翡翠＆琥珀
// 74：対ヒロイン

CommonStandbyParams[Def_ChrNo_Chr003] =
[
	//----七夜風志貴の場合----
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=700, time=197, delay= 127 }, { PAT=921, delay=80 } ],
		checkfunc = function()
		{
			if( BMvCore.GetBossFlag()!=8 ) return 0; // 七夜風志貴じゃないときは抽選されない
			return 1;
		},
	}, // 「夢から覚めても、また悪夢ってね」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=701, time=180, delay= 110 }, { PAT=921, delay=80 } ],
	checkfunc = function()
		{
			if( BMvCore.GetBossFlag()!=8 ) return 0; // 七夜風志貴じゃないときは抽選されない
			return 1;
		},
	}, // 「手向けの花は、いらないかな」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=702, time=180, delay= 110 }, { PAT=921, delay=80 } ], 
		checkfunc = function()
		{
			if( BMvCore.GetBossFlag()!=8 ) return 0; // 七夜風志貴じゃないときは抽選されない
			return 1;
		},
	}, // 「その不安、俺が斬り捨てる」
	//----七夜風志貴の場合----
	
	
	//誰にでも入るもの
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=101, time=155, delay= 80 }, { PAT=921, delay=80 } ],
		checkfunc = function()
		{
			if( BMvCore.GetBossFlag()==8 ) return 0; // 七夜風志貴のときは抽選されない
			return 1;
		},
	}, // 気は乗らないけど、仕方ない

	//ヒロイン以外
	{ ExcludeEnemy=[0,1,2,4,11,13,15], WaitPAT = 920, timeline = [ { PAT=920, SE=100, time= 67, delay= 10 }, { PAT=921, delay=80 } ],
		checkfunc = function()
		{
			if( Battle_Std.EnemyIsHeroine() ) return 0;
			if( BMvCore.GetBossFlag()==8 ) return 0; // 七夜風志貴のときは抽選されない
			return 1;
		},
	}, // 本気なんだな
	{ ExcludeEnemy=[0,1,2,4,11,13,15], WaitPAT = 920, timeline = [ { PAT=920, SE=102, time=145, delay= 80 }, { PAT=921, delay=80 } ],
		checkfunc = function()
		{
			if( Battle_Std.EnemyIsHeroine() ) return 0;
			if( BMvCore.GetBossFlag()==8 ) return 0; // 七夜風志貴のときは抽選されない
			return 1;
		},
	}, // 体力ないんだ。手短にすませよう。
	{ Enemy=[5,9], ExcludeEnemy=[0,1,2,4,11,13,15], WaitPAT = 923, timeline = [ { PAT=923, SE=103, time=123, delay= 90 }, { PAT=924, delay=40 } ],
		checkfunc = function()
		{
			if( Battle_Std.EnemyIsHeroine() ) return 0;
			if( BMvCore.GetBossFlag()==8 ) return 0; // 七夜風志貴のときは抽選されない
			return 1;
		},
	}, // ―――ああ、頭痛がする―――
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=113, time=222, delay=142 }, { PAT=921, delay=80 } ],
		checkfunc = function()
		{
			if( Battle_Std.EnemyIsHeroine() ) return 0;
			if( BMvCore.GetBossFlag()==8 ) return 0; // 七夜風志貴のときは抽選されない
			return 1;
		},
	}, // 「腕試しなら余所で……って、聞いてないか」
	{ Enemy=[5,9,14], WaitPAT = 920,  timeline = [ { PAT=920, SE=114, time=101, delay= 30 }, { PAT=921, delay=80 } ],
		checkfunc = function()
		{
			if( Battle_Std.EnemyIsHeroine() ) return 0;
			if( BMvCore.GetBossFlag()==8 ) return 0; // 七夜風志貴のときは抽選されない
			return 1;
		},
	}, // 「お互いツイてないな…」

	//ヒロイン時のみ
	{ Enemy=[Def_ChrNo_Chr000,Def_ChrNo_Chr001,Def_ChrNo_Chr002,Def_ChrNo_Chr004,Def_ChrNo_Chr011,Def_ChrNo_Chr013],
	WaitPAT = 902,  timeline = [ { PAT=902, SE=650, time=186, delay= 186, achievement_slot = 74 } ],
		checkfunc = function()
		{
			if( !Battle_Std.EnemyIsHeroine() ) return 0;
			if( BMvCore.GetBossFlag()==8 ) return 0; // 七夜風志貴のときは抽選されない
			return 1;
		},
	}, // 「うーん……なんでこんなコトに？」

	// 翡翠＆琥珀　XXX：翡翠のduetが抽選されているのでこれが抽選されてないと思われる
	{
		Enemy=[Def_ChrNo_Chr007], WaitPAT = [900,900],
		duet_timeline =
		[
			{ PL=0, delay=150, SE=106, achievement_slot = 62 } // 軽い手合わせってコト？
			{ PL=1, delay=200, SE=107, achievement_slot = 60 }, // …
		],
		checkfunc = function()
		{
			if( BMvCore.GetBossFlag()==8 ) return 0; // 七夜風志貴のときは抽選されない
			return 1;
		},
	},

	// シエル（duet先achievement_slot 71）
	{
		Enemy=[Def_ChrNo_Chr011], WaitPAT = [904,902],
		duet_timeline =
		[
			{ PL=1, delay=250, SE=106, achievement_slot = 71 } // 深夜の徘徊は感心できません！　これは任意同行ですね
			{ PL=0, delay=200, SE=108, achievement_slot = 71 }, // 先輩、それ職権乱用では？
		],
		checkfunc = function()
		{
			if( Battle_Std.StageInfoCheck() )
			{
				if( !Battle_Std.IsNightStage() ) return 0;//夜でない
				if( Battle_Std.IsIndoorStage() ) return 0;//家の中なので徘徊してない
			}
			if( BMvCore.GetBossFlag()==8 ) return 0; // 七夜風志貴のときは抽選されない
			return 1;
		}
	},
	{
		Enemy=[Def_ChrNo_Chr011], WaitPAT = [902,902],
		duet_timeline =
		[
			{ PL=0, delay=186, SE=650, } // うーん……なんでこんなコトに？(ヒロイン専用)
			{ PL=1, delay=241, SE=791, time=231 }, // （……ふふ……おそろい……おそろいメガネ（属性）です！）
		],
		checkfunc = function()
		{
			if( Battle_Std.StageInfoCheck() )
			{
				if( Battle_Std.IsNightStage() == 1 && Battle_Std.IsIndoorStage() == 0 ) return 0;//夜かつ外
			}
			if( BMvCore.GetBossFlag()==8 ) return 0; // 七夜風志貴のときは抽選されない
			return 1;
		}
	},
	
	// ノエル（duet先achievement_slot 60）
	{
		Enemy=[Def_ChrNo_Chr008], WaitPAT = [904,903],
		duet_timeline =
		[
			{ PL=0, delay=140, SE=109, achievement_slot = 72 } // シスターは趣味じゃなかったんですか！？
			{ PL=1, delay=180, SE=104, achievement_slot = 60 }, // 趣味でやってるのは先生の方なの
		],
		checkfunc = function()
		{
			if( BMvCore.GetBossFlag()==8 ) return 0; // 七夜風志貴のときは抽選されない
			return 1;
		},
	},

	// 暴走アルクェイド（duet先achievement_slot 60）
	{
		Enemy=[Def_ChrNo_Chr010], WaitPAT = [903,902],
		duet_timeline =
		[
			{ PL=1, delay=220, SE=104, achievement_slot = 60 } // こんばんは、私の素敵な殺人鬼さん
			{ PL=0, delay=170, SE=103, achievement_slot = 67 }, // ―――ああ、頭痛がする―――　XXX：上の方でロアとヴローヴに限定してがここで抽選して問題ないのか不明
		],
		checkfunc = function()
		{
			if( BMvCore.GetBossFlag()==8 ) return 0; // 七夜風志貴のときは抽選されない
			return 1;
		},
	},
];

// 琥珀
//通常登場　921:100	
// [Def_ChrNo_Chr002] = [780,781,782,783],
// [Def_ChrNo_Chr003] = [105],
// achievement_slot 62：遠野秋葉
// 61：遠野志貴
CommonStandbyParams[Def_ChrNo_Chr004] =
[		
	{ ExcludeEnemy=[2], WaitPAT = 920, timeline = [ { PAT=920, SE=100, time=192, delay=92 }, { PAT=921, delay=100 } ] }, // うふふふふ、はじめますよ〜
	{ ExcludeEnemy=[2], WaitPAT = 0,   timeline = [ { PAT=923, SE=101, time=192, delay=192 } ] },                        // 頼れるお手伝いさん、ただいま参上！
	{ ExcludeEnemy=[2], WaitPAT = 920, timeline = [ { PAT=920, SE=102, time=130, delay=30 }, { PAT=921, delay=100 } ] }, // どんなおクスリがお好みですか？
	{ ExcludeEnemy=[2], WaitPAT = 920, timeline = [ { PAT=920, SE=103, time=178, delay=78 }, { PAT=921, delay=100 } ] }, // 今宵の針は一味違いますよ〜
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=106, time=195, delay=95 }, { PAT=921, delay=100 } ] }, // 「ふっふっふ…。いざ尋常に……！」
	{ ExcludeEnemy=[0,1,2,3,6,7,8,10,11,13,15,16,20], WaitPAT = 920, timeline = [ { PAT=920, SE=107, time=249, delay=150}, { PAT=921, delay=100 } ], }, // 「なんと不審なお方でしょう…… 成敗、ですね！」
	// { WaitPAT = 920, timeline = [ { PAT=920, SE=108, time=86 , delay=0  }, { PAT=921, delay=100 } ] }, // 「(翡翠)姉妹の絆―― (琥珀)見せつけちゃいます！」
	// { WaitPAT = 920, timeline = [ { PAT=920, SE=109, time=96 , delay=0  }, { PAT=921, delay=100 } ] }, // 「(琥珀)これはなかなか…… 

	// 遠野志貴（duet先achievement_slot 74）※対琥珀ではなく対女性ヒロインでアチーブメントを解除
	{
		Enemy=[Def_ChrNo_Chr003], WaitPAT = [901,902],
		duet_timeline =
		[
			{ PL=0, delay=270, SE=105, achievement_slot = 61 } // ふふふ、見てしまいましたね志貴さん
			{ PL=1, delay=200, SE=650, achievement_slot = 74 }, // うーん……なんでこんなコトに？
		],
		checkfunc = function()
		{
			if( Battle_Std.GetEnemyBossFlag()==8 ) return 0;//七夜風志貴なので掛け合いなし
			return 1;
		}
	},
];


// ロア
// achievement_slot 61：アルクェイド
// 60：ヴローヴ
// 63：暴走アルクェイド
// 62：シエル
CommonStandbyParams[Def_ChrNo_Chr005] =
//920:棒立ち 921:ポリポリ 922:戻り15
[		
	{ ExcludeEnemy=[0,10,12,19], WaitPAT = 920, timeline = [ { PAT=921, SE=100, time=177, delay=162 }, { PAT=922, delay=15 } ],
		checkfunc = function()
		{
			//何度も命がありそうなのは除外
			if( Battle_Std.EnemyIsVampire() ) return 0;//吸血鬼は除外
			return 1;
		},
	}, // やれやれ。一度しかない命を
	{ ExcludeEnemy=[0,10], WaitPAT = 0,   timeline = [ { PAT=924, SE=101, time=149, delay=149 } ] }, // おや。早死にをご所望かい？
	{ ExcludeEnemy=[0,10], WaitPAT = 0,   timeline = [ { PAT=924, SE=102, time=172, delay=179 } ] }, // いいぜ。簡潔にすませよう
	{ ExcludeEnemy=[0,1,2,3,4,7,10,13,14,19], WaitPAT = 920, timeline = [ { PAT=921, SE=103, time=178, delay=163 }, { PAT=922, delay=15 } ] }, // ふむ……この体では限度があるが……
	{ ExcludeEnemy=[0,10], WaitPAT = 920, timeline = [ { PAT=921, SE=104, time=165, delay=150 }, { PAT=922, delay=15 } ] }, // 殺しに飽いているんだがねぇ
	{ WaitPAT = 0,   timeline = [ { PAT=923, SE=107, time=194, delay=194 }, ],
		checkfunc = function()
		{
			if( Battle_Std.StageInfoCheck() )
			{
				if( !Battle_Std.IsNightStage() ) return 0;//夜でない
			}
			return 1;
		}
	}, // 「イキがいい。今夜はツイてる」
	{ WaitPAT = 0,   timeline = [ { PAT=924, SE=108, time=231, delay=231 }, ],
		checkfunc = function()
		{
			//人生？みたいなのは除外
			if( Battle_Std.EnemyIsVampire() ) return 0;//吸血鬼は除外
			return 1;
		},
	}, // 「まったく、人生とやらは素晴らしいな」
	
	// { WaitPAT = 0,   timeline = [ { PAT=924, SE=108, time=231, delay=231 }, ], }, // 「まったく、人生とやらは素晴らしいな」	

	// 暴走アルクェイド（duet先achievement_slot 65）
	{
		Enemy=[Def_ChrNo_Chr010], WaitPAT = [900,904],
		duet_timeline =
		[
			{ PL=1, delay=252, SE=660, achievement_slot = 65 } // 「最高の時に、最悪の邪魔が入るなんて。」
			{ PL=0, delay=330, SE=630, achievement_slot = 63 }, // 「器の臨界が近いのか……？　百年の恋も冷める、というものだ。」
		],
	},
	{
		Enemy=[Def_ChrNo_Chr010], WaitPAT = [900,901],
		duet_timeline =
		[
			{ PL=0, delay=330, SE=630, achievement_slot = 63 }, // 「器の臨界が近いのか……？　百年の恋も冷める、というものだ。」
			{ PL=1, PAT=904, delay=361, SE=661, achievement_slot = 65 } // 「ああ、いたわね。そんな蛇。また踏み潰されたいの？」
		],
	},

	// ヴローヴ（duet先achievement_slot 61）
	{
		Enemy=[Def_ChrNo_Chr009], WaitPAT = [903,902],
		duet_timeline =
		[
			{ PL=1, delay=230, SE=105, achievement_slot = 61 } // ……蛇め。その皮、尾まで剥いで殺す
			{ PL=0, delay=200, SE=109, achievement_slot = 60 }, // 皮でいいなら、いくらでもくれてやるよ
		],
	},

	// シエル（duet先achievement_slot 61）
	{
		Enemy=[Def_ChrNo_Chr011], WaitPAT = [903,901],
		duet_timeline =
		[
			{ PL=1, delay=200, SE=107, achievement_slot = 61 } // 転生の終焉です、アカシャの蛇
			{ PL=0, delay=200, SE=106, achievement_slot = 62 }, // さて―――そうであれば良いのですが
		],
	},
];


// 軋間紅摩
CommonStandbyParams[Def_ChrNo_Chr006] =
//920:バサバサ 921:70
[
	{ ExcludeEnemy=[4], WaitPAT = 920, timeline = [ { PAT=920, SE=100, time=66 , delay=10  }, { PAT=921, delay=70 } ] }, // ……潰す
	{ ExcludeEnemy=[4], WaitPAT = 920, timeline = [ { PAT=920, SE=101, time=114, delay=54  }, { PAT=921, delay=70 } ] }, // 引導を渡してやる
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=102, time=125, delay=65  }, { PAT=921, delay=70 } ] }, // 娑婆は騒がしいな……
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=103, time=144, delay=84  }, { PAT=921, delay=70 } ] }, // 笑い話で済めばいいがな
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=104, time=223, delay=163 }, { PAT=921, delay=70 } ] }, // 「相手にはなるが、望みは叶わんぞ」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=105, time=265, delay=205 }, { PAT=921, delay=70 } ] }, // 「酔狂きわまったか。羨ましい話だ」
];

//ヒスコハ
//MEMO:開始時は必ず翡翠が先なんだけど、それ前提で作るのはちょっと怖い気もする

CommonStandbyParams[Def_ChrNo_Chr007] =
[
	{
		WaitPAT = [920,922],
		OffsetPosition = [ {x=-25,y=0}, {x=25,y=0} ], // 開始座標オフセット
		timeline =
		[
			{ TAG=0, PAT=928, SE=115, delay=77, camera_time=77+86 },//(翡翠)姉妹の絆――
			{ TAG=1, PAT=924, SE=108, delay=86, camera=0 },//(琥珀)見せつけちゃいます！
		]
	},
	{
		WaitPAT = [920,922],
		OffsetPosition = [ {x=-200,y=0}, {x=200,y=0} ], // 開始座標オフセット
		timeline =
		[
			{ TAG=1, PAT=925, SE=109, delay=96, camera_time=96+142 },//(琥珀)これはなかなか…… 
			{ TAG=0, PAT=928, SE=116, delay=142, camera=0 },//(翡翠)心してかかりましょう、姉さん
		]
	},
	{
		WaitPAT = [920,922],
		OffsetPosition = [ {x=-200,y=0}, {x=200,y=0} ], // 開始座標オフセット
		timeline =
		[
			{ TAG=1, PAT=926, SE=700, delay=115, camera_time=115+78 },//(琥珀)遠慮はなしよ、翡翠ちゃん！
			{ TAG=0, PAT=932, SE=700, delay=78, camera=0 },//(翡翠)……僭越ながら
		]
	},
	{
		WaitPAT = [920,922],
		OffsetPosition = [ {x=-25,y=0}, {x=25,y=0} ], // 開始座標オフセット
		timeline =
		[
			{ TAG=0, PAT=928, SE=701, delay=45, camera_time=45+115 },//(翡翠)……姉さん
			{ TAG=1, PAT=924, SE=701, delay=115, camera=0 },//(琥珀)ええ、本気でいきます
		]
	},
	{
		WaitPAT = [920,922],
		OffsetPosition = [ {x=-200,y=0}, {x=200,y=0} ], // 開始座標オフセット
		timeline =
		[
			{ TAG=1, PAT=924, SE=702, delay=89, camera_time=89+113 },//(琥珀)かたづけちゃいます？
			{ TAG=0, PAT=928, SE=702, delay=103, camera=0 },//(翡翠)私たちの仕事ですから
		]
	},
	{
		WaitPAT = [920,922],
		OffsetPosition = [ {x=-200,y=0}, {x=200,y=0} ], // 開始座標オフセット
		timeline =
		[
			{ TAG=1, PAT=924, SE=703, delay=69, camera_time=69+144 },//(琥珀)ではでは
			{ TAG=0, PAT=928, SE=703, delay=144, camera=0 },//(翡翠)はい、清掃の時間です
		]
	},
	{
		ExcludeEnemy=[19], // 強そうではないので除外
		WaitPAT = [920,922],
		OffsetPosition = [ {x=-200,y=0}, {x=200,y=0} ], // 開始座標オフセット
		timeline =
		[
			{ TAG=1, PAT=925, SE=704, delay=171, camera_time=171+147 },//(琥珀)んー、強そうですねー
			{ TAG=0, PAT=928, SE=704, delay=147, camera=0 },//(翡翠)真面目にやってください姉さん
		]
	},
];



// ノエル
// achievement_slot 60：遠野志貴
// 62：暴走アルクェイド
// 61：シエル
CommonStandbyParams[Def_ChrNo_Chr008] =
[	
	{ ExcludeEnemy=[11,16], WaitPAT = 920, timeline = [ { PAT=920, SE=100, time=166, delay=146 }, { PAT=921, delay=40 } ] }, // 「さーて、お仕事お仕事！」
	{ ExcludeEnemy=[11,16], WaitPAT = 920, timeline = [ { PAT=920, SE=101, time=191, delay=151 }, { PAT=921, delay=40 } ] }, // 「代行者ノエル、華麗にとうじょ〜う！」
	{ ExcludeEnemy=[11,16], WaitPAT = 920, timeline = [ { PAT=920, SE=102, time=175, delay=135 }, { PAT=921, delay=40 } ] }, // 「へぇ。懺悔タイム、いっちゃう？」
	{ ExcludeEnemy=[1,2,3,4,7,13], WaitPAT = 920, timeline = [ { PAT=920, SE=107, time=161, delay=121 }, { PAT=921, delay=40 } ] }, // 「うしっ！　戦闘開始だ、私！」
	{ ExcludeEnemy=[0,5,9,10,11,12,14,16], WaitPAT = 923, timeline = [ { PAT=923, SE=103, time=200, delay=110 }, { PAT=924, delay=90 } ], }, // 「手加減とか、そういうの期待しないでね？」
	{ ExcludeEnemy=[0,5,9,10,11,12,14,16,19], WaitPAT = 923, timeline = [ { PAT=923, SE=108, time=182, delay=92 }, { PAT=924, delay=90 } ], }, // 「生意気な目しちゃって、このこの〜☆」
	//武装シエルは 「うしっ！　戦闘開始だ、私！」のみになるように
	
	//シエル（duet先achievement_slot 64）
	{
		Enemy=[Def_ChrNo_Chr011], WaitPAT = [900,903],
		duet_timeline =
		[
			{ PL=0, delay=143, SE=105, achievement_slot = 61 } // ご指導、お願いしま〜す
			{ PL=1, delay=122, SE=750, achievement_slot = 64 }, // 「アナタは、まったく……」
		],
	},
	{
		Enemy=[Def_ChrNo_Chr011], WaitPAT = [900,903],
		duet_timeline =
		[
			{ PL=0, delay=143, SE=105, achievement_slot = 61 } // ご指導、お願いしま〜す
			{ PL=1, delay=106, SE=751, achievement_slot = 64 }, // 「日課はこなしていますか？」
		],
	},
	{
		Enemy=[Def_ChrNo_Chr011], WaitPAT = [900,903],
		duet_timeline =
		[
			{ PL=0, delay=143, SE=105, achievement_slot = 61 } // ご指導、お願いしま〜す
			{ PL=1, delay=172, SE=752, achievement_slot = 64 }, // 「お喋りの前に呼吸を整えてください」
		],
	},
	
	//暴走アルクェイド（duet先achievement_slot 63）
	{
		Enemy=[Def_ChrNo_Chr010], WaitPAT = [902,901],
		duet_timeline =
		[
			{ PL=0, delay=325, SE=106, achievement_slot = 62 } // ひぃぃぃ、ただでさえおっかない真祖が、しまっちゃう真祖になってるぅ〜！
			{ PL=1, PAT=904, delay=205, SE=107, achievement_slot = 63 }, // ……よくこんなのと組んでるわね、シエル……
		],
	},
	
	//ロア
	{
		Enemy=[Def_ChrNo_Chr005], WaitPAT = [906,900],
		duet_timeline =
		[
			{ PL=0, delay=156, SE=690, time=146 }, // ……あれが今回のロア……？
			{ PL=1, delay=275, SE=651, time=265 }, // どうした？　殺意が足りないぜ、お嬢さん
		],
	},	
];


// ヴローヴ
// achievement_slot 60：アルクェイド
// 61：ロア
// 62：シエル
CommonStandbyParams[Def_ChrNo_Chr009] =

//920:ループ 921:45
[	
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=100, time=177, delay=135 }, { PAT=921, delay=45 } ] }, // 「――――いい薪だ。割り甲斐がある。」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=101, time=176, delay=135 }, { PAT=921, delay=45 } ] }, // 「貴様は……何者だ……」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=102, time=177, delay=135 }, { PAT=921, delay=45 } ] }, // 「抗うな。熱が下がる。」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=103, time=146, delay=110 }, { PAT=921, delay=45 } ] }, // 「名乗る必要はない。お互いな。」
	{ ExcludeEnemy = [0,5,9,10,12,14,19], WaitPAT = 920, timeline = [ { PAT=920, SE=107, time=239, delay=195 }, { PAT=921, delay=45 } ], }, // 「血袋。たき火程度にはなるか。」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=108, time=161, delay=116 }, { PAT=921, delay=45 } ] }, // 「生きる術を間違えたな」

	// シエル（duet先achievement_slot 63）
	{
		Enemy=[Def_ChrNo_Chr011], WaitPAT = [900,904],
		duet_timeline =
		[
			{ PL=0, delay=300, SE=106, achievement_slot = 62 } // ……剣僧の教え子か。竜骨剣は持たないのか？
			{ PL=1, delay=230, SE=105, achievement_slot = 63 }, // ……あいにく、第七聖典は安い武器ではありませんので。
		],
	},
];


// 暴走アルクェイド
// achievement_slot 64：アルクェイド
// 60：遠野志貴
// 65：ロア
// 63：ノエル
// 61：シエル
// 62：セイバー
CommonStandbyParams[Def_ChrNo_Chr010] =
//920:ループ 921:70
[	
	{ ExcludeEnemy = [0,3,5,9,10,12,14,19,20,21,22], WaitPAT = 920, timeline = [ { PAT=920, SE=100, time=192, delay=122 }, { PAT=921, delay=70 } ], }, // 「本当、人間って可哀想ね」
	{ ExcludeEnemy=[3,5,11], WaitPAT = 920, timeline = [ { PAT=920, SE=101, time=135, delay=70  }, { PAT=921, delay=70 } ] }, // 「無様に楽しませてくれる？」
	{ ExcludeEnemy=[3,5,11], WaitPAT = 920, timeline = [ { PAT=920, SE=102, time=194, delay=124 }, { PAT=921, delay=70 } ] }, // 「早く私を止めないと、タイヘンよ？」
	{ ExcludeEnemy=[3,5,11], WaitPAT = 920, timeline = [ { PAT=920, SE=103, time=208, delay=138 }, { PAT=921, delay=70 } ] }, // 「待っていて、すぐに殺してあげるから」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=108, time=328, delay=258 }, { PAT=921, delay=70 } ] }, // 「ふふ。ほんの少しだけ、遊んでいく？」
	{ ExcludeEnemy=[11], WaitPAT = 901, timeline = [ { PAT=904, SE=109, time=199, delay=199 }, ]                       }, //　「んー……コレは特にいらないかな？」
];

// シエル
// achievement_slot 66：アルクェイド
// 71：遠野志貴
// 61：ロア
// 64：ノエル
// 63：ヴローヴ
// 62：暴走アルクェイド
// 65：アルクェイド、暴走アルクェイド
CommonStandbyParams[Def_ChrNo_Chr011] =
//920:制服ループ 921:130
[	
	{ ExcludeEnemy=[3,5,8,14], WaitPAT = 920, timeline = [ { PAT=920, SE=100, time= 95, delay=10  }, { PAT=921, delay=130 } ] }, // 「懺悔は済みましたか？」
	{ ExcludeEnemy=[5,9,10,14], WaitPAT = 920, timeline = [ { PAT=920, SE=101, time=125, delay=10  }, { PAT=921, delay=130 } ] }, // 「食後の運動といきますか」
	// XXX：対吸血鬼は全部duetかEnemyで指定されているため抽選されていない
	{ ExcludeEnemy=[3,5,8,15], WaitPAT = 920, timeline = [ { PAT=920, SE=102, time=150, delay=30  }, { PAT=921, delay=130 } ],
		checkfunc = function()
		{
			if( !Battle_Std.EnemyIsVampire() ) return 0;//吸血鬼じゃなかったら除外
			return 1;
		}
	}, // 「その魂、煉獄に送ります」
	{ ExcludeEnemy=[5,9,10,14,15], WaitPAT = 920, timeline = [ { PAT=920, SE=103, time=176, delay=46  }, { PAT=921, delay=130 } ] }, // 「さて、どう片付けたものでしょうか……」
	// XXX：対吸血鬼は全部duetかEnemyで指定されているため抽選されていない
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=113, time= 140, delay=10  }, { PAT=921, delay=130 } ],
		checkfunc = function()
		{
			if( !Battle_Std.EnemyIsVampire() ) return 0;//吸血鬼じゃなかったら除外
			return 1;
		}
	}, // 「裁きの時間です」
	{ ExcludeEnemy=[5,9,10,14,15], WaitPAT = 920, timeline = [ { PAT=920, SE=114, time=144, delay=14  }, { PAT=921, delay=130 } ] }, // 「食事の前の運動と行きますか」

	// 抽選されてなかったのでduetに移動
	// { Enemy=[Def_ChrNo_Chr010], WaitPAT = 901, timeline = [ { SE=780, time=268, delay=268, achievement_slot = 62 }, ] }, // 「理性をうしな……失礼、はじめからありませんでしたね。」 
	// アルク系 ※対暴走アルクはduetがあるのでそちらで対応
	{ Enemy=[Def_ChrNo_Chr000], WaitPAT = 901, timeline = [ { SE=781, time=184, delay=184, achievement_slot = 65 }, ] }, // 「代行者として、吸血鬼を排除します」
	// アルクェイド
	{ Enemy=[Def_ChrNo_Chr000], WaitPAT = 920, timeline = [ { PAT=920, SE=102, time=150, delay=30  }, { PAT=921, delay=130 }, ] }, // 「その魂、煉獄に送ります」 XXX：対アルクが一つしかないため抽選されるように対吸血鬼用セリフを個別追加
	{ Enemy=[Def_ChrNo_Chr000], WaitPAT = 920, timeline = [ { PAT=920, SE=113, time=140, delay=10  }, { PAT=921, delay=130 }, ] }, // 「裁きの時間です」 XXX：対アルクが一つしかないため抽選されるように対吸血鬼用セリフを個別追加

	// 暴走アルクェイド（duet先achievement_slot 61）
	{
		Enemy=[Def_ChrNo_Chr010], WaitPAT = [904,906],
		duet_timeline =
		[
			{ PL=1, delay=260, SE=105, achievement_slot = 61 } // いい体ね。メチャクチャにしてあげる……！
			{ PL=0, delay=220, SE=104, achievement_slot = 62 }, // その前に、その茹だった頭をたたき割りましょう
		],
	},
	{
		Enemy=[Def_ChrNo_Chr010], WaitPAT = [903,906],
		duet_timeline =
		[
			{ PL=1, delay=260, SE=105, achievement_slot = 61 } // いい体ね。メチャクチャにしてあげる……！
			{ PL=0, delay=268, SE=780, achievement_slot = 62 }, // 「理性をうしな……失礼、はじめからありませんでしたね。」 
		],
	},
	{
		Enemy=[Def_ChrNo_Chr010], WaitPAT = [901,920],
		duet_timeline =
		[
			{ PL=0, delay=184, SE=781, achievement_slot = 65 }, // 「代行者として、吸血鬼を排除します」
			{ PL=1, time=192, delay=122, SE=100, achievement_slot = 61 } // 「本当、人間って可哀想ね」
			{ PL=1, delay=70, PAT=921 } // 「本当、人間って可哀想ね」
		],
	},
];


// セイバー
// achievement_slot 60：翡翠
// 61：暴走アルクェイド
CommonStandbyParams[Def_ChrNo_Chr012] =
//920:ループ 921:75
//926:私服ループ 927:首振り驚き　928:45
[
	{ WaitPAT = 920, timeline = [ { PAT=921, SE=100, time=60 , delay=10  }, { PAT=921, delay=75 } ] }, // 「始めましょう」
	{ WaitPAT = 920, timeline = [ { PAT=921, SE=101, time=83 , delay=13  }, { PAT=921, delay=75 } ] }, // 「手加減は無用です」
	{ WaitPAT = 920, timeline = [ { PAT=921, SE=102, time=104, delay=30  }, { PAT=921, delay=75 } ] }, // 「死力を尽くしてくるがいい」
	{ WaitPAT = 926, timeline = [ { PAT=927, SE=103, time=180, delay=160 }, { PAT=928, delay=45 } ] }, // 「食ログではこのあたりに……は！？」
	{ WaitPAT = 920, timeline = [ { PAT=921, SE=106, time=81 , delay=10  }, { PAT=921, delay=75 } ] }, // 「挑戦に応じよう」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=107, time=143, delay=73  }, { PAT=921, delay=75 } ] }, // 「人の目につかなければいいのですが……」

	// 暴走アルクェイド（duet先achievement_slot 62）
	{
		Enemy=[Def_ChrNo_Chr010], WaitPAT = [901,905],
		duet_timeline =
		[
			{ PL=0, delay=320, SE=105, achievement_slot = 61 } // これは……高純度の精霊……！？こんなものがまだ残っているとは……！
			{ PL=1, PAT=906, delay=370, SE=106, achievement_slot = 62 }, // それはこっちの台詞よ、剣の王様。おとなしくアヴァロンにひっこんでくださらない？
		],
	},
];

// 有間都古
// achievement_slot 60：遠野秋葉
// 61：遠野志貴
CommonStandbyParams[Def_ChrNo_Chr013] =
[
	{ ExcludeEnemy=[2,3], WaitPAT = 920, timeline = [ { PAT=920, SE=100, time=100, delay= 10 }, { PAT=921, delay=100 } ] }, // 「よーし、行くぞー！」
	{ ExcludeEnemy=[2,3], WaitPAT = 920, timeline = [ { PAT=920, SE=101, time=125, delay= 25 }, { PAT=921, delay=100 } ] }, // 「こんふーの成果、見せてあげるっ」
	{ ExcludeEnemy=[2], WaitPAT = 0,   timeline = [ { PAT=922, SE=102, time=143, delay=143 },                      ] }, // 「せいせいどうどう、お願いしますっ！」
	{ ExcludeEnemy=[2,3], WaitPAT = 920, timeline = [ { PAT=920, SE=103, time=114, delay= 14 }, { PAT=921, delay=100 } ] }, // 「ふぁいと、おー！」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=105, time=152, delay= 52 }, { PAT=921, delay=100 } ] }, // 「あたしの八極拳、受けてみろ！」
	{ ExcludeEnemy=[0,1,3,4,6,7,8,11,12,13,15,16], WaitPAT = 900, timeline = [ { PAT=900, SE=104, time=114, delay= 14 }, { PAT=923, delay=100 } ],	}, // 「勝負だ、わるもの！」
	{ Enemy=[Def_ChrNo_Chr002], WaitPAT = 900, timeline = [ { PAT=900, SE=740, time=140, delay= 40, achievement_slot = 60 }, { PAT=923, delay=100 } ] }, // お、お兄ちゃんを返せ！
	{ Enemy=[Def_ChrNo_Chr002], WaitPAT = 900, timeline = [ { PAT=900, SE=741, time=189, delay= 90, achievement_slot = 60 }, { PAT=923, delay=100 } ] }, // 「お兄ちゃんはあたしのお兄ちゃんなんだからーっ！」
	/*
	{
		Enemy=[Def_ChrNo_Chr002], WaitPAT = [900,900],
		duet_timeline =
		[
			{ PL=0, delay=30, SE=740, time=140, achievement_slot = 60 }, // お、お兄ちゃんを返せ！
			{ PL=0, PAT=901, delay=110, },
			{ PL=1, delay=140, SE=101, achievement_slot = 61 }, // ……ほんとう、どうしてこんな……
		],
	},
	{
		Enemy=[Def_ChrNo_Chr002], WaitPAT = [900,900],
		duet_timeline =
		[
			{ PL=0, delay=90, SE=741, time=189, }, // 「お兄ちゃんはあたしのお兄ちゃんなんだからーっ！」
			{ PL=0, PAT=901, delay=110, },
			{ PL=1, delay=140, SE=101, achievement_slot = 61 }, // ……ほんとう、どうしてこんな……
		],
	},
	*/
	// 遠野志貴（duet先achievement_slot 68）
	{
		Enemy=[Def_ChrNo_Chr003], WaitPAT = [900,902],
		duet_timeline =
		[
			{ PL=0, delay=160, SE=700, time=310, achievement_slot = 61 }, // お、おおお、おにい…………あうう、いっくぞー！
			{ PL=0, PAT=901, delay=150 }, // お、おおお、おにい…………あうう、いっくぞー！
			{ PL=1, delay=186, SE=650, achievement_slot = 74 } // うーん……なんでこんなコトに？(ヒロイン専用)
			// { PL=1, delay=150, SE=101, achievement_slot = 68 }, // 気は乗らないけど、仕方ない
		],
		checkfunc = function()
		{
			if( Battle_Std.GetEnemyBossFlag()==8 ) return 0;//七夜風志貴なので掛け合いなし
			return 1;
		}
	},
];


// 吸血鬼ノエル
CommonStandbyParams[Def_ChrNo_Chr014] =
[
	{ WaitPAT = 930, timeline = [ { PAT=930, SE=100, time=182, delay=95 }, { PAT=931, delay=120 } ] }, // 「こわーいウサギ狩りのはじまりね？」
	{ WaitPAT = 930, timeline = [ { PAT=930, SE=101, time=237, delay=140 }, { PAT=931, delay=120 } ] }, // 「なぶられたいんでしょ？　遠慮しなくていいのよ？」
	{ ExcludeEnemy=[0,5,9,10,12,14], WaitPAT = 930, timeline = [ { PAT=930, SE=102, time=259, delay=150 }, { PAT=931, delay=120 } ] }, // 「はい、現実終了〜☆　リセット、してあげる?」
	{ WaitPAT = 930, timeline = [ { PAT=930, SE=103, time=204, delay=100 }, { PAT=931, delay=120 } ] }, // 「このオモチャ、どんな声で鳴くのかなぁ！」
	{ WaitPAT = 930, timeline = [ { PAT=930, SE=104, time=227, delay=120 }, { PAT=931, delay=120 } ] }, // 「はあ？　戦いになるとか思ってる？」
	{ WaitPAT = 930, timeline = [ { PAT=930, SE=105, time=185, delay=80 }, { PAT=931, delay=120 } ] }, //  「ねえ、興奮してる？　たまんない？」
	
	{ ExcludeEnemy = [0,3,5,9,10,12,14,19,20,21,22], WaitPAT = 930, timeline = [ { PAT=930, SE=110, time=147, delay=40 }, { PAT=931, delay=120 } ] }, //  「ニンゲンってほんとみじめ?」 人間のみ
	
	// 遠野志貴
	{
		Enemy=[Def_ChrNo_Chr003], WaitPAT = [930,923],
		duet_timeline =
		[
			{ PL=0, delay=220, SE=111, time=210 },//「逃げないんだ。なっまいき〜?」
			{ PL=1, delay=192, SE=670, time=182 },//「そりゃあ、怖がる理由がないからな」
		],
		checkfunc = function()
		{
			if( Battle_Std.GetEnemyBossFlag()==8 ) return 0;//七夜風志貴なので掛け合いなし
			return 1;
		}
	},
	{
		Enemy=[Def_ChrNo_Chr003], WaitPAT = [930,923],
		duet_timeline =
		[
			{ PL=1, delay=176, SE=671, time=166 },//「―――そうか。手遅れなんだな」
			{ PL=0, delay=245, SE=115, time=235 },//「 そ。わたしに見つかっちゃった志貴クンがね？」
		],
		checkfunc = function()
		{
			if( Battle_Std.GetEnemyBossFlag()==8 ) return 0;//七夜風志貴なので掛け合いなし
			return 1;
		}
	},
	
	// アルクェイド
	{
		Enemy=[Def_ChrNo_Chr000], WaitPAT = [930,920],
		duet_timeline =
		[
			{ PL=0, delay=254, SE=112, time=244 },//「なーんだ。これならなんとかなりそうじゃない？」
			{ PL=1, delay=100, SE=680, time=216 },//「ええ。レベル、合わせてあげてるもの」
			{ PL=1, PAT=921, delay=116 },
		],
	},

	// 暴走アルクェイド
	{
		Enemy=[Def_ChrNo_Chr010], WaitPAT = [921,910],
		duet_timeline =
		[
			{ PL=0, delay=160, SE=113, time=253 },//「ちょっ、なによアレ！？　聞いてないわよ！？」
			{ PL=0, PAT=922, delay=103 },
			{ PL=1, PAT=911, delay=290, SE=680, time=280 },//「うるさい蚊トンボ。ああ、すり潰されたいんだ？」
		],
	},

	// ロア
	{
		Enemy=[Def_ChrNo_Chr005], WaitPAT = [930,903],
		duet_timeline =
		[
			{ PL=0, delay=263, SE=114, time=253 },//「誰よ、アナタ。シエルの体できなさいよ」
			{ PL=1, delay=324, SE=650, time=314 },//「そう言うなご同輩。たっぷり痺れさせてやる。」
		],
	},

	// シエル
	{
		Enemy=[Def_ChrNo_Chr011], WaitPAT = [930,904],
		duet_timeline =
		[
			{ PL=0, delay=341, SE=116, time=331 },//「あは―――あははは！　やった、わたしのが強いじゃん！ 」
			{ PL=1, delay=221, SE=790, time=211 },//「ええ。そうである事を期待します。」
		],
	},
];

// 蒼崎青子
CommonStandbyParams[Def_ChrNo_Chr015] =
[
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=100, time=309, delay=100 }, { PAT=925, delay=220 } ] }, // 「なに、バトル？　うんうん、旅先はこうでないとね！」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=101, time=118, delay=62 }, { PAT=921, delay=70 } ] }, // 「ちょっとワクワクしてきたかも」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=102, time=83, delay=30 }, { PAT=921, delay=70 } ] }, // 「お手柔らかにね」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=103, time=316, delay=250 }, { PAT=921, delay=76 } ] }, // 「わたし、容赦ないけど大丈夫？　（勝ったら）根こそぎもっていくけど？」
	{ ExcludeEnemy=[1,2,3,4,13], WaitPAT = 920, timeline = [ { PAT=920, SE=104, time=134, delay=95 }, { PAT=921, delay=60 } ] }, // 「そのケンカ、買いましょう！」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=105, time=116, delay=70 }, { PAT=921, delay=60 } ] }, // 「食後の運動ってね」
	
	{ Enemy=[Def_ChrNo_Chr002], WaitPAT = 928, timeline = [ { PAT=928, SE=118, time=202, delay= 212 } ] }, // 「志貴の妹さん……え、ホントに？」
	{ Enemy=[Def_ChrNo_Chr002], WaitPAT = 928, timeline = [ { PAT=928, SE=119, time=160, delay= 210 } ] }, // 「……この子、私と被ってない……？」

	// アルクェイド
	{
		Enemy=[Def_ChrNo_Chr000], WaitPAT = [920,920],
		duet_timeline =
		[
			{ PL=0, delay=177, SE=110, time=167 },//「こんなところにいていいの、お姫さま？」
			{ PL=1, PAT=921,delay=226, SE=682, time=216 },//「アナタの方こそね、最新の魔法使い。」
		],
	},
	{
		Enemy=[Def_ChrNo_Chr000], WaitPAT = [929,905],
		duet_timeline =
		[
			{ PL=0, delay=201, SE=111, time=191 },//「本気でどうぞ。こっちもマックス出しましょう！」
			{ PL=1, PAT=904, delay=144, SE=681, time=134 },//「え？　ダメでしょ、それ！？」
		],
	},
	
	// 遠野志貴
	{
		Enemy=[Def_ChrNo_Chr003], WaitPAT = [929,900],
		duet_timeline =
		[
			{ PL=0, delay=166, SE=112, time=156 },//「じゃ、ちょっと手合わせ、してみよっか！」
			{ PL=1, delay=192, SE=672, time=182 },// もう。先生らしいですね
		],
		checkfunc = function()
		{
			if( Battle_Std.GetEnemyBossFlag()==8 ) return 0;//七夜風志貴なので掛け合いなし
			return 1;
		}
	},
	{
		Enemy=[Def_ChrNo_Chr003], WaitPAT = [926,902],
		duet_timeline =
		[
			{ PL=0, delay=167, SE=113, time=157 },//「先生　が　現れた！」
			{ PL=1, delay=223, SE=673, time=213 },// そうだった……この人、こういう人だった
		],
		checkfunc = function()
		{
			if( Battle_Std.GetEnemyBossFlag()==8 ) return 0;//七夜風志貴なので掛け合いなし
			return 1;
		}
	},
	{
		Enemy=[Def_ChrNo_Chr003], WaitPAT = [920,904],
		duet_timeline =
		[
			{ PL=1, delay=181, SE=674, time=171 },// 試合で近状報告とか、本気ですか！？
			{ PL=0, delay=238, SE=114, time=228 },//「もち。百聞は一見にしかず、って言うでしょ？」
		],
		checkfunc = function()
		{
			if( Battle_Std.GetEnemyBossFlag()==8 ) return 0;//七夜風志貴なので掛け合いなし
			return 1;
		}
	},
	
	// 暴走アルクェイド
	{
		Enemy=[Def_ChrNo_Chr010], WaitPAT = [929,905],
		duet_timeline =
		[
			{ PL=0, delay=161, SE=115, time=151 },//「来なさい。相手になってあげる。」
			{ PL=1, PAT=906, delay=236, SE=681, time=226 },// いい顔ね。屈服させ甲斐があるわ
		],
	},
	{
		Enemy=[Def_ChrNo_Chr010], WaitPAT = [929,908],
		duet_timeline =
		[
			{ PL=1, delay=346, SE=682, time=338 },// 忌まわしい秩序の飼い犬……ここで弾き出してあげる。
			{ PL=0, delay=268, SE=121, time=258 },//それはゴメン被るわ。戻ってくるの、タイヘンなのよ？
		],
	},	
	
	// ロア
	{
		Enemy=[Def_ChrNo_Chr005], WaitPAT = [928,900],
		duet_timeline =
		[
			{ PL=0, delay=221, SE=116, time=211 },//「アナタ、死徒というより神学者じゃない？」
			{ PL=1, PAT=900, delay=329, SE=652, time=319 },// 昔の話だ。今はこの通りアウトローでね！
		],
	},
	
	// セイバー
	{
		Enemy=[Def_ChrNo_Chr012], WaitPAT = [920,926],
		duet_timeline =
		[
			{ PL=1, PAT=927, delay=190, SE=103, time=180 },// 「食ログではこのあたりに……は！？」
			{ PL=0, delay=220, SE=117, time=210 },//「あ、その店知ってる〜！　終わったら行きましょう！」
		],
	},
	
	// シエル
	{
		Enemy=[Def_ChrNo_Chr011], WaitPAT = [928,902],
		duet_timeline =
		[
			{ PL=1, delay=346, SE=792, time=336 },// ふふふ。どなたか存じませんが、ここで倒しておきますね。
			{ PL=0, delay=190, SE=120, time=180 },//あ。志貴から私のコト聞いてる感じね！
		],
	},
];


// 完全武装シエル
CommonStandbyParams[Def_ChrNo_Chr016] =
[
	{ ExcludeEnemy=[0,1,2,3,4,7,8,10,11,13,14,19], WaitPAT = 919, timeline = [ { PAT=920, SE=100, time=279, delay=210 }, { PAT=921, delay=70 } ] }, // 「名乗らずとも結構。聞くべきは、許しを請う声だけですので。」
	{ ExcludeEnemy=[5,9,14], WaitPAT = 919, timeline = [ { PAT=920, SE=101, time=154, delay=90 }, { PAT=921, delay=70 } ] }, // 「弁明は不要です。構えなさい。」
	{ ExcludeEnemy=[5,8,9,14], WaitPAT = 919, timeline = [ { PAT=920, SE=102, time=290, delay=220 }, { PAT=921, delay=70 } ] }, // 「対象を無力化。その後、命があれば審問に移行します。」
	{ WaitPAT = 928, timeline = [ { SE=103, time=146, delay=156 } ] }, // 「重火器ですが、何か？」
	{ WaitPAT = 919, timeline = [ { PAT=920, SE=104, time=279, delay=210 }, { PAT=921, delay=70 } ] }, // 「第一、第二、第三、セーフティロック、解除。」
	{ WaitPAT = 919, timeline = [ { PAT=920, SE=105, time=267, delay=200 }, { PAT=921, delay=70 } ] }, // 「面白い事はありません。ただ、制圧するのみです。」

	// 対吸血鬼
	{ Enemy=[5,9,14], WaitPAT = 919, timeline = [ { PAT=920, SE=106, time=97, delay=60 }, { PAT=921, delay=70 } ] }, // 「討伐を開始します。」
	{ Enemy=[5,9,14], WaitPAT = 919, timeline = [ { PAT=920, SE=107, time=189, delay=130 }, { PAT=921, delay=70 } ] }, // 「不浄なるものに、相応しい末路を」
	{ Enemy=[5,9,14], WaitPAT = 919, timeline = [ { PAT=920, SE=108, time=82, delay=60 }, { PAT=921, delay=70 } ] }, // 「討伐を開始します。」

	//対死徒ノエル
	{
		Enemy=[Def_ChrNo_Chr014], WaitPAT = [924,930],
		duet_timeline =
		[
			{ PL=1, delay=268, SE=117, time=258 },//「ほら見て！　オマエのせいでみーんな死んじゃった！」
			{ PL=0, delay=265, SE=109, time=255 },//「……（いいえ。）それは、アナタの弱さによるものです」
		],
	},
	{
		Enemy=[Def_ChrNo_Chr014], WaitPAT = [924,930],
		duet_timeline =
		[
			{ PL=0, delay=194, SE=110, time=184 },//「死徒に身を堕としたのですね、ノエル。」
			{ PL=1, delay=279, SE=118, time=269 },// 「ハッ！　それがアンタの本音でしょ、偽善者！」
		],
	},
	
	//対青子
	{
		Enemy=[Def_ChrNo_Chr015], WaitPAT = [924,920],
		duet_timeline =
		[
			{ PL=0, delay=261, SE=111, time=251 },//「第五の魔法使い……こんなところで遭遇するなんて……」
			{ PL=1, delay=216, SE=123, time=206 },// 「えー。アナタも大概だと思うけど？」
		],
	},	
	
	//対マーリオゥ
	{
		Enemy=[Def_ChrNo_Chr017], WaitPAT = [924,[920,919]],
		duet_timeline =
		[
			{ PL=0, delay=230, SE=112, time=220 },//「司祭代行であれ、障害なら排除します」
			{ PL=1, TAG=1, PAT=920, delay=0 },
			{ PL=1, TAG=0, delay=217, SE=112, time=267 },// 「処世術もクソもねぇな。これだから天才は。」
			{ PL=1, TAG=1, PAT=921, delay=60 },
		],
	},
	{
		Enemy=[Def_ChrNo_Chr017], WaitPAT = [923,[930,919]],
		duet_timeline =
		[
			{ PL=1, TAG=1, PAT=930, delay=0, },// 落ちてきて立ちまで
			{ PL=1, TAG=0, delay=90, SE=113, time=213 },// 「都市制圧戦の許可なんざ出してねえよなあ！？」
			{ PL=1, TAG=0, PAT=921, delay=125, },
			{ PL=0, delay=288, SE=113, time=278 },//「独自の判断です。止めるのなら、力ずくでどうぞ。」
		],
	},	
	
	//対ロア
	{
		Enemy=[Def_ChrNo_Chr005], WaitPAT = [926,900],
		duet_timeline =
		[
			{ PL=1, delay=230, SE=653, time=220 },// 「おいおいマジかよ。そりゃあ本物か？」
			{ PL=0, delay=343, SE=114, time=323 },//「もちろん。ここが貴方の終着です、ミハイル・ロア・バルダムヨォン。」
		],
	},	
	
	//遠野志貴
	{
		Enemy=[Def_ChrNo_Chr003], WaitPAT = [924,920],
		duet_timeline =
		[
			{ PL=1, delay=242, SE=675, time=232 },// 「実戦訓練、なんですね」
			{ PL=0, delay=176, SE=750, time=166 },//「ええ。全力で抵抗するように」
		],
		checkfunc = function()
		{
			if( Battle_Std.GetEnemyBossFlag()==8 ) return 0;//七夜風志貴なので掛け合いなし
			return 1;
		}
	},
	{
		Enemy=[Def_ChrNo_Chr003], WaitPAT = [924,900],
		duet_timeline =
		[
			{ PL=0, delay=294, SE=751, time=284 },//「私をアル……いえ、吸血鬼と思ってかかってきなさい」
			{ PL=1, PAT=906, delay=169, SE=676, time=159 },// 「（真面目なのかな、怒ってるのかな……？）」
		],
		checkfunc = function()
		{
			if( Battle_Std.GetEnemyBossFlag()==8 ) return 0;//七夜風志貴なので掛け合いなし
			return 1;
		}
	},
	
	//アルクェイド
	{
		Enemy=[Def_ChrNo_Chr000], WaitPAT = [923,905],
		duet_timeline =
		[
			{ PL=0, delay=227, SE=700, time=217 },//「理性は……かろうじてあるようですね」
			{ PL=1, PAT=906, delay=251, SE=683, time=241 },//「んんー？　街中でそれは反則じゃないのー？。」
		],
	},	

	//暴走アルクェイド
	{
		Enemy=[Def_ChrNo_Chr010], WaitPAT = [923,905],
		duet_timeline =
		[
			{ PL=0, delay=251, SE=701, time=241 },//「吸血衝動に呑み込まれましたか。無様な。」
			{ PL=1, PAT=906, delay=330, SE=683, time=320 },//「ええ。人間の血なんて、ぜんっぜん飲みたくないけどね？」
		],
	},
	{
		Enemy=[Def_ChrNo_Chr010], WaitPAT = [923,905],
		duet_timeline =
		[
			{ PL=1, PAT=906, delay=390, SE=684, time=379 },//ふふ。お気に入りのオモチャ、みーつけた。
			{ PL=0, delay=254, SE=702, time=244 },//「なるほど。オモチャに殺されるのが好きなんですね。」
		],
	},	
	//対ノエル
	{
		Enemy=[Def_ChrNo_Chr008], WaitPAT = [926,[902,901]],
		duet_timeline =
		[
			{ PL=1, delay=268, SE=693, time=258 },//「制圧装備ぃ！？ わ、私なにもしてないわよ！？」
			{ PL=0, delay=265, SE=791, time=255 },//「気を引き締めなさい。ただの、実弾を用いた模擬戦です。」
		],
	},	
]

// マーリオゥ
CommonStandbyParams[Def_ChrNo_Chr017] =
[
	{
		WaitPAT = [930,919],
		OffsetPosition = [ {x=-25,y=0}, {x=25,y=0} ], // 開始座標オフセット
		timeline =
		[
			{ TAG=1, PAT=920, delay=0 },
			{ TAG=0, SE =100, delay=60, time=163 },// 「オレのシマで勝手はさせねえよ」	
			{ TAG=1, PAT=921, delay=0 },
			{ TAG=0, PAT=931, delay=115 },
		]
	},
	{
		WaitPAT = [930,919],
		OffsetPosition = [ {x=-25,y=0}, {x=25,y=0} ], // 開始座標オフセット
		timeline =
		[
			{ TAG=1, PAT=920, delay=0 },
			{ TAG=0, SE =101, delay=75, time=178 },// 「懺悔がわりだ。一曲聴いていけ。」	
			{ TAG=1, PAT=921, delay=0 },
			{ TAG=0, PAT=931, delay=115 },
		]
	},
	{
		WaitPAT = [922,919],
		OffsetPosition = [ {x=-25,y=0}, {x=25,y=0} ], // 開始座標オフセット
		timeline =
		[
			{ TAG=1, PAT=922, delay=0 },//120F固定
			{ TAG=0, SE =102, delay=178, time=192 },// 「指揮者が前に出るほど人手不足でね。」	
			{ TAG=0, PAT=923, delay=24 },
		]
	},
	{
		WaitPAT = [930,919],
		OffsetPosition = [ {x=-25,y=0}, {x=25,y=0} ], // 開始座標オフセット
		timeline =
		[
			{ TAG=1, PAT=920, delay=0 },
			{ TAG=0, SE =103, delay=30, time=134 },// 「改宗ならいつでもどうぞ。」	
			{ TAG=1, PAT=921, delay=0 },
			{ TAG=0, PAT=931, delay=115 },
		]
	},	
	{
		WaitPAT = [930,919],
		OffsetPosition = [ {x=-25,y=0}, {x=25,y=0} ], // 開始座標オフセット
		timeline =
		[
			{ TAG=1, PAT=920, delay=0 },
			{ TAG=0, SE =104, delay=120, time=224 },// 「オレは忙しい。用件だけ語ってもらう。」	
			{ TAG=1, PAT=921, delay=0 },
			{ TAG=0, PAT=931, delay=115 },
		]
	},	
	{
		ExcludeEnemy=[13,17], // 一般人っぽくて子供っぽい見た目のキャラは除外（有間都古、マーリオゥ同キャラ。死徒ノエルはままにした）
		WaitPAT = [924,919],
		OffsetPosition = [ {x=-25,y=0}, {x=25,y=0} ], // 開始座標オフセット
		timeline =
		[
			{ TAG=1, PAT=922, delay=0 },//120F固定
			{ TAG=0, SE =105, delay=170, time=184 },//「子ども相手だぜ？　加減しろよ。」	
			{ TAG=0, PAT=925, delay=24 },
		]
	},	
	
	//死徒ノエル
	{
		Enemy=[Def_ChrNo_Chr014], WaitPAT = [[927,919],930],
		duet_timeline =
		[
			{ PL=1, delay=250, SE=119, time=239 },//「逃げられると思わないでね、クソガキ。」
			{ PL=0, TAG=1, PAT=920, delay=0 },
			{ PL=0, TAG=0, delay=246, SE=106, time=236 },// 「趣味も悪けりゃ口も悪いのかよ。救えねえ。」
		],
	},
	{
		Enemy=[Def_ChrNo_Chr014], WaitPAT = [[927,919],930],
		duet_timeline =
		[
			{ PL=0, TAG=1, PAT=920, delay=0 },
			{ PL=0, TAG=0, delay=257, SE=107, time=247 },// 「純度100パー無能だったよな？　どうなってやがる？」
			{ PL=1, delay=301, SE=109, time=291 },//「ハッ！　殺される時まで憎たらしいガキね！」
		],
	},

	//ノエル
	{
		Enemy=[Def_ChrNo_Chr008], WaitPAT = [[930,919],920],
		duet_timeline =
		[
			{ PL=1, PAT=920, delay=237, SE=691, time=226 },//「よーし！　いいとこ見せるフリしてフルボッコね！」
			{ PL=0, TAG=1, PAT=920, delay=0 },
			{ PL=0, TAG=0, delay=100, SE=108, time=206 },// 「おう。査定してやるよ、かかってきな。」
			{ PL=0, TAG=1, PAT=921, delay=0 },
			{ PL=0, TAG=0, PAT=931, delay=115 },
		],
	},
	{
		Enemy=[Def_ChrNo_Chr008], WaitPAT = [[930,919],920],
		duet_timeline =
		[
			{ PL=0, TAG=1, PAT=920, delay=0 },
			{ PL=0, TAG=0, delay=170, SE=109, time=299 },// 「再訓練だ。じきじきに面倒見てやるよ、ブタ。」
			{ PL=0, TAG=1, PAT=921, delay=0 },
			{ PL=0, TAG=0, PAT=921, delay=137 },
			{ PL=1, PAT=920, delay=203, SE=692, time=233 },//「こ、光栄だなぁ、あはははは！　……チッ。」
			{ PL=1, PAT=921, delay=40 },
		],
	},	
	
	//青子
	{
		Enemy=[Def_ChrNo_Chr015], WaitPAT = [[934,919],928],
		duet_timeline =
		[
			{ PL=1, delay=190, SE=122, time=180 },//「顔に似合わず古風な武器を使うのね。」
			{ PL=0, TAG=1, PAT=920, delay=0 },
			{ PL=0, TAG=0, delay=168, SE=110, time=158 },// 「レトロ趣味なんだよ。ほっとけ。」
		],
	},	
	{
		Enemy=[Def_ChrNo_Chr015], WaitPAT = [[927,919],920],
		duet_timeline =
		[
			{ PL=0, TAG=1, PAT=920, delay=0 },
			{ PL=0, TAG=0, delay=198, SE=111, time=188 },// 「魔法使いのクセに正義の味方かよ。」
			{ PL=1, delay=174, SE=124, time=164 },//「ひとりくらい、そういうのがいてもいいでしょ？」
		],
	},	
	
	//シエル
	{
		Enemy=[Def_ChrNo_Chr011], WaitPAT = [[930,919],922],
		duet_timeline =
		[
			{ PL=1, delay=197, SE=793, time=187 },//「またお忍びですか、司祭代行？」
			{ PL=0, TAG=1, PAT=920, delay=0 },
			{ PL=0, TAG=0, delay=260, SE=114, time=250 },// 「おう。下がそろって使えねえから仕方なくな。」
		],
	},	
	{
		Enemy=[Def_ChrNo_Chr011], WaitPAT = [[930,919],920],
		duet_timeline =
		[
			{ PL=0, TAG=1, PAT=920, delay=0 },
			{ PL=0, TAG=0, delay=173, SE=115, time=289 },// 「さあて。オレに負けるようじゃ埋葬機関失格だぜ？」
			{ PL=0, TAG=1, PAT=921, delay=0 },
			{ PL=0, TAG=0, PAT=921, delay=127 },
			{ PL=1, delay=120, SE=794, time=239 },//「ご安心を。あくまで代行者としてお相手します。」
			{ PL=1, PAT=921, delay=130 },
		],
	},	
	
	//暴走アルク
	{
		Enemy=[Def_ChrNo_Chr010], WaitPAT = [[930,919],906],
		duet_timeline =
		[
			{ PL=1, delay=266, SE=685, time=256 },//「視界に入ったら容赦はしない、と言ったわよね？」
			{ PL=0, TAG=1, PAT=920, delay=0 },
			{ PL=0, TAG=0, delay=234, SE=116, time=224 },// 「ああ。だから、テメェからやってきたんだよ。」
		],
	},	
	{
		Enemy=[Def_ChrNo_Chr010], WaitPAT = [[927,919],905],
		duet_timeline =
		[
			{ PL=0, TAG=1, PAT=920, delay=0 },
			{ PL=0, TAG=0, delay=283, SE=117, time=273 },// 「簡単に堕ちやがって。失恋がそんなにショックか？」
			{ PL=1, delay=80, SE=686, time=281 },//ええ。首から堕ちるような痛みだったわ。
			{ PL=1, PAT=906, delay=215 },
		],
	},
	{
		Enemy=[Def_ChrNo_Chr010], WaitPAT = [[927,919],905],
		duet_timeline =
		[
			{ PL=0, TAG=1, PAT=920, delay=0 },
			{ PL=0, TAG=0, delay=171, SE=118, time=161 },// 「……おまえ、そんなガワだったか？」
			{ PL=1, PAT=914, delay=260, SE=687, time=250 },//指導者として少しは血を流しなさい、ベスティーノ
		],
	},
	
	//遠野志貴
	{
		Enemy=[Def_ChrNo_Chr003], WaitPAT = [[930,919],923],
		duet_timeline =
		[
			{ PL=0, TAG=1, PAT=920, delay=0 },
			{ PL=0, TAG=0, delay=200, SE=119, time=321 },// 「善良そうなツラしやがって。凶器が見えてるぜ、ガキ。」
			{ PL=0, TAG=1, PAT=921, delay=0 },
			{ PL=0, TAG=0, PAT=921, delay=127 },
			{ PL=1, delay=170, SE=677, time=203 },//「そっちもな。物騒なお守りがたくさんだ。」
			{ PL=1, PAT=924, delay=40 },
		],
		checkfunc = function()
		{
			if( Battle_Std.GetEnemyBossFlag()==8 ) return 0;//七夜風志貴なので掛け合いなし
			return 1;
		}
	},	
	
	//ロア
	{
		Enemy=[Def_ChrNo_Chr005], WaitPAT = [[930,919],900],
		duet_timeline =
		[
			{ PL=0, TAG=1, PAT=920, delay=0 },
			{ PL=0, TAG=0, delay=90, SE=121, time=206 },// 「最後の夜だ。リクエストはあるか？」
			{ PL=0, TAG=1, PAT=921, delay=0 },
			{ PL=0, TAG=0, PAT=921, delay=127 },
			{ PL=1, delay=275, SE=654, time=265 },//では一曲、タランテラを聞かせてもらおうか。
		],
	},
	{
		Enemy=[Def_ChrNo_Chr005], WaitPAT = [[930,919],900],
		duet_timeline =
		[
			{ PL=0, TAG=1, PAT=920, delay=0 },
			{ PL=0, TAG=0, delay=40, SE=122, time=161 },// 「ようやく会えたな、バルダムヨォン 」
			{ PL=0, TAG=1, PAT=921, delay=0 },
			{ PL=0, TAG=0, PAT=921, delay=127 },
			{ PL=1, delay=328, SE=655, time=318 },//どうやらそちらはそちらで愉快な事態(こと)になっているな？
		],
	},	
	
	//アルク
	{
		Enemy=[Def_ChrNo_Chr000], WaitPAT = [[927,919],903],
		duet_timeline =
		[
			{ PL=0, TAG=1, PAT=920, delay=0 },
			{ PL=0, TAG=0, delay=283, SE=120, time=273 },// 「待てよこのアバズレ。デートとかなに考えてやがる？」
			{ PL=1, PAT=904, delay=230, SE=684, time=220 },//「なにって、デートのことしか考えてないんですけど！」
		],
	},	
]

// ネコアルク
CommonStandbyParams[Def_ChrNo_Chr019] =
[
	{ WaitPAT = 919, timeline = [ { PAT=920, SE=100, time=130, delay=130 }, ] }, // 「「じゃんじゃじゃ〜ん」」
	{ WaitPAT = 922, timeline = [ { PAT=922, SE=101, time=191, delay=191 }, ] }, // 「にゃっにゃにゃにゃにゃっにゃっにゃっ……」
	{ WaitPAT = 924, timeline = [ { PAT=924, SE=102, time=178, delay=178 }, ] }, // 「気をつけな、飛び出すぜ？」
	{ WaitPAT = 921, timeline = [ { SE=103, time=333, delay=333 } ] }, // 「おいおい、サインは断って……あ、違う？　バトル？　そっかー。」
	{ WaitPAT = 922, timeline = [ { PAT=922, SE=104, time=165, delay=165 },] }, // 「ネコ、地獄にまっしぐら！」
	{ WaitPAT = 919, timeline = [ { PAT=920, SE=105, time=153, delay=153 }, ] }, // 「人類ネコ、顕現！」

	//対都古
	{
		Enemy=[Def_ChrNo_Chr013], WaitPAT = [921,919],
		duet_timeline =
		[
			{ PL=0, delay=278, SE=110, time=268 },//「理解しろチャイナ、アタシは心を入れ替えたンだ」
			{ PL=1, PAT=919, delay=161, SE=750, time=151 },//「より悪い方に入れ替えてるじゃん！」
		],
	},
	//対遠野志貴
	{
		Enemy=[Def_ChrNo_Chr003], WaitPAT = [921,[920,921]],
		duet_timeline =
		[
			{ PL=0, delay=280, SE=111, time=274 },//「ニャニャニャ。お灸を据えてやるぜギルティボーイ？」
			{ PL=1, delay=187, SE=690, time=177 },//「クライム同然の顔に言われたくないです」
		],
		checkfunc = function()
		{
			if( Battle_Std.GetEnemyBossFlag()==8 ) return 0;//七夜風志貴なので掛け合いなし
			local color = BMvTbl.GetSelectColor();
			if( color==32 || color==33 ) return 0;//ネコアキハなら再生しない
			return 1;
		}
	},
	{
		//ネコアキハ用
		Enemy=[Def_ChrNo_Chr003], WaitPAT = [921,[920,921]],
		duet_timeline =
		[
			{ PL=0, delay=340, SE=111, time=334 },//「ニャニャニャ。お灸を据えてやるぜギルティボーイ？」
			{ PL=1, delay=187, SE=690, time=177 },//「クライム同然の顔に言われたくないです」
		],
		checkfunc = function()
		{
			if( Battle_Std.GetEnemyBossFlag()==8 ) return 0;//七夜風志貴なので掛け合いなし
			local color = BMvTbl.GetSelectColor();
			if( !(color==32 || color==33) ) return 0;//ネコアキハ以外なら再生しない　※尺が違いすぎるので個別設定
			return 1;
		}
	},
	//対シエル
	{
		Enemy=[Def_ChrNo_Chr011], WaitPAT = [921,922],
		duet_timeline =
		[
			{ PL=0, delay=261, SE=112, time=251 },//「シエル、なんか若くない？　また年齢詐称か？」
			{ PL=1, delay=152, SE=800, time=140 },//「い、言いがかりはやめなさい！」
		],
	},
	//対アルクェイド
	{
		Enemy=[Def_ChrNo_Chr000], WaitPAT = [922,920],
		duet_timeline =
		[
			{ PL=0, delay=275, SE=113, time=271 },//「美しい……鏡を見ているようだ、ぜ？」
			{ PL=1, PAT=921, delay=215, SE=690, time=205 },//「オッケー、鏡ごとブチ割っちゃう！」
		],
		checkfunc = function()
		{
			local color = BMvTbl.GetSelectColor();
			if( color==30 || color==31 ) return 0;//ネコシエルなら再生しない
			return 1;
		}
	},
	{
		//ネコシエル用
		Enemy=[Def_ChrNo_Chr000], WaitPAT = [922,920],
		duet_timeline =
		[
			{ PL=0, delay=365, SE=113, time=355 },//「美しい……鏡を見ているようだ、ぜ？」
			{ PL=1, PAT=921, delay=215, SE=690, time=205 },//「オッケー、鏡ごとブチ割っちゃう！」
		],
		checkfunc = function()
		{
			local color = BMvTbl.GetSelectColor();
			if( !(color==30 || color==31) ) return 0;//ネコシエル以外なら再生しない　※尺が違いすぎるので個別設定
			return 1;
		}
	},
	//対遠野秋葉
	{
		Enemy=[Def_ChrNo_Chr002], WaitPAT = [922,920],
		duet_timeline =
		[
			{ PL=0, delay=330, SE=114, time=330 },//「素直になれよお嬢。一緒に眼鏡わからせようぜ？」
			{ PL=1, delay=268, SE=650, time=258 },//「そのつもりですが、ネコの手を借りるまでもありません」
		],
		checkfunc = function()
		{
			local color = BMvTbl.GetSelectColor();
			if( color==36 || color==37 ) return 0;//ネココハクなら再生しない
			return 1;
		}
	},
	{
		//ネココハク用
		Enemy=[Def_ChrNo_Chr002], WaitPAT = [922,920],
		duet_timeline =
		[
			{ PL=0, delay=267, SE=114, time=257 },//「素直になれよお嬢。一緒に眼鏡わからせようぜ？」
			{ PL=1, delay=268, SE=650, time=258 },//「そのつもりですが、ネコの手を借りるまでもありません」
		],
		checkfunc = function()
		{
			local color = BMvTbl.GetSelectColor();
			if( !(color==36 || color==37) ) return 0;//ネココハク以外なら再生しない　※尺が違いすぎるので個別設定
			return 1;
		}
	},
	// 対マシュ
	{
		Enemy=[Def_ChrNo_Chr020], WaitPAT = [925,924],
		duet_timeline =
		[
			{ PL=0, delay=158, SE=115, time=148 },//「マシュ君の優しさを信じて！」
			{ PL=1, PAT=925, delay=210, SE=112, time=200 },//「はい！　粉骨砕身、お任せください！」
		],
	},
	{
		Enemy=[Def_ChrNo_Chr020], WaitPAT = [925,924],
		duet_timeline =
		[
			{ PL=1, PAT=925, delay=175, SE=113, time=165 },//「相手がネコアルクさんなら、フルパワーで！」
			{ PL=0, PAT=926, delay=91, SE=116, time=91 },//「地獄かよ」
		],
	},
]

// マシュ
CommonStandbyParams[Def_ChrNo_Chr020] =
[
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=100, time=220, delay=150 }, { PAT=921, delay=80 } ] }, // 「シバによる危険予測……？　戦闘になるのですね。」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=101, time=185, delay=115 }, { PAT=921, delay=80 } ] }, // 「武装完了。シールダー、出ます！」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=102, time=164, delay=94 }, { PAT=921, delay=80 } ] }, // 「マシュ・キリエライト、最善を尽くします！」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=103, time=191, delay=121 }, { PAT=921, delay=80 } ] }, // 「敵性反応、確認。鎮圧します。」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=104, time=127, delay=57 }, { PAT=921, delay=80 } ] }, // 「うまく収められればいいのですが……」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=105, time=152, delay=82 }, { PAT=921, delay=80 } ] }, // 「落ち着いて……普段通りに……」

	// 対吸血鬼
	{ Enemy=[5,9,14], WaitPAT = 920, timeline = [ { PAT=920, SE=110, time=174, delay=104 }, { PAT=921, delay=80 } ] }, // 「この盾にかけて、撤退はできません！」
	{ Enemy=[5,9,14], WaitPAT = 920, timeline = [ { PAT=920, SE=111, time=350, delay=280 }, { PAT=921, delay=80 } ] }, // 「カテゴリ：人類の脅威……戦う他、ありません！」
	
	// 対武装シエル
	{
		Enemy=[Def_ChrNo_Chr016], WaitPAT = [928,931]
		duet_timeline =
		[
			{ PL=0, delay=173, SE=116, time=163 },//「戦闘後、サインをいただないでしょうかっ！？」
			{ PL=1, PAT=932, delay=190, SE=792, time=180 },//「では、こちらも記念写真など一枚」
		],
	},
	// 対翡翠
	{
		Enemy=[Def_ChrNo_Chr001], WaitPAT = [927,920]
		duet_timeline =
		[
			{ PL=0, delay=308, SE=117, time=298 },//「ほ、本物のメイドさんです……！　ご教授のほど、お願いしますっ！」
			{ PL=1, PAT=928, delay=208, SE=830, time=198 },//「かしこまりました。清掃のイロハでよろしければ」
		],
	},
]

// 牛若丸
CommonStandbyParams[Def_ChrNo_Chr021] =
[
	{ ExcludeEnemy=[12,19,20,21,22], WaitPAT = 922, timeline = [ { PAT=922, SE=100, time=127, delay=10 }, { PAT=923, delay=127 } ] }, // 「牛若丸と覚えてもらおう」　※知ってそうな相手は除外
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=101, time=167, delay=30 }, { PAT=921, delay=147 } ] }, // 「では、遊んで進ぜよう」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=102, time=234, delay=90 }, { PAT=921, delay=154 } ] }, // 「時代は弁えている。首はとらんさ」
	{ ExcludeEnemy=[12,19,20,21,22], WaitPAT = 920, timeline = [ { PAT=920, SE=104, time=177, delay=60 }, { PAT=921, delay=117 } ] }, // 「鞍馬の天狗、ご存じかな？」　※知ってそうな相手は除外
	{ WaitPAT = 922, timeline = [ { PAT=922, SE=105, time=151, delay=10 }, { PAT=923, delay=167 } ] }, // 「合戦でなければ、ノビノビと。」

	// タッグは一騎打ちじゃなくない？
	{ ExcludeEnemy = [7,17], WaitPAT = 922, timeline = [ { PAT=922, SE=103, time=167, delay=30 }, { PAT=923, delay=147 } ] }, // 「一騎打ちとは、てっとり早い！」
	
	// 対吸血鬼
	{ Enemy=[5,9,14], WaitPAT = 920, timeline = [ { PAT=920, SE=110, time=222, delay=70 }, { PAT=921, delay=162 } ] }, // 「ほう。鬼にも種類があるのだな？」 
	{ Enemy=[5,9,14], WaitPAT = 920, timeline = [ { PAT=920, SE=111, time=188, delay=60 }, { PAT=921, delay=138 } ] }, // 「貴様らであれば、御首(みしるし)はいただこう」

	// 対秋葉
	{
		Enemy=[Def_ChrNo_Chr002], WaitPAT = [927,920]
		duet_timeline =
		[
			{ PL=0, PAT=924, delay=150, SE=113, time=291 },//「秋葉殿！　現世(げんせ)漫遊(まんゆう)の恩義、お返しいたす！」
			{ PL=0, PAT=925, delay=141 },
			{ PL=0, PAT=926, delay=20 },
			{ PL=1, PAT=932, delay=246, SE=651, time=236 },//（秋葉「そこは一宿一飯の恩、ぐらいにしておきなさい」）
		],
	},
	// 対遠野志貴
	{
		Enemy=[Def_ChrNo_Chr003], WaitPAT = [920,920]
		duet_timeline =
		[
			{ PL=0, PAT=920, delay=180, SE=112, time=319 },//「この時代に浄眼(じょうがん)とは。どこの御山のご子息かな？」
			{ PL=0, PAT=921, delay=159 },
			{ PL=1, PAT=933, delay=190, SE=691, time=180 },//（志貴「そこの丘の上の洋館の長男ですけど……」）
		],
	},
	// 対暴走アルクェイド
	{
		Enemy=[Def_ChrNo_Chr010], WaitPAT = [922,920]
		duet_timeline =
		[
			{ PL=0, PAT=922, delay=180, SE=114, time=329 },//「相手にとって不足なし。魔王(まおう)尊(そん)、退治してご覧にいれる！」 
			{ PL=0, PAT=923, delay=169 },
			{ PL=1, PAT=914, delay=357, SE=690, time=347 },//（暴走アルクェイド「へえ、天狗って言うんだ。犬なら羽虫より楽しめる？」）
		],
	},
	// 対マシュ
	{
		Enemy=[Def_ChrNo_Chr020], WaitPAT = [927,931]
		duet_timeline =
		[
			{ PL=1, delay=204, SE=114, time=194 },//（マシュ「牛若丸さん、一手、お願いします！」）
			{ PL=0, PAT=925, delay=141, SE=117, time=161 },//「よろこんで、お相手つかまつる」
			{ PL=0, PAT=926, delay=30 },
			
		],
	},
	// 対巌窟王
	{
		Enemy=[Def_ChrNo_Chr022], WaitPAT = [920,920]
		duet_timeline =
		[
			{ PL=0, PAT=920, delay=265, SE=115, time=255 },//「サーヴァントか？　見覚えのない顔だが…」
			{ PL=1, PAT=920, delay=308, SE=112, time=298 },//（巌窟王「文字通りエキストラというヤツだ。気にするな」）
		],
	},
	{
		Enemy=[Def_ChrNo_Chr022], WaitPAT = [920,920]
		duet_timeline =
		[
			{ PL=1, PAT=920, delay=235, SE=113, time=225 },//（巌窟王「……今回は……自重しているな」） 
			{ PL=0, PAT=920, delay=210, SE=116, time=200 },//「？　なんの話をしているのです？」
		],
	},
]

// 巌窟王
CommonStandbyParams[Def_ChrNo_Chr022] =
[
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=100, time=226, delay=66 }, { PAT=921, delay=170 } ] }, // 「貴様は、我が姿に何を見る！」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=101, time=196, delay=86 }, { PAT=921, delay=120 } ] }, // 「世に地獄の種は尽きぬらしい！」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=102, time=301, delay=171 }, { PAT=921, delay=140 } ] }, // 「我が名は復讐者、巌窟王エドモン・ダンテス
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=103, time=186, delay=186 } ] }, // 「捜し物は、貴様ではない……」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=104, time=282, delay=122 }, { PAT=921, delay=170 } ] }, // 「話し合いより、こちらの方が早い人種か」
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=105, time=208, delay=78 }, { PAT=921, delay=140 } ] }, // 「ははは、ははははははははははは！」

	// 対吸血鬼
	{ Enemy=[5,9,14], WaitPAT = 920, timeline = [ { PAT=920, SE=110, time=182, delay=82 }, { PAT=921, delay=110 } ] }, // 「吸血鬼か！　来るがいい！」
	{ Enemy=[5,9,14], WaitPAT = 920, timeline = [ { PAT=920, SE=111, time=217, delay=107 }, { PAT=921, delay=120 } ] }, // 「同類だとも！　オレも、貴様も！」
	
	
	// 対遠野志貴
	{
		Enemy=[Def_ChrNo_Chr003], WaitPAT = [923,920]
		duet_timeline =
		[
			{ PL=0, delay=394, SE=114, time=384 },// 「忘れているのか。貴様の深奥にある、その怒りを」
			{ PL=1, delay=184, SE=692, time=174 },// （志貴「覚えがないのなら、そういうコトだよ」）
		]
	},

	// 対ロア
	{
		Enemy=[Def_ChrNo_Chr005], WaitPAT = [923,920]
		duet_timeline =
		[
			{ PL=0, delay=326, SE=115, time=316 },// 「どのような世界であろうと、蛇は蛇という事か」 
			{ PL=1, delay=248, SE=660, time=238 },// （ロア「おや。見知らぬ顔ですが、私と面識が？」）
		]
	},
	{
		Enemy=[Def_ChrNo_Chr005], WaitPAT = [923,920]
		duet_timeline =
		[
			{ PL=1, delay=266, SE=661, time=256 },// （ロア「ひでぇ有様だ。英霊というより亡霊だな？」） 
			{ PL=0, delay=274, SE=116, time=264 },// 「貴様もな。神学者の面影もない」
		]
	},
	
	// 対ネコアルク
	{
		Enemy=[Def_ChrNo_Chr019], WaitPAT = [923,925]
		duet_timeline =
		[
			{ PL=0, delay=385, SE=117, time=375 },// 「馬鹿な……！　恩讐反応が……皆無……だと！？」
			{ PL=1, PAT=928, delay=200, SE=117, time=190 },// （ネコアルク「ニャんだよ、その恩讐反応って」）　※ざっくり200FあればOK
		]
	},

	// 対マシュ
	{
		Enemy=[Def_ChrNo_Chr020], WaitPAT = [923,940]
		duet_timeline =
		[
			{ PL=1, delay=205, SE=115, time=195 },//マシュ「この方もサーヴァント……なのでしょうか？」
			{ PL=0, delay=90, SE=118, time=71 },//巌窟王「………さて」
		]
	},
]

CommonStandbyParams[Def_ChrNo_Chr023] =
[
	{ WaitPAT = 900, timeline = [ { PAT = 50, delay=112, SE=100, time=112 } ]  }, // 「出ろ！　インスレーター！」
	{ WaitPAT = 902, timeline = [ { PAT = 904, delay=186, SE=101, time=186 } ] }, // 「邪魔をするなら…片付けるまでだ！」
	{ WaitPAT = 900, timeline = [ { PAT = 50, delay=124, SE=102, time=124 } ]  }, // 「……この力で終わらせてやる！」
	{ WaitPAT = 902, timeline = [ { PAT = 903, delay=146, SE=103, time=146 } ] }, // 「オレの力……見せてやる！」
]

CommonStandbyParams[Def_ChrNo_Chr024] =
[
	//----七夜風志貴の場合----
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=700, time=197, delay= 127 }, { PAT=921, delay=80 } ] },
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=701, time=180, delay= 110 }, { PAT=921, delay=80 } ] },
	{ WaitPAT = 920, timeline = [ { PAT=920, SE=702, time=180, delay= 110 }, { PAT=921, delay=80 } ] },
]



//CommonStandbyParamsのエラーチェック処理
//timeよりも極端にdelayが少ないと字幕がかぶってしまうのでそれを調べる
if( 0 && Def_Dbg_LocalDebugMode ){
	local limit_sa = 0;//10;
	foreach( slot, val in CommonStandbyParams )
	{
		//val = 配列?
		if( typeof val == "array" )
		{
			_dpn("キャラ:"+slot);
			for( local i=0; i<val.len(); i++ )
			{
				if( "timeline" in val[i] )
				{
					local tl = val[i].timeline;
					_dpn("TL["+i+"]");
					if( typeof tl != "array" ) break;
					
					local time = [0,0]; // 音声再生時間
					local delay = [0,0]; // アニメディレイ時間
					for( local j=0; j<tl.len(); j++ )
					{
						local id = ( "TAG" in tl[j] )? tl[j].TAG : 0;
						if( "delay" in tl[j] ) delay[id] += tl[j].delay;
						if( "time" in tl[j] ) time[id] += tl[j].time;
					}
					for( local pl=0; pl<2; pl++ )
					{
						local sa = time[pl]+limit_sa - delay[pl];
						if( time[pl] > 0 && sa > 0 )
						{
							_dpn(" ★"+pl+1+"P時間:"+delay[pl]+" -> "+time[pl]+" 時間不足:"+sa );
						}
					}
				}
				if( "duet_timeline" in val[i] )
				{
					local tl = val[i].duet_timeline;
					_dpn("DTL["+i+"]");
					if( typeof tl != "array" ) break;
					
					local time = [0,0]; // 音声再生時間
					local delay = [0,0]; // アニメディレイ時間
					for( local j=0; j<tl.len(); j++ )
					{
						local id = ( "PL" in tl[j] )? tl[j].PL : 0;
						if( "delay" in tl[j] ) delay[id] += tl[j].delay;
						if( "time" in tl[j] ) time[id] += tl[j].time;
					}
					for( local pl=0; pl<2; pl++ )
					{
						local sa = time[pl]+limit_sa - delay[pl];
						if( time[pl] > 0 && sa > 0 )
						{
							_dpn(" ★"+pl+1+"P時間:"+delay[pl]+" -> "+time[pl]+" 時間不足:"+sa );
						}
					}				
				}
			}
			_dpn("");
		}
		else
		{
			// 未定義キャラだと0が入っているのでここにくる
			// _dpn("タイプ:"+typeof val+" : "+slot+" -> "+val );
		}
	}
}


// ----------------------------------------------------------------------------
// Std_MoveTable作成
// ----------------------------------------------------------------------------

local Std_MoveTable = {} //基本行動リストテーブル


Battle_Std.AddHitEffects( Std_MoveTable, _ChrNo ); // ヒットエフェクトMvを追加する

// ----------------------------------------------------------------------------
// ゲーム全体の割り込み関数
// ----------------------------------------------------------------------------

// 条件付き勝利
// ※タイムアップ勝利はボイス定義側で行って下さい
// enemy = -1 相手キャラをチェックしない
local finish_achive =
{
	[Def_ChrNo_Chr000] = [{ enemy=Def_ChrNo_Chr005, finish=30, achievement_slot=54 }],
	[Def_ChrNo_Chr011] = [{ enemy=Def_ChrNo_Chr009, finish=20, achievement_slot=54 }, { enemy=Def_ChrNo_Chr010, finish=30, achievement_slot=56 } ],
	[Def_ChrNo_Chr002] = [{ enemy=Def_ChrNo_Chr003, finish=30, achievement_slot=55 }, { enemy=Def_ChrNo_Chr001, finish=30, achievement_slot=54 }, { enemy=Def_ChrNo_Chr004, finish=30, achievement_slot=54 } ],
	[Def_ChrNo_Chr003] = [{ enemy=Def_ChrNo_Chr005, finish=20, achievement_slot=55 }, { enemy=Def_ChrNo_Chr009, finish=20, achievement_slot=54 }, { enemy=Def_ChrNo_Chr000, finish=30, achievement_slot=56 } ],
	[Def_ChrNo_Chr006] = [{ enemy=Def_ChrNo_Chr009, finish=30, achievement_slot=56 }, { enemy=Def_ChrNo_Chr003, finish=10, achievement_slot=55 } ],
	[Def_ChrNo_Chr008] = [{ enemy=Def_ChrNo_Chr009, finish=30, achievement_slot=55 }],
	[Def_ChrNo_Chr009] = [{ enemy=Def_ChrNo_Chr005, finish=20, achievement_slot=55 }, { enemy=Def_ChrNo_Chr000, finish=30, achievement_slot=56 } ],
	[Def_ChrNo_Chr005] = [{ enemy=Def_ChrNo_Chr003, finish=20, achievement_slot=54 }, { enemy=Def_ChrNo_Chr000, finish=30, achievement_slot=56 }, { enemy=Def_ChrNo_Chr011, finish=10, achievement_slot=55 } ],
	[Def_ChrNo_Chr013] = [{ enemy=Def_ChrNo_Chr002, finish=30, achievement_slot=56 }],
	[Def_ChrNo_Chr010] = [{ enemy=Def_ChrNo_Chr011, finish=30, achievement_slot=54 }, { enemy=Def_ChrNo_Chr003, finish=10, achievement_slot=55 } ],
	[Def_ChrNo_Chr012] = [{ enemy=Def_ChrNo_Chr005, finish=30, achievement_slot=55 }, { enemy=Def_ChrNo_Chr009, finish=10, achievement_slot=56 } ],
	[Def_ChrNo_Chr007] = [{ enemy=Def_ChrNo_Chr002, finish=30, achievement_slot=55 }, { enemy=Def_ChrNo_Chr003, finish=30, achievement_slot=56 }, { enemy=Def_ChrNo_Chr002, finish=20, achievement_slot=54 } ],
}

//function Std_MoveTable::GeneralInterrupt( info )
Std_MoveTable.GeneralInterrupt <- function( info ) : (finish_achive)
{
	// info は BMvTbl::MvInterruptInfo クラス
	switch( info.type ) // typeで分岐
	{
	case _InterruptType_Ko_Atk: // KOした
		//print( "\n_InterruptType_Ko_Atk" );
		
		//KOの情報をまとめ
		local now_ko_param = {
			player = BMvCore.GetCharaNo(),//タッグのキャラ番号
			enemy = Battle_Std.GetEnemyCharaNo(),
			finish = info.Param1,
		}
		
		Battle_Std.GS_AddFlag( def_PP_GS_KoAtk ); // 何かしらでKOしたのを記憶
		
		//トロフィー開放
		switch( now_ko_param.finish )
		{
		case 20:
			Battle_Std.Achievement_Unlock(19);//【トロフィー】アークドライブフィニッシュ
			Battle_Std.GS_AddFlag( def_PP_GS_ArcDriveFinish );
			break;
		case 30:
			Battle_Std.Achievement_Unlock(20);//【トロフィー】ラストアークフィニッシュ
			break;
		}
		
		// KOした側がプレイヤー操作のときのみアチーブメントは処理
		local achiv_ok = 1;
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			if( tDDC.IsNotPlayMode() ) achiv_ok = 0;//アドバタイズ、リプレイ、観戦時はダメ
			if( tDDC.IsNotEnemySide() ) achiv_ok = 0;//観戦時、CPU側はダメ
			// if( BMvTbl.IsCpu()!=0 ) achiv_ok = 0;//CPU側はダメ　これを入れると他のアチーブメントと条件が変わるかも

			player.pop();
		}
		// _dpn("★★★KO:"+achiv_ok+" INP:"+tDDC.IsNotPlayMode()+" INE:"+tDDC.IsNotEnemySide()+" CPU:"+BMvTbl.IsCpu() );
		
		if( achiv_ok )
		{
			// 特定の技でKOしたらアチーブメントを開放する仕様
			
			if( now_ko_param.player in finish_achive )
			{
				foreach( slot, val in finish_achive[now_ko_param.player] )
				{
					// enemyとfinishが一致してたらachievement_slotを開放する
					if( ( !("enemy" in val) || (val.enemy == now_ko_param.enemy) || (val.enemy == -1) ) && val.finish == now_ko_param.finish )
					{
						Battle_Std.CharaAchievement_Increment( val.achievement_slot, "KO" );
					}
				}
			}
		}
		break;
	case _InterruptType_Ko_Def: // KOされた
		//print( "\n_InterruptType_Ko_Def" );
		//スローにする
		
		//まず音声をとめる（投げ開放系だと停止中に声がでちゃうので）
		BSound.SE_Stop( { type=_SeType_Player } ); // 自分のやられ音声をとめる

		BMvEff.CreateObject( { mvname="Mv_KOCamera_Object", datatype=1 } );
		
		//キャラ別にいじれるオブジェクトを一応呼ぶ
		BMvEff.CreateObject( { mvname="Mv_KOImpact_Object", datatype=1 } );
		
		BSound.SE_Play( { type=_SeType_Normal, num=75 } ); //ＫＯ効果音
		break;
	case _InterruptType_DrawMotion: // ドロー
		// _dpn("_InterruptType_DrawMotion");
		break;
	case _InterruptType_TM_MoonDriveReset:
		// トレーニングモードのムーンドライブ状態の設定色々
		// ムーンドライブ発動後に「常時ムーンドライブ」に変えたり、またはその逆などの初期化処理
		//高速回復でMDが無限になると、結構違和感あったので廃止
		local pside = BMvTbl.GetPlayerSide();
		switch(tDDC.Moon_MoonDriveIsInfinitePlayer(pside))//1:常時 2:高速回復
		{
		case 1: // 「常にムーンドライブ」を選んで閉じた
			//常時ムーンドライブ
			if( tDDC.Moon_GetType() != 0 )
			{
				//ムーンドライブ中
				if( tDDC.Moon_GetValue() < 10000 )//無限じゃない
				{
					tDDC.Moon_MoonDriveStart( { type=1, time=10001} );//MAXムーンドライブ＆時間無限に変更
				}
			}
			else
			{
				//ムーンドライブじゃないときにきたら、ムーンドライブ発動と同じ処理を通してムーンドライブにする
				BMvEff.CreateObject( { mvname="Mv_Null_DelayCallChangeMoonDrive" } );//1F待機してから呼び出す
			}
			break;
		default:
			// 「高速回復」や「通常」を選んで閉じた
			// 無限ムーンドライブ中だったら時間設定をして通常のムーンドライブに戻す
			if( tDDC.Moon_GetType() != 0 ) // ムーンドライブ中
			{
				if( tDDC.Moon_GetValue() >= 10000 )//無限っぽい
				{
					// 無限状態は減少しないので無理やり求めて本当に無限かチェックする
					// このチェックをしないと「ムーンドライブ中で月残量が減っていない＝発動後の時間停止中」も無限と扱われる
					local nowvalue = tDDC.Moon_GetValue();
					tDDC.Moon_AddValue( -nowvalue ); // 一旦0にする
					tDDC.Moon_AddValue( 1000 ); // 1000足す
					tDDC.Moon_AddValue( -1000 ); // 1000引く
					if( tDDC.Moon_GetValue() != 0 )
					{
						// 無限だったので通常のムーンドライブに
						tDDC.Moon_MoonDriveStart( { type=1, time=Def_MoonDriveTimeMax } );//MAXムーンドライブの時間に
					}
					else
					{
						// 無限じゃなかったので残量を戻す
						tDDC.Moon_AddValue( 10000 ); // 10000足す
					}
				}
			}
			break;
		}
		break;
	}
}

//キャラの座標が正確になるまで少し待機してMDに
//そうしないとオーラの座標がおかしい
Std_MoveTable.Mv_Null_DelayCallChangeMoonDrive <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 1 )
		{
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				Battle_Std.ChangeMoonDriveMode( { type=1, time=10001 } );//MAXムーンドライブ＆時間無限
				player.pop();
			}
			BMvTbl.SetFinalize();
		}
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//超技中持続するオブジェクト
//超技での背景を切り替えたりする
Std_MoveTable.Mv_SPAfterImage_KanriObject <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender| _ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );

		Battle_Std.GS_AddFlag( def_PP_GS_SPKanriObjFlag ); // 暗転中というフラグを立てる
		Battle_Std.PP_DelFlag( def_PP_ArcDriveStatus, def_PP_ADS_ComboDamageBoost ); //ダメージブースト念の為初期化
	}
	function FrameUpdate_Std()
	{
		local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		local skillmove = 0;
		local spmove = 0;
		local object_daburi = 0; // このオブジェクトの２個目が出てきているっぽいかどうか
		
		local obj_mvs = BMvTbl.GetMvStatus();
		local obj_mvs_MvCount = obj_mvs.MvCount+1; // 超技中持続するMvのMvCount(呼び出し分1F遅いので足す)
		
		if( player.push() )
		{
			skillmove = ( Battle_Std.MoveCode.CheckFlag( def_MC_Skill ) );
			spmove = ( Battle_Std.MvAction.CheckFlag( def_MC_SPAction ) );
			
			player.pop();
		}
		
		if( obj_mvs_MvCount == def_FL_SPCutinStopTime ) // 暗転抜けたタイミング
		{
			_dp("\n 暗転おわり");
			Battle_Std.GS_DelFlag( def_PP_GS_SPKanriObjFlag ); // 暗転を抜けたのでフラグを消す
		}
		else if( obj_mvs_MvCount > def_FL_SPCutinStopTime )
		{
			if( Battle_Std.GS_CheckFlag( def_PP_GS_SPKanriObjFlag ) )
			{
				object_daburi = 1; // ２個目でてるっぽい
			}
		}
		
		if( Def_Sys_SetMuteki_ArcDriveEnemy )
		{
			//コンボ中のとき相手に飛び道具無敵を付与する
			//そうしないと超技演出中に飛び道具があたるとダメージが高くなってしまう
			//弾側を消すとかすると、そもそも発動タイミングではヒットが確定してないのでやるとおかしくなるのでこうするしかなさそう
			if( Battle_Std.PP_CheckFlag( def_PP_ArcDriveStatus, def_PP_ADS_ComboDamageBoost ) )
			{
				if( Battle_Std.CheckEnemyisDamage() )
				{
					local enemy = BMvCore.GetEnemyCharaData();
					if( enemy.push() )
					{
						// _dpn("相手に弾無敵を設定");
						BMvTbl.SetHitCheckFlag( { type=0, val=_HitCheckFlag_FireBall, time=32, flag=_ClearFlag_ChangeMv  } ); // 弾無敵
						enemy.pop();
					}
				}
			}
		}

		if( skillmove && spmove ) //必殺技でＳＰ扱い
		{
		}
		else
		{	
			BMvTbl.SetFinalize(0);
		}
		if( object_daburi )
		{
			_dp("\n ダブリで終了");
			BMvTbl.SetFinalize(100);
		}
	}
	function Finalize()
	{
		if( BMvTbl.GetFinalizeCode() != 100 ) // ダブりで終了の時以外
		{
			local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			if( player.push() )
			{
				BMvEff.PcAfterImage_Clear(); //残像の消去
				BMvEff.CutInProc_Erase(); //カットインがあったら消去する
				
				player.pop();
			}
		}
		BMvTbl.SetDeleteMoveTable();
	}
}


//空振りガード関係
//確かMv名はプログラムから直指定
Std_MoveTable.Mv_VGuard_Stand <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする

		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( s.DataPattern!=def_PAT_VGuard_S )
		{
			BMvTbl.SetPattern(def_PAT_VGuard_S); // 任意
			BMvTbl.JumpFrameID(100); // 行動可能のガードポーズへ
			BMvTbl.VGuard_Time(def_PAT_VGuard_Time);
		}
		else //同じパターンでもFrameIDをチェック
		{
			if( (s.FrameID==120 || s.FrameID==130 ) ) //抜けてた
			{
				BMvTbl.JumpFrameID(100); // 行動可能のガードポーズへ
			}
		}		
		
		Battle_Std.InitCharaVector(); //InitCharaVectorでXMAX初期化するようにしたのでこっちでＯＫ
		//Battle_Std.InitVector(); //ダッシュの慣性が乗ってしまうのでこうする
	}
	function Update_Std() // 
	{
		local type = BMvTbl.VGuard_CheckKeep();
		if( type != 0 )
		{
			BMvTbl.VGuard_Time(def_PAT_VGuard_Time); // もどす
			if( type == 1 ); // そのまま継続
			else if( type == 2 ) BMvTbl.SetFinalize(2); // しゃがみへ
			else
			{
				// 例外、怖いので終わり
				BMvTbl.SetFinalize(0);
			}
		}
		else
		{
			if( BMvTbl.VGuard_Time(-1) == 0 ) // 時間を取得し0だと終了
			{
				BMvTbl.SetFinalize(0);
			}
		}
		//
		//print("\nKeep_Stand" + BMvTbl.VGuard_Time(-1) ); //-1で取得
	}
	function Finalize_Std() // 
	{
		BMvTbl.VGuard_Time(0); // 0にする
		Battle_Std.SwitchNextMoveTable("Mv_VGuard_StandEnd", [2,"Mv_VGuard_Crouch"]); //デフォ,[code,mv]...	
	}
	function LastUpdate_Std() // 
	{
		BMvTbl.VGuard_Time(0); // 0にする
	}
}

Std_MoveTable.Mv_VGuard_Crouch <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする

		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( s.DataPattern!=def_PAT_VGuard_C )
		{	
			//print("\n違うパターンなので設定");
			BMvTbl.SetPattern(def_PAT_VGuard_C); // 任意
			BMvTbl.JumpFrameID(100); // 行動可能のガードポーズへ		
			BMvTbl.VGuard_Time(def_PAT_VGuard_Time);
		}
		else //同じパターンでもFrameIDをチェック
		{
			if( (s.FrameID==120 || s.FrameID==130 ) ) //抜けてた
			{
				BMvTbl.JumpFrameID(100); // 行動可能のガードポーズへ
			}
		}
		Battle_Std.InitCharaVector(); //InitCharaVectorでXMAX初期化するようにしたのでこっちでＯＫ
		//Battle_Std.InitVector(); //ダッシュの慣性が乗ってしまうのでこうする
	}
	function Update_Std() // 
	{
		local type = BMvTbl.VGuard_CheckKeep();
		if( type != 0 )
		{
			// 継続
			BMvTbl.VGuard_Time(def_PAT_VGuard_Time); // もどす
			if( type == 1 )  BMvTbl.SetFinalize(1); // 立ちへ
			else if( type == 2 ); // そのまま継続
			else
			{
				// 例外、怖いので終わり
				BMvTbl.SetFinalize(0);
			}
		}
		else //継続しない
		{
			if( BMvTbl.VGuard_Time(-1) == 0 ) // 時間を取得し0だと終了
			{
				BMvTbl.VGuard_Time(0); // 0にする
				BMvTbl.SetFinalize(0);
			}
		}
		// 
		//print("\nKeep_Crouch" + BMvTbl.VGuard_Time(-1)+" type:"+type );
	}
	function Finalize_Std() // 
	{
		BMvTbl.VGuard_Time(0); // 0にする
		Battle_Std.SwitchNextMoveTable("Mv_VGuard_CrouchEnd", [1,"Mv_VGuard_Stand"]); //デフォ,[code,mv]...	
	}
	function LastUpdate_Std() // 
	{
		BMvTbl.VGuard_Time(0); // 0にする
	}
}


// 
Std_MoveTable.Mv_VGuard_StandEnd <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		Battle_Std.JumpFrameIDEX(120, def_PAT_VGuard_S, 0); //設定FrameID, 上書きPattern, 失敗時FinalizeCode
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

Std_MoveTable.Mv_VGuard_CrouchEnd <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		Battle_Std.JumpFrameIDEX(120, def_PAT_VGuard_C, 0); //設定FrameID, 上書きPattern, 失敗時FinalizeCode
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}























// ----------------------------------------------------------------------------
// やられ関係
// ----------------------------------------------------------------------------
// ○特殊なもの
// Mv_Bound_0023 投げ抜け押し返し攻撃
// Mv_Bound_0024 投げ抜けられガードポーズ

//のけぞり時間がcnt以上なら採用される
local boundAniParams2 =
[
	{ cnt= 0, fra=[4,3,4],			omomi=[1,300,100], },
	{ cnt= 6, fra=[3,2,3,4],		omomi=[1,400,120,120], },
	{ cnt=12, fra=[2,1,2,3,4],		omomi=[1,500,100,100,100], },
	{ cnt=24, fra=[1,0,1,2,3,4],	omomi=[1,600,100,100,100,100], },
	{ cnt=36, fra=[0,0,1,2,3,4],	omomi=[1,700,100,100,100,100], },
];

Std_MoveTable.Mv_Bound <- 
{
	function Init_Std() // 
	{
		Battle_Std.BoundInit();
	}
	function Update_Std()
	{
		Battle_Std.BoundUpdate();
	}
	function FrameUpdate_Std() : (boundAniParams2)
	{
		//落下アニメ自動ジャンプ
		local bs = BtlMvStd.GetBoundStatus();
		if( bs.isBound && bs.VecCount == 0 )
		{
			local bs_power = bs.Power;
			
			if( bs_power&def_BS_Pow_JumpFallAnime )	
			{
				local mvs = BMvTbl.GetMvStatus();
				if (mvs.FrameID==100) //落下チェックID中なら
				{
					//ベクトルが↓向いたら落下パターンへ
					local vec = BMvTbl.GetVector( { flags=_Vector_Bound }); //ベクトル取得
					local about_fall = (vec.y >= 500)? 1 : 0;
					
					if( about_fall )
					{
						if (BMvTbl.JumpFrameID(256) == -1)
						{
							_dem("【警告】飛び先のフレームIDが無い");
						}
					}
				}
			}
		}
		
		// アニメ自動設定
		if( bs.isBound )
		{
			local bs_power = bs.Power;
			
			if( bs_power&def_BS_Pow_GroundAutoAnime )
			{
				local use_aniparams = boundAniParams2;
				local use_ani = use_aniparams[1];
				local bs_cnt_max = bs.GetCountMax();
				for( local i=use_aniparams.len()-1; i>=0; i-- )
				{
					// _dp("\n i:"+i+" bs_cnt_max:"+bs_cnt_max+" >= "+use_aniparams[i].cnt );
					if( bs_cnt_max >= use_aniparams[i].cnt )
					{
						use_ani = use_aniparams[i];
						// _dp("\n 抽選したi = "+i );
						break;
					}
				}
				
				//20Fののけぞりの場合…
				//par = 1000/20 = 50
				//pos = 1000 - (10*50) = 500
				//10Fのけぞってる=*5
				local par = 1000 / (bs.GetCountMax()-1);
				local pos = (bs.GetCountMax() - bs.GetCountNow() ) * par; // 最大1000ののけぞり重み
				local omomi_max = 0;
				for( local i=0; i<use_ani.omomi.len(); i++ )
				{
					omomi_max += use_ani.omomi[i];
				}
					
				local ch_omo = 0;
				for( local i=0; i<use_ani.omomi.len(); i++ )
				{
					local omo = use_ani.omomi[i]*1000/omomi_max;
					ch_omo += omo;
					// _dp("\n par:"+par+" pos:"+pos+" omo:"+omo+" GC:"+bs.GetCountNow()+"/"+bs.GetCountMax() );
					if( pos < ch_omo )
					{
						// print("\n ここ:"+i+" pos:"+pos+" 設定Fra:"+use_ani.fra[i] );
						BMvTbl.Frame_Proc( use_ani.fra[i], _ValSet );
						break;
					}
				}
			}
		}
		
		if( Def_Sys_DownOiutiUkemiType )
		{
			if( bs.isBound && bs.IsDown() && bs.Num >= 237 && bs.Num <= 239 )
			{
				local oiuti_frame = BMvTbl.GetMvStatus().MvCount;
				
				//CPで計算するタイプ
				local muteki_limit = 8;
				local enemy = BMvCore.GetEnemyCharaData();
				if( enemy.push() )
				{
					local cp = BMvTbl.ComboPoint_Calc( { num=0 } );//今の値
					
					enemy.pop();
					
					if( cp < 5 )
					{
						muteki_limit = 0;
					}
					else if( cp < 10 )
					{
						muteki_limit = 8;
					}
					else if( cp < 20 )
					{
						muteki_limit = 10;
					}
					else if( cp < 40 )
					{
						muteki_limit = 12;
					}
					else
					{
						muteki_limit = 14;
					}
					// _dpn("ダウン追い打ち:"+cp+" F:"+oiuti_frame+"/"+muteki_limit );
				}
				
				if( bs.VecCount != 0 )
				{
					//バウンド後は無敵に
					muteki_limit = 0;
				}

				
				if( oiuti_frame > muteki_limit )
				{
					//受け身はとれないので、無敵にして拾えなくする
					BMvEff.SetPlayerTimer( { muteki_dage=8, muteki_dageX=8 } ); // 怖いので時間は短め
				}
				
			}
		}
	}
	function Finalize_Std() // 
	{
		//抜け先が無いかも？
		//状態の移行だけ行う
		BtlMvStd.SetBoundFinalize();
		// print("\nMv_Bound Finalize()");
	}
	function LastUpdate_Std() // 
	{
		if( Def_Rule_GroundBoundSlideKeep )
		{
			//地上状態では慣性を残す
			if( BMvTbl.CheckPosState( _PosState_Ground  ) )
			{
				local vec = BMvTbl.GetVector( { flags=_Vector_Bound } );
				BMvTbl.SetVector( { x=vec.x, addx=-vec.x/10, flags=_Vector_DivKeep } );
				// print("\n vec.x:"+vec.x);
			}
		}
		BtlMvStd.ClearBound(); // 状態解除(ベクトルが無くなる)
		// print("\nMv_Bound LastUpdate()");		
	}
}

//ダウン追い打ち
//Std_MoveTable.Mv_Bound_0237

//捕まれ中はMv_BoundではなくMv_Bound_Captureになります(毎フレームInitする)
//Mv_Bound_Captureは名前だけでBoundではないため、Bound関係で何かしようとすると危ない
//Mv_Bound_Captureという状態を取得できるだけと考えたほうがいい
//エラーがうざいので一応定義するけど何もしない
Std_MoveTable.Mv_Bound_Capture <- 
{
	function Init_Std() // 
	{
		if( BMvTbl.ChangeMv_GetMvName() != "Mv_Bound_Capture" )
		{
			// print("\nMv_Bound_Capture Init()");
			// ベクトル初期化だけ行う
			// つかみ成立→前MvのLastUpdateでベクトル設定→このMvで動きっぱなしになる
			Battle_Std.InitVector();
			
			// やられボイス再生処理
			local sound_st = BMvTbl.GetPP(def_PP_SoundStatus);
			if( sound_st&def_PP_SS_NoBoundVoice )
			{
			}
			else if( sound_st&def_PP_SS_NoBoundVoiceOnce )
			{
			}
			else
			{
				Battle_Std.PlayerSE_StopLastPlaySound( 1 ); //直前に再生した音声を停止
			}
			BMvEff.CutInProc_Erase(); //カットインがあったら消去する
			
			local anno_flags = BMvTbl.GetPP(def_PP_ImpactAnnounce);
			BMvTbl.SetPP(def_PP_ImpactAnnounce,0);//すぐ初期化
			Battle_Std.DrawPunishAnnounce( anno_flags ); //やられアナウンス処理
		}
	}
	function Finalize_Std() // 
	{
		// Finalizeすると無限ループして落ちるし、そもそも何もしないでおく
		// BMvTbl.SetNextMoveTable( "Mv_Bound_Capture" );
	}
}

// ----------------------------------------------------------------------------
// Guard
// ----------------------------------------------------------------------------

// シールドの設定
// ガードやシールドのMVで共通なのでここで定義
local shieldParams = 
{
	Std = {
		initPat = def_PAT_Barrier_Std,
		finMv = "Mv_StdShieldDelay",
		finMvSuc = "Mv_StdShieldSucDelay",
		activity_slot = 70,
		activity_suc_slot = 71,
		activity = "立ちシールド使用",
		activity_suc = "立ちシールド成功",
		activity_ave = "立ちシールド成功確率",
		isAir = 0,
		landMv = 0,
		landMvSuc = 0,
		penalty_pluslv = 1,//未使用
	},
	Cro = {
		initPat = def_PAT_Barrier_Cro,
		finMv = "Mv_CroShieldDelay",
		finMvSuc = "Mv_CroShieldSucDelay",
		activity_slot = 75,
		activity_suc_slot = 76,
		activity = "しゃがみシールド使用",
		activity_suc = "しゃがみシールド成功",
		activity_ave = "しゃがみシールド成功確率",
		isAir = 0,
		landMv = 0,
		penalty_pluslv = 2,
	},
	Air = {
		initPat = def_PAT_Barrier_Air,
		finMv = "Mv_AirShieldDelay",
		finMvSuc = "Mv_AirShieldSucDelay",
		activity_slot = 80,
		activity_suc_slot = 81,
		activity = "空中シールド使用",
		activity_suc = "空中シールド成功",
		activity_ave = "空中シールド成功確率",
		isAir = 1,
		landMv = "Mv_AirShieldLand",
		landMvSuc = "Mv_AirShieldSucLand",
		landStdMv = "Mv_StdShield",
		landCroMv = "Mv_CroShield",
		penalty_pluslv = 1,
	}
}

//特殊判定のメモ
//PAT17 特殊判定15 ... 仮想しゃがみガードのやられ判定。切り替え中段検知用。

Std_MoveTable.Mv_Guard <- 
{
	function Init_Std() : (shieldParams)// 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		Battle_Std.InitVector(); // ベクトル初期化
		
		// _dpn("ガードで初期化");
		local anno_flags = BMvTbl.GetPP(def_PP_ImpactAnnounce);
		BMvTbl.SetPP(def_PP_ImpactAnnounce,0);//このタイミングorBoundInitで初期化される

		local damage_impact_count = BMvTbl.GetPP(def_PP_DamageImpactCount);
		BMvTbl.SetPP(def_PP_DamageImpactCount,0); // このタイミングorBoundInitで初期化される
		// _dpn("このフレームにあたった技の数:"+damage_impact_count);
		
		//ガードに来る前の状態。実際のガードの姿勢とは異なり、どの状態から来たか
		local fromStatus = {
			pat = BMvTbl.GetMvStatus().DataPattern,
			isStand  = BCMDTbl.CheckPosState( _PosState_Stand  ),
			isCrouch = BCMDTbl.CheckPosState( _PosState_Crouch ),
			isAir = BCMDTbl.CheckPosState( _PosState_Air  ),
		}
		// _dpn("fromStatus:"+fromStatus.pat+" st:"+fromStatus.isStand+", "+fromStatus.isCrouch+", "+fromStatus.isAir );
		
		local is_renzoku_guard = ( BMvTbl.ChangeMv_GetMvName() == "Mv_Guard" )? 1 : 0;
		if( !is_renzoku_guard )
		{
			//_dpn("１つ前の行動がガードじゃない＝連続ガードではない");
			BMvTbl.SetPP(def_PP_GuardActionID,0);//初期化
		}
		
		BtlMvStd.SetGuardStatus();
		//print("\nMv_Bound Init()\n");
		
		BMvTbl.SetLP(7,0); // ラストアーク条件を満たしたら1
		BMvTbl.SetLP(8,0); // ガードフロートで無敵時間のついたガードだよ
		BMvTbl.SetLP(9,0); // シールド成功の記憶 10:立ちシールド 20:しゃがみシールド 30:空中シールド
		
		BMvTbl.SetLPEx(1,5,0); // 初回シールドかどうか(シールドエフェクトの変化用に使っている)
		BMvTbl.SetLPEx(1,6,0); // シールド失敗記憶
		
		local mvs = BMvTbl.GetMvStatus();
		local nowpat = mvs.DataPattern;
		local training_cpu_setpat = 0; // トレモの全てガードで失敗シールドにしないための値
		
		local change_mv = BMvTbl.ChangeMv_GetMvName();
		local last_success_shield = ( (change_mv == "Mv_Guard" && Battle_Std.ChangeMoveCodeEx_CheckFlag(2,def_MC2_ShiledSuccess)) || change_mv == "Mv_StdShieldSuccess" || change_mv == "Mv_CroShieldSuccess" || change_mv == "Mv_AirShieldSuccess" )? 1 : 0;
		if( !last_success_shield )
		{
			BMvTbl.SetLPEx(1,5,1); // 初回シールドかどうか
		}
		
		local shield_is_miss = 0; // 0:失敗じゃない　1:Bで失敗　2:Cで失敗
		if( Def_Sys_NerfShield_CheckPosStatus )
		{
			if( BMvEff.GuardSP_Success() )
			{
				//last_success_shield
				//前回がシールドに成功したガード（＝連続シールドの場合）の場合は失敗チェックなし
				//そうしないと、多段の立ちBとかを一瞬立ちシールド→しゃがみガードってファジーしたとき、二段目を食らってよくない

				//…でもこのチェックだと、2Aを屈シールド成功してる相手に、立ちBってやっても屈シールドされるので、
				//相手の攻撃MVにシールドされたフラグがたってる場合はチェックしない形に変更する

				//相手が立ちB・立ちCの場合は屈シールドを失敗させる
				//立ちシールドもしゃがみB、しゃがみCでシールドを失敗させる
				local enemy_LastDmgChr = BMvCore.GetLastDamageCharaData( 0 ); // 0 そのままの相手を取得 1 殴られた相手の一番親を取得
				if( enemy_LastDmgChr.push() )
				{
					local mvname = BMvTbl.GetMvName();
					local shielded_atk = Battle_Std.MoveCodeEx.CheckFlag( 5, def_MC5_ShieldedEvenOnce ); // 一度でもシールドを取られたMv
					enemy_LastDmgChr.pop();
					
					//GetLastDamageCharaDataのチェック時はshielded_atkを見ればいいが、同時ヒットしたanno_flagsで見るなら見るべきフラグが異なる
					//失敗シールドはプレイヤーの立ちB・立ちCだけなので、直接相手プレイヤーを見に行くことで（雑に）解決しておく
					local shielded_atk_pl = 0;
					local enemy = BMvCore.GetEnemyCharaData();
					if( enemy.push() )
					{
						shielded_atk_pl = Battle_Std.MoveCodeEx.CheckFlag( 5, def_MC5_ShieldedEvenOnce ); // 一度でもシールドを取られたMv
						enemy.pop();
					}
					
					// レバー入れとかは対応せず、あくまでBとCだけに限定（BEもそうなので）
					// 飛び道具と立ちCが同時に重なって屈シールドしようとしたときなど、ガードベクトルの優先度で結果が変わってしまうので
					// DamageImpactでなんの技をガードしたのか一通りフラグを立ててあって、それも踏まえて厳重にチェックする
					if( nowpat == def_PAT_GuardC )
					{
						if( (mvname == "Mv_Atk_StdB" && !shielded_atk) || (anno_flags&def_PP_IA_GuardStdB && !shielded_atk_pl) )
						{
							shield_is_miss = 1;
						}
						else if( (mvname == "Mv_Atk_StdC" && !shielded_atk) || (anno_flags&def_PP_IA_GuardStdC && !shielded_atk_pl) )
						{
							shield_is_miss = 2;
						}
					}
					else if( nowpat == def_PAT_GuardS )
					{
						if( (mvname == "Mv_Atk_CroB" && !shielded_atk) || (anno_flags&def_PP_IA_GuardCroB && !shielded_atk_pl) )
						{
							shield_is_miss = 1;
						}
						else if( (mvname == "Mv_Atk_CroC" && !shielded_atk) || (anno_flags&def_PP_IA_GuardCroC && !shielded_atk_pl) )
						{
							shield_is_miss = 2;
						}
					}
					
					//CPUのトレモ専用の処理
					if( shield_is_miss )
					{
						local training_allguard = BMvEff.TM_IsEnemyAllShield(); //トレーニングモードである+ガード：全てガード+シールド：あり、ランダムで1
						
						local stage_st = BMvTbl.GetMvStageStatus().IsTrainingBattle();// 1-トレーニング 2-チュートリアル 3-ミッション
						if( stage_st == 1 && training_allguard && BMvTbl.IsCpu() ) // 全てガード＋CPU＋トレモ時
						{
							local ikinari_shield = ( change_mv == "Mv_StdShield" || change_mv == "Mv_CroShield" )? 0 : 1;//空中は関係ないので除外した
							
							//いきなりシールドで、かつ姿勢不一致のとき、失敗シールドになるところをCPU専用で正しいシールドに書き換える
							// _dpn("ikinari_shield:"+ikinari_shield);
							if( ikinari_shield && shield_is_miss )
							{
								shield_is_miss = 0;//失敗シールドにしない
								//正しい姿勢でシールドさせるためにPAT番号を予約する
								if( nowpat == def_PAT_GuardC )
								{
									training_cpu_setpat = def_PAT_GuardS;
								}
								else if( nowpat == def_PAT_GuardS )
								{
									training_cpu_setpat = def_PAT_GuardC;
								}
							}
						}
					}
				}
			}
			if( shield_is_miss )
			{
				// 赤は合計値の削りになる
				/*
				BMvEff.SetHpGauge( { value=-300, valuetype=3 } ); // 赤+実の削り
				BMvEff.SetHpGauge( { value=-400, valuetype=1 } ); // 赤のみの削り
				*/

				// 受け止めの削りダメージ的に実ダメージはない方がよさそう
				local damage = ( shield_is_miss == 1)? -400 : -800;
				BMvEff.SetHpGauge( { value=damage, valuetype=1 } ); // 赤のみの削り
				
				BMvTbl.SetLPEx(1,6,1); // シールド失敗を記憶してエフェクトのPATをガードエフェクトに変える

				tDDC.Moon_AddValue( -2000 );//月消費 1000はシールド発動分で必須で+1本という感じにした

				// ガード硬直増加はやりすぎると連携が変わってきて結構攻め側にとってノイズの可能性がある
				// 多少は増やしてもいいけどいまいち。どっちかというとシールドしてる側の強化にする方があってる
				// BMvEff.SetBoundSt( { addtime = 15 } );//ガード硬直増加
				
				BMvEff.ClearGuardSP_Success(); // SPガードの成功状態を初期化（これorガードで初期化される）
				
				if( !Def_Sys_ShieldMissGuardNoPlusStop ) // 時間停止で操作感（ディレイ固めなど）にズレがあって気持ち悪いので廃止
				{
					BMvEff.SetStopTime( { time=5, stopme=2 } );//一瞬だけ時間停止を入れる
				}
				BMvEff.SetCamera_Quake( { time=8, type=0 } );
				
				Battle_Std.MoveCodeEx.AddFlag( 5, def_MC5_ShieldMissGuard ); // シールド失敗ガード状態
			}
		}		

		//ガードのボイスを選んで再生
		local bs = BtlMvStd.GetBoundStatus(); // バウンド情報取得
		local bs_isBound = bs.isBound;
		
		local bs_power = ( bs_isBound )? bs.Power : 0;
		local bs_BoundTimeAll = ( bs_isBound )? bs.BoundTimeAll : 0;
		
		if( bs_isBound )
		{
			if( bs_power&def_BS_Pow_GuardFloat && !BMvEff.GuardSP_Success() ) 
			{
				// ガードフロートなので無敵にします　※21/10/25シールド時はフロートで浮かないので除外
				_dp("\n ガードフロートなので無敵をセット");
				BMvEff.SetPlayerTimer( { muteki_dage=64, muteki_dageX=64 } ); // 怖いので時間は短め
				BMvTbl.SetLP(8,1); // 無敵をセットしたことを記憶
				
				//フロートなので画面揺れを入れる
				BMvEff.SetCamera_Quake( { time=10, type=0 } );
				Battle_Std.MoveCodeEx.AddFlag( 5, def_MC5_EnableAirToLandedShield );
			}
		}
		
		local sp_guard_pat = def_PAT_Barrier_Std;
		local sp_guard_fincode = 10;
		local sp_guard_land = 0;
		
		// パターンによってフラグをつけておく(MC2はチュートリアル検知用)
		if( training_cpu_setpat == def_PAT_GuardS )
		{
			sp_guard_pat = def_PAT_Barrier_Std;
			sp_guard_fincode = 10;
			Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_StatusStd );
		}
		else if( training_cpu_setpat == def_PAT_GuardC )
		{
			sp_guard_pat = def_PAT_Barrier_Cro;
			sp_guard_fincode = 20;
			Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_StatusCro );
		}
		else if( nowpat == def_PAT_GuardS )
		{
			sp_guard_pat = def_PAT_Barrier_Std;
			sp_guard_fincode = 10;
			Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_StatusStd );
		}
		else if( nowpat == def_PAT_GuardC )
		{
			sp_guard_pat = def_PAT_Barrier_Cro;
			sp_guard_fincode = 20;
			Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_StatusCro );
		}
		else if( nowpat == def_PAT_GuardA && fromStatus.isAir )
		{
			sp_guard_pat = def_PAT_Barrier_Air;
			sp_guard_fincode = 30;
			Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_StatusAir );
		}
		else
		{
			//例外処理、及びガードフロートを地上ガード時がここ
			//中段のフロートをCPUがシールドするとしゃがみシールドするので無理やり対策する
			local tyudan = Battle_Std.PP_CheckFlag(def_PP_ImpactAnnounce,def_PP_IA_OverHead );
			// _dpn("tyudan:"+tyudan);
			if( fromStatus.isCrouch && !tyudan ) // 中段のときは立ちシールドしないとおかしい
			{
				sp_guard_pat = def_PAT_Barrier_Cro;
				sp_guard_fincode = 20;
			}
			else
			{
				sp_guard_pat = def_PAT_Barrier_Std;
				sp_guard_fincode = 10;
			}
			sp_guard_land = 1; //空中で立つと困るので強制着地
		}
		
		//シールド成功時の処理
		//シールドに成功
		if( BMvEff.GuardSP_Success() && !shield_is_miss ) // この弾き方は雑
		{
			BMvTbl.SetLP(9,sp_guard_fincode); // シールド成功の記憶 10:立ちシールド 20:しゃがみシールド 30:空中シールド
			
			// Mv_StdShield > Mv_Guard > Mv_StdShieldSuccess > Mv_Guard ...
			//前回がシールドに成功したガード（＝連続シールドの場合）　last_success_shield = 1

			// local is_first_sp_guard = (change_mv == "Mv_Guard" && Battle_Std.ChangeMoveCodeEx_CheckFlag(2,def_MC2_ShiledSuccess))? 0 : 1;
			local is_first_sp_guard = ( last_success_shield )? 0 : 1;
			local enemy_LastDmgChr = BMvCore.GetLastDamageCharaData( 0 ); // 0 そのままの相手を取得 1 殴られた相手の一番親を取得
			
			//CPUの突然成功するシールドとか連続シールドなど、ボタン操作なしでのシールド成功時
			local ikinari_shield = ( change_mv == "Mv_StdShield" || change_mv == "Mv_CroShield" || change_mv == "Mv_AirShield" )? 0 : 1;
			local last_is_shield_and_pass_cost = ( Battle_Std.ChangeMoveCodeEx_CheckFlag(7,def_MC7_PassShieldInitCost) && ( change_mv == "Mv_StdShield" || change_mv == "Mv_CroShield" || change_mv == "Mv_AirShield" ) )? 1 : 0;
			
			if( ikinari_shield )
			{
				Battle_Std.AddShieldedCancelCount( 1 );
			}
			
			BMvTbl.SetPattern(sp_guard_pat);
			//絵をすすめる
			if( BMvTbl.GetMvStatus().FrameID == 5 )
			{
				BMvTbl.JumpFrameID(10);
			}
			// ガードフロートシールド時に強制着地
			if( sp_guard_land )
			{
				BMvTbl.SetPosition( { y=0 } ); // 強制着地
				//ベクトルはシールド共通処理で初期化される
			}

			// XXX:何故か埋まっていることがあって次の行動で着地することあり
			local pos = BMvTbl.GetPosition();
			if( pos.y > 0 )
			{
				// _dpn("座標:"+pos.y );
				BMvTbl.SetPosition( { y=0 } ); // 着地ではなく0に浮かせるor接地させる
			}
			
			Battle_Std.CallBarrierEffect( 1 );
			
			BMvEff.GuardSP_Set( { val=3 } ); //SPガード状態の設定（シールド状態を継続）　val:3 背面攻撃もシールド可
			Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_Shield );
			
			if( is_first_sp_guard )
			{
				Battle_Std.TypeSE_Play({ type="シールド成功" });
				
				local useShieldParam = shieldParams.Std;
				
				switch( sp_guard_pat )
				{
				case def_PAT_Barrier_Std:
					useShieldParam = shieldParams.Std;
					break;
				case def_PAT_Barrier_Cro:
					useShieldParam = shieldParams.Cro;
					break;
				case def_PAT_Barrier_Air:
					useShieldParam = shieldParams.Air;
					break;
				}
			
				if( !ikinari_shield )
				{
					Battle_Std.CharaBattleActivity_Increment( useShieldParam.activity_suc_slot, useShieldParam.activity_suc );
				}
				
				//計算はバトルの方でやるはずなので不要…のはず
				//シールド成功回数/シールドを出した回数
				Battle_Std.CharaBattleActivity_Calc( {
					title=useShieldParam.activity_ave, 
					molecule=Battle_Std.CharaBattleActivity_Count(useShieldParam.activity_suc), denominator=(Battle_Std.CharaBattleActivity_Count(useShieldParam.activity))
				} );
				
				//月増加処理
				//すぐには増加させずにシールド成功行動が終わったら増加させる
				//（BCシルカンが急に飛んでこないようにするため）
				//また、オブジェクト側でフェイタルの被弾が確認できた場合、シールド失敗として月は減る
				BMvEff.CreateObject( { mvname="Mv_ShieldSuccessBonusMng" } );
				
				//赤ダメと実ダメもちょっと回復
				Battle_Std.FirstShieldSuccess();
				
				// 前の行動がシールドなんだけど、コスト処理は通ってない場合はコストを消費
				// _dpn("last_is_shield_and_pass_cost:"+last_is_shield_and_pass_cost);
				if( !last_is_shield_and_pass_cost )
				{
					Battle_Std.InitShieldCost();//シールド開始時のコスト系処理
				}
			}
			
			//シールドに成功
			BMvEff.AttackInfoString_Set({ word=def_AISW_SPGuard,} );
			
			//シールド成功のフラグ関係
			Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_ShiledSuccess ); // シールド成功
			Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_Enable_ShieldCounter ); // シールドカウンターが出せる
			
			local player_hit_stop = BMvTbl.GetHitStop();//防御側のヒットストップ
			local enemy_attack_hit_stop = 10;//攻撃側のヒットストップ（デフォは10にしておく）
			local set_stop = 0;
			
			// _dpn("player_hit_stop:"+player_hit_stop);
			
			// やりたいこと
			// シールドされても硬直差のベースはガード時と同じにする

			// 攻撃と防御のストップが同じ技の場合はOK
			//　　 攻/防 差　硬直差　　シールドとられ硬直差　張替えし硬直差
			// stop 6/ 6  0 ガードで-5F　→　シールドで+2F　-10F
			// stop 8/ 8  0 ガードで-5F　→　シールドで+2F　-10F
			// stop10/10  0 ガードで-5F　→　シールドで+2F　-10F

			// 違う場合もOK
			// stop 8/ 6  2 ガードで-7F　→　シールドで+0F　-12F
			// stop12/ 8  4 ガードで-9F　→　シールドで-2F　-14F
			// stop 6/ 8 -2 ガードで-3F　→　シールドで+4F　-8F

			
			// 防御側に設定するヒットストップ = 0
			// 攻撃側に設定するヒットストップ = 攻撃側のヒットストップ - 防御側のヒットストップ + 4 
			
			// 攻撃6F、防御8F
			// (6-8)で、-2F優秀、さらに+4F
			
			// シールドすると自分（防御側）のヒットストップは0になる
			// シールドされた側は、普段より-4Fの硬直差のヒットストップになるが、ヒットストップが4未満の攻撃だと差がなくなっていく
			
			if( enemy_LastDmgChr.isPlayer() )
			{
				if( enemy_LastDmgChr.push() )
				{
					//共通処理
					Battle_Std.SetShieldedPenalty();

					enemy_attack_hit_stop = BMvTbl.GetHitStop();//攻撃側のヒットストップ
					local excude_stop_adv = Battle_Std.MoveCodeEx.CheckFlag( 5, def_MC5_ExcludeHitStopFrameAdv_Shielded ); // シールドとられ時にヒットストップ差をなくす
					
					if( Def_Sys_FixStopAdv_ShieldSameTime && damage_impact_count >= 2 ) excude_stop_adv = 1; // ２つ以上が同時ヒットしててシールドのときはややこしいので硬直差統一
					
					// _dpn("enemy_attack_hit_stop:"+enemy_attack_hit_stop);
					
					set_stop = enemy_attack_hit_stop-player_hit_stop+4;
					if( excude_stop_adv && enemy_attack_hit_stop != player_hit_stop )
					{
						//シールドとられ時にヒットストップ差をなくす
						set_stop = 4; // 固定
					}
					if( set_stop < 0 )
					{
						set_stop = 0;
					}
					
					// _dpn("set_stop:"+set_stop);
					
					BMvTbl.SetHitStop(set_stop, _ValSet);
					
					if( BMvCore.GetTagStatus() == 0 )//パートナーの攻撃のとき
					{
						local partner = BMvCore.GetPertnerCharaData();//本体の方に相殺されを伝える
						if( partner.push() )
						{
							//呼び出し攻撃っぽかったときだけやる
							//MEMO:文字列のfindは動的にやるにはちょっと重そう
							if( BMvTbl.GetMvName().find("Mv_Skill_M_") == 0 || Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_CallPartnerSkill ) )
							{
								Battle_Std.SetShieldedPenalty();
							}
							partner.pop();
						}
					}
					enemy_LastDmgChr.pop();
				}
			}
			else
			{
				// _dpn("enemy_LastDmgChr isNotPlayer");
				//プレイヤー以外(オブジェクト関係)
				if( enemy_LastDmgChr.push() )
				{
					Battle_Std.SetShieldedPenalty();
					
					enemy_attack_hit_stop = BMvTbl.GetHitStop();//攻撃側のヒットストップ
					local excude_stop_adv = Battle_Std.MoveCodeEx.CheckFlag( 5, def_MC5_ExcludeHitStopFrameAdv_Shielded ); // シールドとられ時にヒットストップ差をなくす
					local pass_stop_player = Battle_Std.MoveCodeEx.CheckFlag( 5, def_MC5_ShieldedHitStop_PassToPlayer ); // シールドとられの硬直差の計算をプレイヤーまで伝える
					if( Def_Sys_FixStopAdv_ShieldSameTime && damage_impact_count >= 2 ) excude_stop_adv = 1; // ２つ以上が同時ヒットしててシールドのときはややこしいので硬直差統一
					
					set_stop = enemy_attack_hit_stop-player_hit_stop+4;
					if( excude_stop_adv && enemy_attack_hit_stop != player_hit_stop )
					{
						//シールドとられ時にヒットストップ差をなくす
						set_stop = 4; // 固定
					}
					if( set_stop < 0 )
					{
						set_stop = 0;
					}
					
					BMvTbl.SetHitStop(set_stop, _ValSet);
					
					// 上の処理と共通化できるとは思う
					// 厳密には少し怪しいかも（翡翠214A>214Cとやって、214Aの植物をシールドされたときは除外しないといけないので、uniqidを見ている）
					if( BtlPt.GetTagStatus() == 0 && BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) != 0 )//パートナーの攻撃のとき -1:通常 1:タッグのメイン 0:タッグのパートナー
					{
						local partner_player = BtlPt.GetPlayerCharaData(); //本体の方に相殺されを伝える
						if( partner_player.push() )
						{
							//呼び出し攻撃っぽかったときだけやる
							//MEMO:文字列のfindは動的にやるにはちょっと重そう
							if( BMvTbl.GetMvName().find("Mv_Skill_M_") == 0 || Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_CallPartnerSkill ) )
							{
								Battle_Std.SetShieldedPenalty();
							}
							partner_player.pop();
						}
					}
					
					if( pass_stop_player )
					{
						// プレイヤーにも伝える超例外的処理（低いときだけ）

						// 今のところ青子のJ[C]の飛び道具専用になってる
						local player = BMvCore.GetPlayerCharaData();
						if( player.push() )
						{
							_dpn("ヒットストップ加算");
							// なぜ3Fなのかというと、青子のJ[C]のエフェクトが3F遅れてヒットするため（要するに限定的な処理）
							// 他キャラでやるときはその性能に合わせて数値決め打ちにするしかない
							BMvTbl.SetHitStop(3, _ValAdd);//加算
							player.pop();
						}
					}
					
					Battle_Std.Recursive_SetShieldedPenaltyToParent(3);//1:子まで 2:孫まで 3:ひ孫まで
					
					// オブジェクトをシールドしたフレームに、プレイヤーがガードした情報が入っていたら
					if( Def_Sys_ShieldToObject_CheckEnemyHitStatus )
					{
						if( anno_flags&def_PP_IA_GuardPlayer ) // 確実にこのフレームにプレイヤーの攻撃をガードした記憶がある
						{
							_dpn("シールドしたとき、同時にプレイヤーの攻撃もガードしてるっぽい");
							local player = BMvCore.GetPlayerCharaData();
							if( player.push() )
							{
								local hs = BMvTbl.GetMvHitStatus();
								if( hs.Type & _HitType_Guard ) // このチェックだけだと、ヒット情報を伝える飛び道具も入ってくる
								{
									_dpn("ガード情報も入ってるので確実");
									Battle_Std.SetShieldedPenalty(); // プレイヤーにもペナルティやシールド返し可能フラグを付ける
									
									// 飛び道具側で計算済みなので、そのヒットストップと揃える
									// 揃えなかった場合、飛び道具のヒットストップが短いと、その分シールド返しが遅くなる
									// 処理を整理したいが、影響範囲を考えるとこれが一番丸い
									BMvTbl.SetHitStop(set_stop, _ValSet); // 飛び道具と同じストップに変更
								}
								
								player.pop();
							}
						}
					}
					
					enemy_LastDmgChr.pop();
				}
			}
			
			//シールドとった側のヒットストップは0にしたい
			//とられた側はどうでもいいけど、共通のほうがキャラ差はないかな…とは思う…難しい
			//攻撃側の停止が短いタイプの攻撃をシールドした場合、シールドとった側が少し有利になりがち（まぁOKとする）

			// _dpn("★攻撃e:"+enemy_attack_hit_stop+" 防御p:"+player_hit_stop+" c:"+(enemy_attack_hit_stop-player_hit_stop)+" set_stop:"+set_stop );
			// _dpn("★防御p:"+player_hit_stop+" 攻撃e:"+enemy_attack_hit_stop );

			//シールドしたら硬直ベクトルを固定にする(カウンターは時間停止F+Def_Sys_ShieldSuccessFrameが受付F
			//多段などだと後半は時間停止0なので、カウンターを出すのが難しくなる
			BMvEff.SetBoundSt( { settime = Def_Sys_ShieldSuccessFrame } );
			
			BMvTbl.SetHitStop(0, _ValSet); // 自分のヒットストップは0F固定　※XXX:これを呼ぶと、次回の各種相殺の時間停止が1Fズレる
			
			local shieldCounterInputFrame = Def_Sys_ShieldCounterInputFrame;
			//シールドによる時間停止
			//初回シールドのみ
			if( def_FL_ShieldStopTime && is_first_sp_guard )
			{
				//メルブラとかの暗転バグに繋がる
				BMvEff.SetStopTime( { time=def_FL_ShieldStopTime+1, stopme=2 } );//+1することで格ゲーのフレームと揃う
				BMvEff.SetPlayerTimer( { muteki_dage=1, muteki_nage=1, muteki_dageX=1, muteki_nageX=1 } );//時間停止中は進まないのでこれでよさそう？
				
				//時間停止時は少し暗くする
				BMvEff.CutInProc_Set( { time=[0,def_FL_ShieldStopTime,4], cutin_mv="", bgtype=1 } ); // 
				
				local shieldedCancelCount = BMvTbl.GetPP(def_PP_ShieldedCancelCount);
				// _dpn("shieldedCancelCount:"+shieldedCancelCount);
				if( shieldedCancelCount > 0 )
				{
					Battle_Std.SetInstantCharaCameraFocus( 20, 1.0 + 0.1 * shieldedCancelCount );
				}
				if( Def_Sys_ShieldCounterFrameCheckType )
				{
					shieldCounterInputFrame = Def_Sys_ShieldCounterInputFrame;
				}
				else
				{
					shieldCounterInputFrame = Def_Sys_ShieldCounterInputFrame+def_FL_ShieldStopTime; //時間停止分を加算した値に変更
				}
				
				//シールドで時間停止すると、ヒットでのprio変更が完了する前にとまってしまうので、パートナーキャラが手前になってしまう
				//相手が手前になる→こっちが奥になる→（時間停止）→パートナーをプレイヤーより奥にする、という流れだと思われる
				//とりあえず奥側に設定して対策する
				if( BMvCore.GetTagStatus() == 1 ) //-1:通常 1:タッグのメイン 0:タッグのパートナー
				{
					local partner = BMvCore.GetPertnerCharaData();
					if( partner.push() )
					{
						BMvTbl.SetPrio(_CharaPrio_Far );
						partner.pop();
					}
				}
			}
			
			if( BCMDTbl.CheckPosState( _PosState_Air ) )
			{
				Battle_Std.InitVector();//シールドしてノックバックするな

				//のぼりでシールドとって即着地がギャグなので浮くようにしたいが、超多段の攻撃をシールドするとどんどん浮いてしまう
				//シールドとったときの高さで浮くベクトルを変えて、ざっくり硬直を揃える
				local pos = BMvTbl.GetPosition();
				//-50  低空ライン
				//-300 高空ライン
				local use_ypos = pos.y;
				local min_y = -100*128;
				local max_y = -250*128;
				if( use_ypos > min_y ) use_ypos = min_y; 
				if( use_ypos < max_y ) use_ypos = max_y; 
				
				local par = 100 - ( (use_ypos - min_y) * 100 / (max_y-min_y));
				if( par < 0 ) par = 0;
				if( par > 100 ) par = 100;
				local y_vec = -2000 * par /100;
				// _dpn("高さ:"+pos.y/128+" use_ypos:"+use_ypos/128+" par:"+par+" y_vec:"+y_vec );
				
				BMvTbl.SetVector( { y=y_vec, addy=200, flags=_Vector_Normal } );
			}
			else
			{
				Battle_Std.InitVector();//シールドしてノックバックするな
			}
			
			if( BMvTbl.GetPP(def_PP_ShieldCounterMng) == 0 )
			{
				BMvEff.CreateObject( { mvname="Mv_ShieldCancelChecker" } );
				BMvTbl.SetPP(def_PP_ShieldCounterMng,1);//生成済み
			}
			BMvTbl.SetPP(def_PP_ShieldCounterInputFrame,shieldCounterInputFrame);
			
			//ラストアークの条件だったら
			if( Def_Sys_MvFinalizeShieldLastArc && BMvEff.Liberate_Get() == _SpGaugeMode_OverLiberate && !Battle_Std.CharaisKO() )
			{
				BMvEff.SetBoundSt( { settime = 1 } );//0にはできない
				BMvTbl.SetHitStop(0, _ValSet);
				BMvTbl.SetLP(7,1); // ラストアーク条件を満たしたら1
				Battle_Std.MoveCodeEx.DelFlag( 4, def_MC4_Enable_ShieldCounter ); // シールドカウンターが出せないようにする
				Battle_Std.InitVector();//1F動くのがあれなので停止
			}
		}
		else
		{
			//シールドではない通常のガード
			//失敗シールドガードも入る
			Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_NoShieldGuard ); // チュートリアルなどでシールドと区別する用
			
			//連続ガード時間がのびてきたときの救済措置
			//ガードした技の数で処理をする
			if( Def_Sys_LongTimeGuard_ForSafety )
			{
				//
				local action_id = 0;
				local enemy = BMvCore.GetLastDamageCharaData( 0 ); // 殴られたものそのまま
				if( enemy.push() )
				{
					if( Battle_Std.MoveCode.CheckFlag( def_MC_FireBall ) ) // 行動コード(飛び道具)
					{
						action_id = BMvTbl.GetLP(def_LP_ActionID);
					}
					else
					{
						action_id = BMvTbl.GetPP(def_PP_ActionID);//適当。厳密にはおかしいけど、この処理全体が救済措置なのでいい
					}
					enemy.pop();
				}

				//保険処理
				if( action_id <  0 ) action_id =  0;
				if( action_id > 30 ) action_id = 30;

				local action_id_flag = (1<<action_id);//フラグ化
				Battle_Std.PP_AddFlag(def_PP_GuardActionID, action_id_flag );
				local guard_action_id = BMvTbl.GetPP(def_PP_GuardActionID);
				
				local guard_id_count = 0;//ざっくり何技ガードしたか。最大31個で、疎らなガードだと正確には取得できない。
				for( local i=0; i<31; i++ )
				{
					if( guard_action_id&(1<<i) ) guard_id_count++;
				}
				
				//減らすガード硬直を決定
				local add_frame = 0;
				if( guard_id_count >= 25 )
				{
					add_frame = -6;
				}
				else if( guard_id_count >= 20 )
				{
					add_frame = -4;
				}
				else if( guard_id_count >= 15 )
				{
					add_frame = -2;
				}

				if( add_frame < 0 )
				{
					BMvEff.SetBoundSt( { addtime = add_frame } );//ガード硬直を減らせば永久連ガは減らせる（なくなりはしない）
				}

				// _dpn("ガード:"+action_id+" flag:"+action_id_flag+" -> "+guard_action_id+" 個数:"+guard_id_count+" 硬直減:"+add_frame );
			}
			
			if( bs_power&def_BS_Pow_LV1 )
			{
				// _dpn("A");
				Battle_Std.TypeSE_Play({ type="ガード弱" });
			}
			else if( bs_power&def_BS_Pow_LV0 )
			{
				// 声無し
			}
			else if( bs_power&def_BS_Pow_LV3 )
			{
				// _dpn("C");
				Battle_Std.TypeSE_Play({ type="ガード強" });
			}
			else
			{
				//def_BS_Pow_LV2 == 0 なのでフラグのチェックは絶対に0になるからelseに置く
				// _dpn("B");
				Battle_Std.TypeSE_Play({ type="ガード中" });
			}
		}
	}
	function Update_Std()
	{
		//地上状態では符号が反転しないようにする
		if( BMvTbl.CheckPosState( _PosState_Ground  ) )
		{
			//今プラスのベクトルで、次のフレームがマイナスベクトルか？
			local vec = BMvTbl.GetVector( { flags=_Vector_Bound });
			if( (( vec.x<0 ) && ( (vec.x + vec.addx)>=0 )) || (( vec.x>0 ) && ( (vec.x + vec.addx)<=0 )) )
			{
				BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_Bound } );
			}
		}
		
		// ガード中にのぼりジャンプ攻撃がきたら上段にする
		// これを1にすると、結構緩めのジャンプ攻撃も上段になってしまい、影響が大きいので一応注意
		// 立ちガードの時のみにしたので少しはマシになったが、まだちょっとゆるいかも
		if( Def_Rule_GuardNoboriTyudanLimit )
		{
			local isStand = BCMDTbl.CheckPosState( _PosState_Stand ); // 定数がかえる
			local bs = BtlMvStd.GetBoundStatus();
			if( isStand && bs.isBound && bs.BoundTime <= 1 )
			{
				// ヒットストップ(12〜20)+8Fジャンプ攻撃ぐらいチェックする
				// ガード硬直中に相手のジャンプ攻撃がきたらのぼり中段のチェックをする
				local enemy = BMvCore.GetEnemyCharaData();
				if( enemy.push() )
				{
					local nobori_airatk = Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_SlowRocketeerAirAtk ); // のぼりジャンプ攻撃？
					local mvs = BMvTbl.GetMvStatus();
					
					if( nobori_airatk && mvs.MvCount <= 1 )
					{
						BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_GuardCrouch, time=18, flag=_ClearFlag_ChangeMv } );
						if( Def_Dbg_AirAtkFlag ) _dm("ガード後ののぼり中段の上段化(18F)");
					}

					enemy.pop();
					
				}
			}
		}
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus(); // ステータス取得
		
		//空中ガード中に着地したら立ちガードポーズに移行
		if( mvs.isLanding )
		{
			BMvTbl.SetPattern(def_PAT_GuardS);
			//今の行動がシールド成功のガードだったらシールドにする
			if( Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_ShiledSuccess ) ) // シールド成功
			{
				BMvTbl.SetPattern(def_PAT_Barrier_Std);
				BMvTbl.SetLP(9,10); // シールド成功の記憶 10:立ちシールド 20:しゃがみシールド 30:空中シールド
			}
			//
			//Yベクトルだけ初期化（着地・念のため）
			BMvTbl.SetVector( { y=0, addy=0, flags=_Vector_Normal|_Vector_Div|_Vector_Bound|_Vector_Keep|_Vector_DivKeep } );
			//着地エフェクトを呼ぶ
			BMvEff.CreateObject( { datatype=1, x=0, y=0, start_pat=20, flags=_Position_ToolShift } );
			
			// ガードフロートからの着地だったら打撃無敵を削除
			if( BMvTbl.GetLP(8) ==1 ) // 無敵をセットされていた
			{
				// 打撃無敵を削除
				BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0 } );
			}
			
			// 空中ガードの着地硬直をへらす
			if( Def_Sys_ReduceTikigaLandDelayFrame )
			{
				local delayf = BMvEff.SetBoundSt( { addtime = 0 } );
				local set_delayf = delayf - Def_Sys_ReduceTikigaLandDelayFrame;
				if( set_delayf < 0 ) set_delayf = 0;
				if( delayf >= 2 && set_delayf < 2 ) set_delayf = 2;//最低保障
				BMvEff.SetBoundSt( { settime = set_delayf } );
				_dpn("着地硬直:"+delayf+" -> "+set_delayf );
			}
		}
	}
	function Finalize_Std() // 
	{
		//状態の移行だけ行う
		BtlMvStd.SetGuardFinalize();
		//print("SetGuardFinalize()");
		
		local shield_success_code = BMvTbl.GetLP(9); // シールド成功の記憶 10:立ちシールド 20:しゃがみシールド 30:空中シールド
		// _dpn("shield_success_code:"+shield_success_code);
		//シールド成功すると少しまってFinalizeしてシールド行動へ戻ります
		switch( shield_success_code )
		{
		case 10:
			BMvTbl.SetNextMoveTable( "Mv_StdShieldSuccess" );
			break;
		case 20:
			BMvTbl.SetNextMoveTable( "Mv_CroShieldSuccess" );
			break;
		case 30:
			BMvTbl.SetNextMoveTable( "Mv_AirShieldSuccess" );
			break;
		}
		
		//ラストアークの予約を何よりも優先処理
		if( Def_Sys_MvFinalizeShieldLastArc && BMvTbl.GetLP(7)==1 )
		{
			BMvTbl.SetNextMoveTable( "Mv_LastArc" );
		}
		BMvTbl.SetFinalizeCode(0);
	}
	function LastUpdate_Std() // 
	{
		if( Def_Rule_GroundGuardSlideKeep )
		{
			//地上状態では慣性を残す
			if( BMvTbl.CheckPosState( _PosState_Ground  ) )
			{
				local vec = BMvTbl.GetVector( { flags=_Vector_Bound } );
				BMvTbl.SetVector( { x=vec.x, addx=-vec.x/10, flags=_Vector_DivKeep } );
				// print("\n vec.x:"+vec.x);
				// MEMO:_Vector_DivKeepで残しているので、ジャンプ時にダッシュジャンプ扱いになって慣性がのるバグあり
				// BoundDiv的なものがないとダメそう
			}
		}		
		
		// ガードフロートで浮いて、空中だったら空ガ不能技でハメられないように無敵時間をセットする
		if( BMvTbl.GetLP(8) ==1 && BMvTbl.CheckPosState( _PosState_Air ) ) // ガードフロートで無敵をセットされていた,空中だった
		{
			// 抜けるときに少し打撃無敵をつける（ハメ回避）
			BMvEff.SetPlayerTimer( { muteki_dage=def_FL_ModoriGuardFloatDagekiMuteki, muteki_dageX=def_FL_ModoriGuardFloatDagekiMuteki } );
		}
		
		BtlMvStd.ClearGuard(); // 状態解除
		Battle_Std.Reversal.SetTime(); //リバーサル受付＋判定オブジェクト生成
		
	}
}

// 失敗シールド＆シールド返し不可エフェクトの管理
// シールド失敗時にシールドエフェクトを別PATに置き換える処理
// 力技で作っている感じが結構あるのがややネック
// 専用エフェクトのほうがいいかもしれん
local pat_num_Grp_Hit_ShieldMissGuard = BMvEff.GetPatternNum( { datatype=1, pat="Grp_Hit_ShieldMissGuard" } );
local pat_num_Grp_Hit_GuardNgEx = BMvEff.GetPatternNum( { datatype=1, pat="Grp_Hit_GuardNgEx" } );
local pat_num_Grp_Hit_GuardNgExLimit = BMvEff.GetPatternNum( { datatype=1, pat="Grp_Hit_GuardNgExLimit" } );

Std_MoveTable.Mv_ShieldGuardEffect <-
{
	function Init_Std() : (pat_num_Grp_Hit_ShieldMissGuard, pat_num_Grp_Hit_GuardNgEx, pat_num_Grp_Hit_GuardNgExLimit)
	{
		// BMvTbl.SetLP(0,0); // 生成時に指定　軽いverかどうか
		// BMvTbl.SetLP(1,0); // 生成時に指定　パーティクル数
		
		local is_limit = BMvTbl.GetLP(0);
		local pat_num = BMvTbl.GetLP(1);
		
		local super_shield = 0; // 1:初回 2:2回目以降

		local shield_is_miss = 0;
		local player = BtlPt.GetPlayerCharaData(); // タッグを考慮したプレイヤー取得
		if( player.push() && player.isPlayer() )
		{
			// _dm("攻撃側＆プレイヤー")
			
			// 相手がシールド返しできないときはエフェクトを変更する
			if( Battle_Std.CheckShieldedCencel()==0 )
			{
				// シールドキャンセルできないタイミング
				// これだけだとあらゆるシーンがヒットしてしまうので、ムーンスキルと無敵の必殺技、Bシルカンのみを対象とする
				
				local mvcode = BMvTbl.GetMoveCode();
				// このチェックをしないと設置をシールドされたときに相手が無敵技とか出してるとダメになる
				local is_shielded_move = (mvcode&def_MC_Shielded)? 1 : 0; // シールドを取られたMV
				if( is_shielded_move )
				{
					local mvaction = BMvTbl.GetMvAction();
					local mvname = BMvTbl.GetMvName();
					
					local is_bc_skill = ( mvcode&def_MC_Skill && (mvcode&def_MC_BCAction || mvaction==def_MVA_BCSkill) )? 1 : 0;//ムーンスキル
					local is_sp_skill = ( mvcode&def_MC_Skill && (mvcode&def_MC_SPAction || mvaction==def_MVA_SPSkill || mvaction==def_MVA_LASkill ) )? 1 : 0;//AD・LA
					local is_muteki_action = ( (mvcode&def_MC_Skill || mvcode&def_MC_Atk) && Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_Muteki ) ); // 無敵の通常技or必殺技
					local is_b_sc = ( mvname == "Mv_ShieldDive" || mvname == "Mv_ShieldDiveAir" ); // Bシルカン
					local is_blast = ( mvname == "Mv_Blast" ); // 開放
					
					if( is_bc_skill || is_muteki_action || is_b_sc || is_sp_skill || is_blast )
					{
						super_shield = 1; // シールド返しできないエフェクトに
					}
				}
			}
			
			// 相手が失敗シールドのときはエフェクトを変更する
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				shield_is_miss = BMvTbl.GetLPEx(1,6); // シールド失敗してる模様
				
				// enemyをpushしたついでに、シールド返しできないエフェクトの初回かどうかでエフェクトの見た目を変える
				if( super_shield )
				{
					local e_mvname = BMvTbl.GetMvName();
					if( e_mvname == "Mv_Guard" )
					{
						local isFirstShield = BMvTbl.GetLPEx(1,5); // 初回シールドかどうか
						// _dpn("isFirstShield:"+isFirstShield);
						if( !isFirstShield )
						{
							super_shield = 2; // 2回目以降は小さめのものにする
						}
					}
				}
				enemy.pop();
			}
			player.pop();
		}
		
		if( shield_is_miss ) // 失敗シールドだった
		{
			BMvTbl.SetPattern( pat_num_Grp_Hit_ShieldMissGuard );
			if( !is_limit )
			{
				Battle_Std.CallShieldPar( { num=pat_num, pat=189 } );
			}
		}
		else if( super_shield ) // シールド返しできない技をシールドした
		{
			BMvTbl.SetPattern( (super_shield==1)? pat_num_Grp_Hit_GuardNgEx : pat_num_Grp_Hit_GuardNgExLimit );
			if( !is_limit )
			{
				Battle_Std.CallShieldPar( { num=pat_num, pat=190 } );
			}
		}
		else // 通常シールド
		{
			if( !is_limit )
			{
				Battle_Std.CallShieldPar( { num=pat_num, pat=188 } );
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}
	
Std_MoveTable.Mv_ShieldSuccessBonusMng <-
{
	function Init_Std() // 
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		
		BMvTbl.SetLP(0,0); // 0:Mv変化待機 1:シールド成功以外に移ったので数F待機 -1:フェイタルして失敗として抜ける
		BMvTbl.SetLP(1,0); // 待機するフレームカウンタ
	}
	function FrameUpdate_Std()
	{
		if( BMvTbl.GetLP(0) == 0 )
		{
			//シールド成功関係のMvでいる限り生存する
			if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) == 0 )
			{
				local player = BMvCore.GetPlayerCharaData();
				if( player.push() )
				{
					local is_shield_success = Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_ShiledSuccess );
					local is_fatal_counter = BMvTbl.DamageFlag_Func( def_DF_FatalCounter, _ValCheck ); // 0 or 1
					
					player.pop();
					
					if( is_shield_success )
					{
						// _dpn("別の行動にきた");
						BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player, setid=1 } );
					}
					else if( is_fatal_counter )
					{
						// シールド成功後にシールドはりっぱなしにしてて、そこでフェイタル被弾した
						BMvTbl.SetLP(0,-1);
						BMvTbl.SetFinalize();
						return; // 失敗として抜ける
					}
					else
					{
						BMvTbl.SetLP(0,1);
					}
				}
			}
		}
		else
		{
			//シールド成功以外に移ったので少しまってから終了して月を増やす
			local count = BMvTbl.AddLP(1,1);
			if( count >= 4 )
			{
				//少し余裕をもった時間待機して抜ける
				BMvTbl.SetFinalize();
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		local shield_success_st = BMvTbl.GetLP(0);
		if( shield_success_st == -1 )
		{
			// フェイタルで抜けたときは増やさない
			// というか減らす
			tDDC.Moon_AddValue( Def_ShieldFatalDamageMoonAdd );// シールド失敗　ムーンドライブ中も減る
		}
		else
		{
			Battle_Std.Moon_AddValue( Def_ShieldMoonAdd );//シールド成功
		}
	}
}

//シールドカウンターの受付猶予及びシールド返しの受付猶予の管理
//シールドに成功すると、def_PP_ShieldCounterInputFrameがに値が入りつつ生成される
//すでに生成済みのときは生成されないで今あるオブジェクトを使い回す
Std_MoveTable.Mv_ShieldCancelChecker <-
{
	function Init_Std() // 
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		local frame = BMvTbl.GetPP(def_PP_ShieldCounterInputFrame);
		if( mvs.CallCount == 1 )
		{
			if( Def_Sys_ShieldCounterFrameCheckType )
			{
				local player = BMvCore.GetPlayerCharaData();
				if( player.push() )
				{
					local pmvs = BMvTbl.GetMvStatus();
					player.pop();

					// 時間停止中はカウントを進まないようにする
					if( pmvs.isUpdate )
					{
						BMvTbl.AddPP(def_PP_ShieldCounterInputFrame,-1);
					}
				}
			}
			else
			{
				BMvTbl.AddPP(def_PP_ShieldCounterInputFrame,-1);
			}
		}
		
		if( frame == 0 )
		{
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				//フラグがたってたら消す
				Battle_Std.MoveCodeEx.DelFlag( 4, def_MC4_Enable_ShieldCounter );//シールドカウンターを出せなくする
				player.pop();
			}
		}
		
		//相手側の猶予+1Fして両者の猶予を揃えるため少し長めに生存する
		if( frame <= -3 )
		{
			BMvTbl.SetFinalize();
		}
		
		//B+Cの検知を厳密にやる
		if( Def_Sys_BandCDoujiCheck )
		{
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				Battle_Std.StartBandCDoujiCheck( "B+C", 1 );//正確なB+Cが検知されたらフラグを立てる　暗転中なので強制フラグオン
				player.pop();
			}
		}
		// _dpn("チェック中..."+BMvTbl.GetPP(def_PP_ShieldCounterInputFrame) );
	}
	function Finalize_Std()
	{
		BMvTbl.SetPP(def_PP_ShieldCounterMng,0);
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_GroundUkemi <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BtlMvStd.SetGroundUkemiStatus();
	}
	function Update_Std() // 
	{
	}
	function Finalize_Std() // 
	{
		//状態の移行だけ行う
		BtlMvStd.SetGroundUkemiFinalize();
	}
	function LastUpdate_Std() // 
	{
	}
}

// ----------------------------------------------------------------------------
// 基本アクション
// ----------------------------------------------------------------------------
//全キャラほぼ共通部分（個別に変えたい場合はキャラ別で同名Mv作っておく）---------------------------------------------------------------

local val_StdTyouhatsuType = chrparam.Get( { type="立ち挑発タイプ", chrnum=_ChrNo } ); 

local appeal_finalize = function( param={} )//tyouhatsuType, fincode, jumpid )
{
	// 通常時と、トレーニング時に挑発を行う→通常時のみに変更
	// チュートリアルとミッションは除外
	local stage_st = BMvTbl.GetMvStageStatus().IsTrainingBattle();// 1-トレーニング 2-チュートリアル 3-ミッション
	if( stage_st == 0 )
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		//挑発再生チェック
		switch( param.type )
		{
		case 0: // 挑発無し
			break;
		case 1: // 挑発あり・モーションあり
			if( BMvTbl.GetPP(def_PP_TMP0) >= 0 )
			{
				if( s.MvCount>def_FL_NeutralWaitMin && s.MvCount%def_FL_NeutralWaitStep==0 && BMvTbl.GetFinalizeCode() == 0 ) //振り向き中は反応しないとか
				{
					Battle_Std.CallSkillSoonCache( param.jumpid, 10 );//先に予約だけしておく
					if( BMvEff.Random_Limit(100) < 15 ) //発動確率
					{
						BMvTbl.SetFinalize(param.fincode); // 立ち待機アニメへ
						BMvTbl.SetPP(def_PP_TMP0,-10); // 10F後に挑発を行う予約
					}
				}
			}
			else
			{
				local left_frame = BMvTbl.AddPP(def_PP_TMP0,1);
				if( left_frame >=0 )
				{
					BMvTbl.SetFinalize(param.fincode); // 立ち待機アニメへ
				}
			}
			break;
		case 2: // 挑発あり・モーション無し ※暫定未実装
			// if( Def_Dbg_NoPlayUpsetSE == 0 ) Battle_Std.TypeSE_Play({ type="挑発" });
			break;
		}
	}	
	
	
}

Std_MoveTable.Mv_Neutral <- // ニュートラル待機
{
	function Init_Std() // 
	{	
		BMvTbl.SetPattern(def_PAT_Neutral);
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetFinalizeCode(0); //初期状態が0でない＋GetFinalizeCodeで分岐してるので初期化
		BMvTbl.SetMoveableFlag( { move=1, time=255, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		
		BMvTbl.SetPP(def_PP_TMP0,0); // 挑発カウンタ
		
		BMvTbl.SetPosition( { y=0 } ); // 保険処理で地上につける
		
		//パートナーも地上やられやダウンのあとはここに来てしまうのでパートナーのMVに移動
		local tagStatus = BMvCore.GetTagStatus();//-1:通常 1:タッグのメイン 0:タッグのパートナー
		if( tagStatus == 0 )
		{
			BMvTbl.SetFinalize(1024);
		}
	}
	function FrameUpdate_Std() : (appeal_finalize, val_StdTyouhatsuType)
	{
		BMvTbl.SetMoveableFlag( { move=1, time=32, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); // ループに含める行動可能
		
		if( BMvTbl.CheckFurimuki() ) // 振り向きチェック
		{
			BMvTbl.SetFinalize(256); // コード256を振り向きとしてFinalize
		}
		else
		{
			appeal_finalize( { type=val_StdTyouhatsuType, fincode=512, jumpid=512 } );//挑発時はFinalize(PP使用)
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Furimuki_S"], [512,"Mv_Neutral_Appeal"], [1024,"PatMv_Neutral"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.PatMv_Neutral <-
{
	function Init_Std()
	{
		BMvTbl.SetPattern(def_PAT_Neutral);//使い回しテスト
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetFinalizeCode(0); //初期状態が0でない＋GetFinalizeCodeで分岐してるので初期化
		BMvTbl.SetMoveableFlag( { move=1, time=255, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		
		BMvTbl.SetPosition( { y=0 } ); // 保険処理で地上につける
	}
	function FrameUpdate_Std()
	{
		BMvTbl.SetMoveableFlag( { move=1, time=32, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); // ループに含める行動可能
		
		if( BMvTbl.CheckFurimuki() ) // 振り向きチェック
		{
			BMvTbl.SetFinalize(256); // コード256を振り向きとしてFinalize
		}

		BtlPt.NoRenderPartner_EnemySPAction(); //自分と相手の超技中は消す
	}
	function Finalize_Std()
	{
		Battle_Std.SwitchNextMoveTable("PatMv_Neutral", [256,"PatMv_Furimuki_S"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_Neutral_Appeal <- // 挑発
{
	function Init_Std() // 
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.DataPattern != def_PAT_Neutral ) BMvTbl.SetPattern(def_PAT_Neutral);
		BMvTbl.JumpFrameID( 512 );
		if( Def_Dbg_NoPlayUpsetSE == 0 ) Battle_Std.TypeSE_Play({ type="挑発" });
		
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
	}
	function Update_Std() // 
	{
		if( BMvTbl.IsCpu()==0 ) // プレイヤーの時
		{
			//毎フレーム行動可能で更新
			BMvTbl.SetMoveableFlag( { move=1, time=2, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		}
		
		if( BMvTbl.CheckFurimuki() ) // 振り向きチェック
		{
			BMvTbl.SetFinalize(256); // コード256を振り向きとしてFinalize
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Furimuki_S"] ); //デフォ,[code,mv]...
	}
}

local footstep_senum_array = [
	chrparam.Get( { type="足音Ａ_ＳＥ番号", chrnum=_ChrNo } ),
	chrparam.Get( { type="足音Ｂ_ＳＥ番号", chrnum=_ChrNo } ),
];

//Param0が10の時足音を再生する
Std_MoveTable.Mv_Null_PlayFootstepSE <- 
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_NoRender|_ObjFlags_EraseParentPatChange } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetLP(0,0);
	}
	function FrameUpdate_Std() : ( footstep_senum_array)
	{
		local my_st = BMvTbl.GetMvStatus();
		if( my_st.CallCount!=0 )
		{
			return;
		}
		
		local player = BMvCore.GetPlayerCharaData();
		if( player.isdone() )
		{
			local playtiming = 0;
			if( player.push() )
			{
				if( Battle_Std.GetUpdateParam0() == 10 )
				{
					playtiming = 1;
				}
				player.pop();
			}

			if( playtiming==1 )
			{
				local setype = BMvTbl.GetLP(0);
				BMvTbl.SetLP(0, 1-setype ); // 0 1 0 1 ...
				local use_senum = footstep_senum_array[ setype%footstep_senum_array.len() ];
				if( use_senum != -1 )
				{
					if( typeof use_senum == "array" )
					{
						BSound.SE_Play( { type=use_senum[0], num=use_senum[1] } );
					}
					else
					{
						BSound.SE_Play( { type=_SeType_Normal, num=use_senum } );
					}
				}
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

local walk_vectorar = chrparam.Get( { type="歩きベクトル", chrnum=_ChrNo } );
local walk_f_vector = { start=walk_vectorar[0], loop=walk_vectorar[1] };
local walk_b_vector = { start=walk_vectorar[2], loop=walk_vectorar[3] };

Std_MoveTable.Mv_Walk_F <- // 前進
{
	function Init_Std() // 
	{
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Walk_F);
		Battle_Std.Call_FootStepSE(); // 足音再生監視オブジェクト
	}
	function FrameUpdate_Std() : (walk_f_vector)
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount == 0 )
		{
			BMvTbl.SetVector( { x=walk_f_vector.start, y=0, addx=0, addy=0, flags=_Vector_Normal } );
		}
		else if( mvs.MvCount == 4 )
		{
			BMvTbl.SetVector( { x=walk_f_vector.loop, y=0, addx=0, addy=0, flags=_Vector_Normal } );
		}
		
		BMvTbl.SetMoveableFlag( { move=1, time=32, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); // ループに含める行動可能
		if( BMvTbl.CheckStickHold( (1<<0) ) || !BMvTbl.CheckStickHold( (1<<6) ) )
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_WalkStop_F" );
	}
}

Std_MoveTable.Mv_WalkStop_F <- // 前進停止
{
	function Init_Std() // 
	{
		Battle_Std.JumpFrameIDEX(256, def_PAT_Walk_F, 0); //設定FrameID, 上書きPattern, 失敗時FinalizeCode
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}		

Std_MoveTable.Mv_Walk_B <- // 後退
{
	function Init_Std() // 
	{
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Walk_B);
		Battle_Std.Call_FootStepSE(); // 足音再生監視オブジェクト
	}
	function FrameUpdate_Std() : (walk_b_vector)
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount == 0 )
		{
			BMvTbl.SetVector( { x=walk_b_vector.start, y=0, addx=0, addy=0, flags=_Vector_Normal } );
		}
		else if( mvs.MvCount == 4 )
		{
			BMvTbl.SetVector( { x=walk_b_vector.loop, y=0, addx=0, addy=0, flags=_Vector_Normal } );
		}
		
		BMvTbl.SetMoveableFlag( { move=1, time=32, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); // ループに含める行動可能
		if( BMvTbl.CheckStickHold( (1<<0) ) || !BMvTbl.CheckStickHold( (1<<4) ) )
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_WalkStop_B" );
	}
}

Std_MoveTable.Mv_WalkStop_B <- // 後退停止
{
	function Init_Std() // 
	{
		Battle_Std.JumpFrameIDEX(256, def_PAT_Walk_B, 0); //設定FrameID, 上書きPattern, 失敗時FinalizeCode
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

local cutin_fade = function( param={} )
{
	local frame_ar = param.frame;
	//frame_ar [10,40,10];
	local mvs = BMvTbl.GetMvStatus();
	// _dpn("mvs.MvCount:"+mvs.MvCount);
	if( mvs.MvCount <= 0 )
	{
		BMvTbl.SetDrawAlpha( { val=0, time=255, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
	}
	else if( mvs.MvCount <= frame_ar[0] )
	{
		//フェードイン
		local alpha = BMvTbl.GetDrawAlpha();
		alpha += 255 / frame_ar[0];
		if( alpha > 255 )
		{
			alpha = 255;
		}
		BMvTbl.SetDrawAlpha( { val=alpha, time=255, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
	}
	else if( mvs.MvCount >= frame_ar[0]+frame_ar[1] )
	{
		//フェードアウト
		local alpha = BMvTbl.GetDrawAlpha();
		alpha -= 255 / frame_ar[2];
		if( alpha < 0 )
		{
			alpha = 0;
			BMvTbl.SetFinalize(0);
		}
		BMvTbl.SetDrawAlpha( { val=alpha, time=255, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
	}
}

// カットインの絵だけ
// 超技
Std_MoveTable.Mv_CutinGrp <- //カットイン スクロールの影響を受けない
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPattern(def_PAT_IWCutinGrp);
		BMvTbl.SetPosition( { x=0, y=0 } );
		// _dm("カットイン呼ばれ");
		
		BMvEff.SetDefaultExtendedEffectDrawing( 0 );//追加効果描画設定
		BMvTbl.SetPrio( _CharaPrio_Parent_BG  );//BG手前
	}
	function Update_Std() : (cutin_fade)
	{
		cutin_fade( { frame=[10,70,10], } );
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

// カットインの絵だけ　使わない

Std_MoveTable.Mv_IWXCutinGrp <- //カットイン スクロールの影響を受けない
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPattern(def_PAT_IWCutinGrp);
		BMvTbl.SetPosition( { x=0, y=0 } );
		//_dm("カットイン呼ばれ");
		
		BMvTbl.SetPrio( _CharaPrio_Near );//一番手前
	}
	function Update_Std() : (cutin_fade)
	{
		cutin_fade( { frame=[10,70,10], } );
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

// これは絵だけじゃない、表示して他をとめる
//インフィニットワースイグジスト
Std_MoveTable.Mv_IWXCutin <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPattern(def_PAT_IWXCutinGrp);
		BMvTbl.SetPosition( { x=0, y=0 } );
		//_dm("カットイン呼ばれ");
		
		local eff = BMvEff.CreateObject( { datatype=1, start_pat=998 }); //黒い板を呼ぶ
		if( eff.IsDone )
		{
			BMvCore.PushCharaData( eff ); //	
				BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
				BMvTbl.SetPosition( { x=0, y=-360*128 } );			
			BMvCore.PopCharaData(); //	
		}


		BMvEff.SetStopTime( { time=50, stopme=2 } ); //自分以外をとめてしまう
	}
	function FrameUpdate_Std()
	{
		//print("\n.");
	}
	function Finalize_Std()
	{
		//print("\n -------------------☆");
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		//
	}
}



// EXカットインの絵だけ
Std_MoveTable.Mv_EXCutinGrp <- //カットイン スクロールの影響を受けない
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPattern(def_PAT_EXCutinGrp);
		BMvTbl.SetPosition( { x=-220*128*BMvTbl.GetMuki(), y=0 } );

		BMvEff.SetDefaultExtendedEffectDrawing( 0 );//追加効果描画設定
		BMvTbl.SetPrio( _CharaPrio_Parent_BG );
		
		// //大きくズラして開始して勢いよく入ってくる
		local shift = 500*128;
		local pow = shift * 15 / 100;
		BMvTbl.SetPosition( { x=-(shift+95*128)*BMvTbl.GetMuki(), y=0, flags=_Position_Add } );
		BMvTbl.SetVector( { x=128, flags=_Vector_Normal } );
		BMvTbl.SetVector( { x=pow, addx=-pow/15, flags=_Vector_Div } );
	}
	function Update_Std() : (cutin_fade)
	{
		cutin_fade( { frame=[5,40,8], } );
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}			
}

local pat_num_Eff_SpSpark = BMvEff.GetPatternNum( { datatype=1, pat="Eff_SpSpark" } );//ADカットイン

//暫定カットイン処理、多分未使用
Std_MoveTable.Mv_CutinObject <- //カットイン スクロールの影響を受けない
{
	function Init_Std()
	{
	}
	function Update_Std() : (pat_num_Eff_SpSpark)
	{
		local effcallflag = false;
		if( BMvTbl.GetLP(0) == 0) //まだ出てない
		{
			//特殊判定を見つけたらカットイン集中エフェクトをそこに出す
			local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			BMvCore.PushCharaData( p ); //		
				local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
				if( rc.sx != _Hantei_Error ) // 存在するか
				{	
					local e = BMvEff.CreateObject( { x=rc.sx, y=rc.sy, mvname="", datatype=1, start_pat=pat_num_Eff_SpSpark, flags=_Position_ToolShift } );
					BMvCore.PushCharaData( e ); //
						BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange|_ObjFlags_MoveTimeStopAll } );	
					BMvCore.PopCharaData(); //				
					effcallflag = true;
				}
			BMvCore.PopCharaData(); //	
			if( effcallflag ) BMvTbl.SetLP( 0, 1); //エフェクト出した			
		}
		else
		{
			BMvTbl.SetFinalize(0);
		}
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( s.MvCount>60 ) BMvTbl.SetFinalize(0);
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}			
}

//ダッシュMv終了時に呼ばれて次のMVによってダッシュ慣性を管理するオブジェクト
Std_MoveTable.Mv_DashKanseiMng <-
{
	function Init_Std()
	{
		// _dpn("Mv_DashKanseiMng");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPosition( { y=1024, flags=_Position_CaptureShift } );
		
		local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		if( player.push() )
		{
			//ジャンプ離陸のMvだった場合は慣性をいい感じに残して消える
			//それ以外なら慣性はキツめに消して消える
			local vec = BMvTbl.GetVector( { flags=_Vector_DivKeep } );
			local is_jump_wait = Battle_Std.IsMatchMvNameArray(["Mv_JumpWait_F","Mv_JumpWait_N","Mv_JumpWait_B","Mv_HighJumpWait_F"]);
			// _dpn("is_jump_wait:"+is_jump_wait);
			if( is_jump_wait )
			{
			}
			else
			{
				vec.x = vec.x * 40 / 100;
			}
			BMvTbl.SetVector( { x=vec.x, addx=-vec.x/10, flags=_Vector_DivKeep } );
			
			player.pop();
		}
		
		BMvTbl.SetFinalize();
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

local chp_DashJumpKansei = chrparam.Get( { type="ダッシュジャンプ慣性", chrnum=_ChrNo } );

//地上ジャンプの離陸から着地まで持続するオブジェクト
Std_MoveTable.Mv_JumpKanseiCheckObject <- //ジャンプ中の慣性（収束ベクトルじゃなくする）
{
	function Init_Std() : (chp_DashJumpKansei)
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPosition( { y=1024, flags=_Position_CaptureShift } );
		
		local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		if( player.push() )
		{
			local v = BMvTbl.GetVector( { flags=_Vector_DivKeep } );
			// _dpn("v.x:"+v.x);
			if( v.x > 2500 ) v.x = 2500; // 限界値

			local use_dashJumpKansei = chp_DashJumpKansei;
			local div_vec = v.x*use_dashJumpKansei[0]/100;
			local add_vec = v.x*use_dashJumpKansei[1]/100;
			
			BMvTbl.SetVector( { x=div_vec, addx=0, flags=_Vector_DivKeep } ); //メルブラジャンプ
			// _dpn("div:"+div_vec+" 加算:"+add_vec );
			BMvTbl.SetVector( { x=add_vec, flags=_Vector_Normal|_VecFlag_Add } );

			player.pop();
		}
	}
	function Update_Std() // 
	{
		local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		if( player.push() )
		{
			local playerisground = ( (BMvTbl.CheckPosState( _PosState_Ground ))==1 );
			if( playerisground )	
			{
				BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_DivKeep } ); //メルブラジャンプ終了
			}
			player.pop();
		
			if ( playerisground )	
			{
				BMvTbl.SetFinalize(0);
				BMvTbl.SetPP(def_PP_JumpStatus,0); //ジャンプステータスを初期化
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

local jump_vectorar = chrparam.Get( { type="ジャンプベクトル", chrnum=_ChrNo } );
local jump_vector = { y=jump_vectorar[0], addy=jump_vectorar[1] ,fx=jump_vectorar[2], nx=jump_vectorar[3], bx=jump_vectorar[4] };

local mjump_vectorar = chrparam.Get( { type="２段ジャンプベクトル", chrnum=_ChrNo } );
local mjump_vector = { y=mjump_vectorar[0], addy=mjump_vectorar[1] ,fx=mjump_vectorar[2], nx=mjump_vectorar[3], bx=mjump_vectorar[4] };

local mjump3_vectorar = chrparam.Get( { type="３段ジャンプベクトル", chrnum=_ChrNo } );
local mjump3_vector = { y=mjump3_vectorar[0], addy=mjump3_vectorar[1] ,fx=mjump3_vectorar[2], nx=mjump3_vectorar[3], bx=mjump3_vectorar[4] };

local mhighjump_vectorar = chrparam.Get( { type="２段ハイジャンプベクトル", chrnum=_ChrNo } );
local mhighjump_vector = { y=mhighjump_vectorar[0], addy=mhighjump_vectorar[1] ,fx=mhighjump_vectorar[2], nx=mhighjump_vectorar[3], bx=mhighjump_vectorar[4] };

local highjump_vectorar = chrparam.Get( { type="ハイジャンプベクトル", chrnum=_ChrNo } );
local highjump_vector = { y=highjump_vectorar[0], addy=highjump_vectorar[1] ,fx=highjump_vectorar[2], nx=highjump_vectorar[3], bx=highjump_vectorar[4] };

local aerialjump_vectorar = chrparam.Get( { type="エリアルジャンプベクトル", chrnum=_ChrNo } );
local aerialjump_vector = { y=aerialjump_vectorar[0], addy=aerialjump_vectorar[1] ,fx=aerialjump_vectorar[2], nx=aerialjump_vectorar[3], bx=aerialjump_vectorar[4] };

local missaerialjump_vectorar = chrparam.Get( { type="失敗エリアルジャンプベクトル", chrnum=_ChrNo } );
local missaerialjump_vector = { y=missaerialjump_vectorar[0], addy=missaerialjump_vectorar[1] ,fx=missaerialjump_vectorar[2], nx=missaerialjump_vectorar[3], bx=missaerialjump_vectorar[4] };


local set_JumpCtrlVector = function()
{
	local vec = BMvTbl.GetVector();
	
	if( (vec.y + vec.addy ) >= 0 )
	{
		//print("\n .");//23F
		return; // 下降中は失敗
	}
	
	Battle_Std.SetJumpCtrlVector( { max=700, min=-700, plus=96 } );
}

local func_JumpWaitInit = function()
{
	BMvTbl.SetMuki(_Direction_Auto);
	local vec = BMvTbl.GetVector( { flags=_Vector_DivKeep } );
	Battle_Std.InitVector();
	//Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
	BMvTbl.SetVector( { x=vec.x, addx=-vec.x/20, flags=_Vector_DivKeep } ); //メルブラジャンプ
	BMvEff.SetPlayerTimer( { muteki_nage=def_FL_JumpWaitNageMuteki, muteki_nageX=def_FL_JumpWaitNageMuteki } ); //ジャンプ移行は投げ無敵に設定
	
	BMvTbl.AirSkill_Begin(); // ジャンプ準備フレームのはじめに呼ぶ
}

// ジャンプで空中に浮いた時共通処理
local func_JumpFlightInit = function()
{
	BMvTbl.AirSkill_Check(); // ジャンプ開始フレームのはじめに呼ぶ
}

local noChickedGuard = {};

noChickedGuard.JumpInit <- function()
{
	// チキガ不可
	BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=Def_Rule_NoChickenGuardFrame, flag=_ClearFlag_ChangeMv } );
	BMvTbl.SetPP(def_PP_TMP0,Def_Rule_NoChickenGuardFrame+1);
}

noChickedGuard.JumpUpdate <- function()
{
	if( BMvTbl.GetPP(def_PP_TMP0) > 0 )
	{
		BMvTbl.AddPP(def_PP_TMP0,-1);
	}
}

noChickedGuard.MultiJumpInit <- function()
{
	//前のMvを見る
	if( Battle_Std.IsMatchChangeMvNameArray(["Mv_Jump_F","Mv_Jump_N","Mv_Jump_B"]) )
	{
		local leftFrame = BMvTbl.GetPP(def_PP_TMP0);
		BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=leftFrame, flag=_ClearFlag_ChangeMv } );
	}
}

local setLPEx_SousaiJumpCancelFrame = function()
{
	BMvTbl.SetLPEx(1,0,-1); // 初期化
	if( Battle_Std.ChangeMoveCodeEx_CheckFlag( 4, def_MC4_Sousai ) ) // 相殺されてる
	{
		// _dpn("相殺jcだと思う");
		local last_mv = BMvTbl.ChangeMv_GetMvName();
		if( last_mv == "Mv_Atk_RapidFinishAtk" )
		{
			BMvTbl.SetLPEx(1,0,Def_Sys_3CSousaiJumpCancelWaitFrame); // 3C
		}
		else if( last_mv == "Mv_ShieldCounterGro" )
		{
			BMvTbl.SetLPEx(1,0,Def_Sys_GroScSousaiJumpCancelWaitFrame); // ScA
		}
		else
		{
			BMvTbl.SetLPEx(1,0,-1); // 初期化
		}
	}
}

local setInitLPEx_SousaiJumpCancelFrame = function( mvname )
{
	if( BMvTbl.ChangeMv_GetMvName() == mvname )
	{
	}
	else
	{
		BMvTbl.SetLPEx(1,0,-1); // 初期化
	}
}

local checkTiming_SousaiJumpCancel = function()
{
	local mvcount = BMvTbl.GetMvStatus().MvCount;
	local frame = BMvTbl.GetLPEx(1,0);
	if( frame != -1 && mvcount >= frame )
	{
		return 1;
	}
	return 0;
}

//ジャンプキャンセル制限フラグを立てる用のかませMv
Std_MoveTable.Mv_JumpCanselWait_F <-
{
	function Init_Std() : (setLPEx_SousaiJumpCancelFrame)
	{
		Battle_Std.EnemyDamageFlag_Add( def_DF_JumpCanseled ); // 「ジャンプキャンセルをされた」を相手に記憶
		
		//二段ジャンプを消費したコンボ中ならさらにフラグをたてる
		if( Battle_Std.EnemyDamageFlag_Check( def_DF_MultiJumpCanceled ) )
		{
			Battle_Std.EnemyDamageFlag_Add( def_DF_AllJumpCancel_UsedMultiJumpCancel );
		}

		// 相殺ジャンプキャンセルのときは離陸の硬直を調整
		BMvTbl.SetLPEx(1,0,-1); // 初期化 -1:通常 0〜:jcのwaitをその値Fにする
		if( Def_Sys_ChangeSousaiJumpCancelFrame )
		{
			setLPEx_SousaiJumpCancelFrame();
		}
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_JumpWait_F" );
	}
}

// ジャンプ待機
Std_MoveTable.Mv_JumpWait_F <- 
{
	function Init_Std() : (func_JumpWaitInit, setInitLPEx_SousaiJumpCancelFrame)
	{
		setInitLPEx_SousaiJumpCancelFrame("Mv_JumpCanselWait_F");
		func_JumpWaitInit();
		BMvTbl.SetPattern(def_PAT_JumpWait_F);
	}
	function FrameUpdate_Std() : (checkTiming_SousaiJumpCancel)
	{
		Battle_Std.StartBandCDoujiCheck( "B+C" );//正確なB+Cが検知されたらフラグを立てる
		
		if( checkTiming_SousaiJumpCancel() )
		{
			BMvTbl.SetFinalize();
		}
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_nageX=0 } ); //抜けるときに初期化
		
		// ダッシュジャンプでかかり必殺技でスーっと滑るのが強いので補正
		if( !BMvTbl.FromFinalize() )
		{
			local vec = BMvTbl.GetVector( { flags=_Vector_DivKeep } );
			BMvTbl.SetVector( { x=vec.x*100/150, addx=-vec.x/10,flags=_Vector_DivKeep } ); // 収束ダッシュ慣性を減少
		}
	}
	function Finalize_Std() // 
	{
		local s = BMvTbl.GetMvStatus();
		if( s.MvCount<3 ) _dem("【警告】ジャンプ移行フレームが["+(s.MvCount)+"F]しかありません")

		BMvEff.CreateObject( { x=0, y=0, mvname="Mv_JumpKanseiCheckObject", flags=_Position_ToolShift } );		
		BMvTbl.SetNextMoveTable( "Mv_Jump_F" ); //						
	}	
}

// ジャンプ
Std_MoveTable.Mv_Jump_F <- 
{
	function Init_Std() : (jump_vector, noChickedGuard, func_JumpFlightInit)
	{
		BMvTbl.SetPattern(def_PAT_Jump_F);
		Battle_Std.JumpStatus.Set( def_PP_JS_JumpF ); // 前ジャンプからフラグを立てる
		BMvTbl.SetVector( { x=jump_vector.fx, y=jump_vector.y, addx=0, addy=jump_vector.addy } );
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		
		if( Def_Rule_NoChickenGuardFrame ) noChickedGuard.JumpInit();
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_PositiveAction ); // 行動コード(ポジティブ)を設定
		
		Battle_Std.SetPP_JumpStartHeight(); // ジャンプしたときの高さを記憶
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_Jump );
		Battle_Std.MoveCodeEx.AddFlag( 5, def_MC5_EnableAirToLandedShield );
		
		Battle_Std.TypeSE_Play({ type="ジャンプ" });
		
		// Battle_Std.DrawJumpPar( { x=0, y=-200 } ); // ジャンプ用パーティクル生成
		BMvEff.CreateObject( { datatype=1, start_pat=35 } );//ジャンプ煙
		
		func_JumpFlightInit(); // ジャンプ空中に移行した時共通処理
	}
	function FrameUpdate_Std() : (set_JumpCtrlVector)
	{
		local s = BMvTbl.GetMvStatus();
		if( Def_Rule_JumpSideMoveCtrl==1 ) set_JumpCtrlVector();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Update_Std() : (noChickedGuard)
	{
		if( Def_Rule_NoChickenGuardFrame ) noChickedGuard.JumpUpdate();
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}	
}

//ジャンプ共通着地Mv
Std_MoveTable.Mv_Jump_Land <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMoveableFlag( { move=0, time=def_FL_Jump_LandRecovery, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		Battle_Std.InitVector(); //ベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}		

//ジャンプキャンセル制限フラグを立てる用のかませMv
Std_MoveTable.Mv_JumpCanselWait_B <-
{
	function Init_Std() : (setLPEx_SousaiJumpCancelFrame)
	{
		Battle_Std.EnemyDamageFlag_Add( def_DF_JumpCanseled ); // 「ジャンプキャンセルをされた」を相手に記憶
		
		//二段ジャンプを消費したコンボ中ならさらにフラグをたてる
		if( Battle_Std.EnemyDamageFlag_Check( def_DF_MultiJumpCanceled ) )
		{
			Battle_Std.EnemyDamageFlag_Add( def_DF_AllJumpCancel_UsedMultiJumpCancel );
		}
		
		// 相殺ジャンプキャンセルのときは離陸の硬直を調整
		BMvTbl.SetLPEx(1,0,-1); // 初期化 -1:通常 0〜:jcのwaitをその値Fにする
		if( Def_Sys_ChangeSousaiJumpCancelFrame )
		{
			setLPEx_SousaiJumpCancelFrame();
		}
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_JumpWait_B" );
	}
}


// ジャンプ待機
Std_MoveTable.Mv_HighJumpWait_F <- 
{
	function Init_Std() : (func_JumpWaitInit)
	{
		func_JumpWaitInit();
		BMvTbl.SetPattern(def_PAT_HighJumpWait_F);
	}
	function FrameUpdate_Std()
	{
		Battle_Std.StartBandCDoujiCheck( "B+C" );//正確なB+Cが検知されたらフラグを立てる
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_nageX=0 } ); //抜けるときに初期化
		
		// ダッシュジャンプでかかり必殺技でスーっと滑るのが強いので補正
		if( !BMvTbl.FromFinalize() )
		{
			local vec = BMvTbl.GetVector( { flags=_Vector_DivKeep } );
			BMvTbl.SetVector( { x=vec.x*100/150, addx=-vec.x/10,flags=_Vector_DivKeep } ); // 収束ダッシュ慣性を減少
		}
	}
	function Finalize_Std() // 
	{
		local s = BMvTbl.GetMvStatus();
		if( s.MvCount<3 ) _dem("【警告】ジャンプ移行フレームが["+(s.MvCount)+"F]しかありません")

		BMvEff.CreateObject( { x=0, y=0, mvname="Mv_JumpKanseiCheckObject", flags=_Position_ToolShift } );		
		BMvTbl.SetNextMoveTable( "Mv_HighJump_F" ); //						
	}	
}

// ハイジャンプ中持続する残像管理オブジェクト
// ハイジャンプとジャンプ攻撃は継続
// 二段ジャンプでも消えるが、二段ジャンプから最速ジャンプ攻撃すると継続しちゃうよ
Std_MoveTable.Mv_HighJumpAfterImageObject <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPosition( { y=1024, flags=_Position_CaptureShift } );
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount < 2 )
		{
			//Initでやると他の残像消去で消される可能性があるので念入りにやる
			// BMvEff.PcAfterImage_Set( { type=0, range=12, delay=3, color=0xFFAAAAFF, blendmode=1 } );
			BMvEff.PcAfterImage_Set( {  type=0, range=12, delay=4, color=0x8FAAAAFF, blendmode=0 } );
		}
		
		local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		if( player.push() )
		{
			local playerisground = ( (BMvTbl.CheckPosState( _PosState_Ground ))==1 );
			local playerisair = ( (BMvTbl.CheckPosState( _PosState_Air ))==1 );
			local mvname = BMvTbl.GetMvName(); // Mvname取得
			player.pop();
		
			if ( playerisground )	
			{
				BMvTbl.SetFinalize(0);
				return;
			}
			if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) == 0 )
			{
				// ハイジャンプではない行動に移った
				// ジャンプ攻撃かどうかチェック
				if( playerisair && mvname.find("Mv_Atk_Air")==0 ) //空中だったら・ジャンプ攻撃っぽかったら
				{
					// _dp("\n ジャンプ攻撃っすよ");
				}
				else
				{
					_dp("\n ジャンプ攻撃ではない行動に移ったので残像を消す");
					BMvTbl.SetFinalize(0);
					return;
				}
			}
			
		}	
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		local is_bc_skill = 0;
		local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		if( player.push() )
		{
			is_bc_skill = Battle_Std.MoveCode.CheckFlag( def_MC_BCAction );
			
			player.pop();
		}
		if( !is_bc_skill )
		{
			BMvEff.PcAfterImage_Clear();
		}
	}
}

// ジャンプ
Std_MoveTable.Mv_HighJump_F <- 
{
	function Init_Std() : (highjump_vector, noChickedGuard, func_JumpFlightInit)
	{
		BMvTbl.SetPattern(def_PAT_Jump_F);
		Battle_Std.JumpStatus.Set( def_PP_JS_JumpF ); // 前ジャンプからフラグを立てる
		BMvTbl.SetVector( { x=highjump_vector.fx, y=highjump_vector.y, addx=0, addy=highjump_vector.addy, flags=_Vector_Normal } );

		//ジャンプ離陸後少し硬直とする
		//行動可能にするとハイジャンプ空中必殺技とか強い挙動になる
		//チキガではなく操作不能にする
		
		// 1〜Def_Rule_HightJumpNoMovedFrame : 行動不能
		// Def_Rule_HightJumpNoMovedFrame〜Def_Rule_NoChickenGuardFrame : 行動可能だけどガードのみ不可
		// Def_Rule_NoChickenGuardFrame〜：行動可能
		
		BMvTbl.SetMoveableFlagEx( {  move=0, timeA=Def_Rule_HightJumpNoMovedFrame, timeB=254, flag=_ClearFlag_ChangeMv } );
		// BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		
		if( Def_Rule_NoChickenGuardFrame ) noChickedGuard.JumpInit();
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_PositiveAction ); // 行動コード(ポジティブ)を設定
		BMvEff.CreateObject( { mvname="Mv_HighJumpAfterImageObject" } ); // ハイジャンプ中の残像管理

		Battle_Std.SetPP_JumpStartHeight(); // ジャンプしたときの高さを記憶
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_Jump );
		Battle_Std.MoveCodeEx.AddFlag( 5, def_MC5_EnableAirToLandedShield );

		Battle_Std.TypeSE_Play({ type="ジャンプ" });
		
		BMvEff.CreateObject( { datatype=1, start_pat=35 } );//ジャンプ煙
		
		Battle_Std.DrawAirDashPar( { x=0, y=-200 } );
		BSound.SE_Play( { type=_SeType_Normal, num=185 } ); // 高速移動音
		
		func_JumpFlightInit(); // ジャンプ空中に移行した時共通処理(意味なし)
	}
	function FrameUpdate_Std() : (set_JumpCtrlVector)
	{
		local s = BMvTbl.GetMvStatus();
		if( Def_Rule_JumpSideMoveCtrl==1 ) set_JumpCtrlVector();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
		
		local frame = s.MvCount;
		if( frame < Def_Rule_HightJumpNoMovedFrame )
		{
			BMvTbl.SetMoveableFlag( { move=0, time=64, flag=_ClearFlag_ChangeMv } ); // Mv中行動不能にする
		}
		else if( frame >= Def_Rule_HightJumpNoMovedFrame && frame < Def_Rule_NoChickenGuardFrame )
		{
			BMvTbl.SetMoveableFlag( { move=1, time=64, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
			BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=64, flag=_ClearFlag_ChangeMv } ); // 行動可能だけどガード不能にする
			//先行入力はきかない（きくと色々漏れる）
		}
		else
		{
			BMvTbl.SetMoveableFlag( { move=1, time=64, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
			BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=0, flag=_ClearFlag_ChangeMv } ); // 行動可能だけどガード不能を消す
		}
	}
	function Update_Std() : (noChickedGuard)
	{
		// if( Def_Rule_NoChickenGuardFrame ) noChickedGuard.JumpUpdate();//そもそも行動不能なので入れてはダメ
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		//ハイジャンプからの行動を少し減速する処理
		if( BMvTbl.FromFinalize()==0 )
		{
			local vec = BMvTbl.GetVector( { flags=_Vector_Normal } );
			local xmax = 3000;
			if( vec.x >  xmax ) vec.x =  xmax;
			if( vec.x < -xmax ) vec.x = -xmax;
			BMvTbl.SetVector( { x=xmax, flags=_Vector_Normal } );
		}
	}
}

// ジャンプ待機
Std_MoveTable.Mv_AssaultWait <- 
{
	function Init_Std() : (func_JumpWaitInit)
	{
		func_JumpWaitInit();
		BMvTbl.SetPattern(34);
		
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
	}
	function FrameUpdate_Std()
	{
		Battle_Std.StartBandCDoujiCheck( "B+C" );//正確なB+Cが検知されたらフラグを立てる
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_nageX=0 } ); //抜けるときに初期化
		
		// ダッシュジャンプでかかり必殺技でスーっと滑るのが強いので補正
		if( !BMvTbl.FromFinalize() )
		{
			local vec = BMvTbl.GetVector( { flags=_Vector_DivKeep } );
			BMvTbl.SetVector( { x=vec.x*100/150, addx=-vec.x/10,flags=_Vector_DivKeep } ); // 収束ダッシュ慣性を減少
		}
	}
	function Finalize_Std() // 
	{
		local s = BMvTbl.GetMvStatus();
		if( s.MvCount<3 ) _dem("【警告】ジャンプ移行フレームが["+(s.MvCount)+"F]しかありません")

		BMvEff.CreateObject( { mvname="", datatype=1, start_pat=255, flags=_Position_ToolShift } );		
		BMvEff.CreateObject( { x=0, y=0, mvname="Mv_JumpKanseiCheckObject", flags=_Position_ToolShift } );		
		BMvTbl.SetNextMoveTable( "Mv_AssaultJump" ); //						
	}	
}

local ground_Assault_AirAtkFrameAr = chrparam.Get( { type="地上アサルト硬直", chrnum=_ChrNo } );

//-1ならデフォ値に書き換える
if( ground_Assault_AirAtkFrameAr[0] == -1 ) ground_Assault_AirAtkFrameAr[0] = 10;
if( ground_Assault_AirAtkFrameAr[1] == -1 ) ground_Assault_AirAtkFrameAr[1] = 10;
if( ground_Assault_AirAtkFrameAr[2] == -1 ) ground_Assault_AirAtkFrameAr[2] = 10;

local air_Assault_AirAtkFrameAr = chrparam.Get( { type="空中アサルト硬直", chrnum=_ChrNo } );

//-1ならデフォ値に書き換える
if( air_Assault_AirAtkFrameAr[0] == -1 ) air_Assault_AirAtkFrameAr[0] = 9;
if( air_Assault_AirAtkFrameAr[1] == -1 ) air_Assault_AirAtkFrameAr[1] = 9;
if( air_Assault_AirAtkFrameAr[2] == -1 ) air_Assault_AirAtkFrameAr[2] = 9;


local assault_AirAtkParam =
{
	ground = 
	{
		min = ground_Assault_AirAtkFrameAr[0],
		a = ground_Assault_AirAtkFrameAr[0],
		b = ground_Assault_AirAtkFrameAr[1],
		c = ground_Assault_AirAtkFrameAr[2],
	},
	air = 
	{
		min = air_Assault_AirAtkFrameAr[0],
		a = air_Assault_AirAtkFrameAr[0],
		b = air_Assault_AirAtkFrameAr[1],
		c = air_Assault_AirAtkFrameAr[2],
	},
}

//最小フレームを決める
if( assault_AirAtkParam.ground.min > assault_AirAtkParam.ground.b ) assault_AirAtkParam.ground.min = assault_AirAtkParam.ground.b
if( assault_AirAtkParam.ground.min > assault_AirAtkParam.ground.c ) assault_AirAtkParam.ground.min = assault_AirAtkParam.ground.c
if( assault_AirAtkParam.air.min > assault_AirAtkParam.air.b ) assault_AirAtkParam.air.min = assault_AirAtkParam.air.b
if( assault_AirAtkParam.air.min > assault_AirAtkParam.air.c ) assault_AirAtkParam.air.min = assault_AirAtkParam.air.c

local use_assult_param = assault_AirAtkParam.ground;

// ジャンプ待機
Std_MoveTable.Mv_JumpWait_B <- 
{
	function Init_Std() : (func_JumpWaitInit, setInitLPEx_SousaiJumpCancelFrame)
	{
		func_JumpWaitInit();
		setInitLPEx_SousaiJumpCancelFrame("Mv_JumpCanselWait_B");
		BMvTbl.SetPattern(def_PAT_JumpWait_B);		
	}
	function FrameUpdate_Std() : (checkTiming_SousaiJumpCancel)
	{
		Battle_Std.StartBandCDoujiCheck( "B+C" );//正確なB+Cが検知されたらフラグを立てる
		
		if( checkTiming_SousaiJumpCancel() )
		{
			BMvTbl.SetFinalize();
		}
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_nageX=0 } ); //抜けるときに初期化
		
		// ダッシュジャンプでかかり必殺技でスーっと滑るのが強いので補正
		if( !BMvTbl.FromFinalize() )
		{
			local vec = BMvTbl.GetVector( { flags=_Vector_DivKeep } );
			BMvTbl.SetVector( { x=vec.x*100/150, addx=-vec.x/10,flags=_Vector_DivKeep } ); // 収束ダッシュ慣性を減少
		}
	}
	function Finalize_Std() // 
	{
		local s = BMvTbl.GetMvStatus();
		if( s.MvCount<3 ) _dem("【警告】ジャンプ移行フレームが["+(s.MvCount)+"F]しかありません")
		BMvEff.CreateObject( { x=0, y=0, mvname="Mv_JumpKanseiCheckObject", flags=_Position_ToolShift } );		
		
		BMvTbl.SetNextMoveTable( "Mv_Jump_B" ); //
	}	
}	

Std_MoveTable.Mv_Jump_B <- 
{
	function Init_Std() : (jump_vector, noChickedGuard, func_JumpFlightInit)
	{
		BMvTbl.SetPattern(def_PAT_Jump_B);
		Battle_Std.JumpStatus.Set( def_PP_JS_JumpB ); // 後ろジャンプからフラグを立てる
		BMvTbl.SetVector( { x=jump_vector.bx, y=jump_vector.y, addx=0, addy=jump_vector.addy } );
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする		
		
		if( Def_Rule_NoChickenGuardFrame ) noChickedGuard.JumpInit();
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_NegativeAction ); // 行動コード(ネガティブ)を設定
		
		Battle_Std.SetPP_JumpStartHeight(); // ジャンプしたときの高さを記憶
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_Jump );
		Battle_Std.MoveCodeEx.AddFlag( 5, def_MC5_EnableAirToLandedShield );
		
		Battle_Std.TypeSE_Play({ type="ジャンプ" });
		
		// Battle_Std.DrawJumpPar( { x=0, y=-200 } ); // ジャンプ用パーティクル生成
		BMvEff.CreateObject( { datatype=1, start_pat=37 } );//ジャンプ煙
		
		func_JumpFlightInit(); // ジャンプ空中に移行した時共通処理
	}
	function FrameUpdate_Std() : (set_JumpCtrlVector)
	{
		local s = BMvTbl.GetMvStatus();
		if( Def_Rule_JumpSideMoveCtrl==1 ) set_JumpCtrlVector();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Update_Std() : (noChickedGuard)
	{
		if( Def_Rule_NoChickenGuardFrame ) noChickedGuard.JumpUpdate();
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}	
}


//ジャンプキャンセル制限フラグを立てる用のかませMv
Std_MoveTable.Mv_JumpCanselWait_N <-
{
	function Init_Std() : (setLPEx_SousaiJumpCancelFrame)
	{
		Battle_Std.EnemyDamageFlag_Add( def_DF_JumpCanseled ); // 「ジャンプキャンセルをされた」を相手に記憶

		//二段ジャンプを消費したコンボ中ならさらにフラグをたてる
		if( Battle_Std.EnemyDamageFlag_Check( def_DF_MultiJumpCanceled ) )
		{
			Battle_Std.EnemyDamageFlag_Add( def_DF_AllJumpCancel_UsedMultiJumpCancel );
		}

		// 相殺ジャンプキャンセルのときは離陸の硬直を調整
		BMvTbl.SetLPEx(1,0,-1); // 初期化 -1:通常 0〜:jcのwaitをその値Fにする
		if( Def_Sys_ChangeSousaiJumpCancelFrame )
		{
			setLPEx_SousaiJumpCancelFrame();
		}
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_JumpWait_N" );
	}
}

// ジャンプ待機
Std_MoveTable.Mv_JumpWait_N <- 
{
	function Init_Std() : (func_JumpWaitInit, setInitLPEx_SousaiJumpCancelFrame)
	{
		func_JumpWaitInit();
		setInitLPEx_SousaiJumpCancelFrame("Mv_JumpCanselWait_N");
		BMvTbl.SetPattern(def_PAT_JumpWait_N);		
	}
	function FrameUpdate_Std() : (checkTiming_SousaiJumpCancel)
	{
		Battle_Std.StartBandCDoujiCheck( "B+C" );//正確なB+Cが検知されたらフラグを立てる
		
		if( checkTiming_SousaiJumpCancel() )
		{
			BMvTbl.SetFinalize();
		}
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_nageX=0 } ); //抜けるときに初期化
		
		// ダッシュジャンプでかかり必殺技でスーっと滑るのが強いので補正
		if( !BMvTbl.FromFinalize() )
		{
			local vec = BMvTbl.GetVector( { flags=_Vector_DivKeep } );
			BMvTbl.SetVector( { x=vec.x*100/150, addx=-vec.x/10,flags=_Vector_DivKeep } ); // 収束ダッシュ慣性を減少
		}
	}
	function Finalize_Std() // 
	{
		local s = BMvTbl.GetMvStatus();
		if( s.MvCount<3 ) _dem("【警告】ジャンプ移行フレームが["+(s.MvCount)+"F]しかありません")
		
		BMvEff.CreateObject( { x=0, y=0, mvname="Mv_JumpKanseiCheckObject", flags=_Position_ToolShift } );		
		BMvTbl.SetNextMoveTable( "Mv_Jump_N" ); //
	}
}	

Std_MoveTable.Mv_Jump_N <- 
{
	function Init_Std() : (jump_vector, noChickedGuard, func_JumpFlightInit)
	{
		BMvTbl.SetPattern(def_PAT_Jump_N);
		Battle_Std.JumpStatus.Add( def_PP_JS_JumpN ); //垂直ジャンプからフラグを立てる
		
		BMvTbl.SetVector( { x=jump_vector.nx, y=jump_vector.y, addx=0, addy=jump_vector.addy } );
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		
		if( Def_Rule_NoChickenGuardFrame ) noChickedGuard.JumpInit();

		Battle_Std.SetPP_JumpStartHeight(); // ジャンプしたときの高さを記憶
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_Jump );
		Battle_Std.MoveCodeEx.AddFlag( 5, def_MC5_EnableAirToLandedShield );
		
		Battle_Std.TypeSE_Play({ type="ジャンプ" });
		
		// Battle_Std.DrawJumpPar( { x=0, y=-200 } ); // ジャンプ用パーティクル生成
		BMvEff.CreateObject( { datatype=1, start_pat=36 } );//ジャンプ煙
		
		func_JumpFlightInit(); // ジャンプ空中に移行した時共通処理
	}
	function FrameUpdate_Std() : (set_JumpCtrlVector)
	{
		local s = BMvTbl.GetMvStatus();
		if( Def_Rule_JumpSideMoveCtrl ) set_JumpCtrlVector();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Update_Std() : (noChickedGuard)
	{
		if( Def_Rule_NoChickenGuardFrame ) noChickedGuard.JumpUpdate();
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}	
}

local func_multijump_wait_init = function()
{
	if( Def_Sys_MultiJumpTrueFurimuki )
	{
		Battle_Std.SetMukiAuto();
	}
	else
	{
		BMvTbl.SetMuki(_Direction_Auto);
	}
	Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
	Battle_Std.SetNoMovableMove(); // 動けないMV
	BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=6, flag=_ClearFlag_ChangeMv } );//ガード情報反転
	
	// 前の行動がガードフロートのときに、二段ジャンプしたら、少しだけ打撃無敵時間を付与する
	if( Def_Sys_GuardFloat_AddMutekiFrame )
	{
		if( BMvTbl.ChangeMv_GetMvName() == "Mv_Modori_GuardA" && Battle_Std.ChangeMoveCodeEx_CheckFlag( 1, def_MC1_GenFlag ) )
		{
			// ガードフロートからの多段ジャンプ
			BMvEff.SetPlayerTimer( { muteki_dage=Def_Sys_GuardFloat_AddMutekiFrame } );
		}
	}
}

//２段ジャンプ系のでかかり硬直
//GGPO向けに急なベクトル変更をなくすのが目的

Std_MoveTable.Mv_MultiJump_F_Wait <-
{
	function Init_Std() : (func_multijump_wait_init)
	{
		BMvTbl.SetPattern(def_PAT_Jump_F);
		func_multijump_wait_init();
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 2 )
		{
			BMvTbl.SetFinalize();
		}
		if( mvs.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_MultiJump_F", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_MultiHighJump_F_Wait <-
{
	function Init_Std() : (func_multijump_wait_init)
	{
		BMvTbl.SetPattern(def_PAT_Jump_F);
		func_multijump_wait_init();
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 2 )
		{
			BMvTbl.SetFinalize();
		}
		if( mvs.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_MultiHighJump_F", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_MultiJump_N_Wait <-
{
	function Init_Std() : (func_multijump_wait_init)
	{
		BMvTbl.SetPattern(def_PAT_Jump_N);
		func_multijump_wait_init();
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 2 )
		{
			BMvTbl.SetFinalize();
		}
		if( mvs.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_MultiJump_N", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_MultiJump_B_Wait <-
{
	function Init_Std() : (func_multijump_wait_init)
	{
		BMvTbl.SetPattern(def_PAT_Jump_B);
		func_multijump_wait_init();
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 2 )
		{
			BMvTbl.SetFinalize();
		}
		if( mvs.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_MultiJump_B", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_MultiJumpCancel_F <-
{
	function Init_Std()
	{
		BMvTbl.SetMuki(_Direction_Auto); //振り向いてからベクトルを入れる
		
		//二段ジャンプを消費したコンボ中ならさらにフラグをたてる
		if( Battle_Std.EnemyDamageFlag_Check( def_DF_MultiJumpCanceled ) )
		{
			Battle_Std.EnemyDamageFlag_Add( def_DF_AllJumpCancel_UsedMultiJumpCancel );
		}
		Battle_Std.EnemyDamageFlag_Add( def_DF_MultiJumpCanceled ); // 二段ジャンプ消費
		
		//ちょんいれならハイジャンプへ 2021/3/26 初心者の暴発が多いため基本廃止（がんばって28って入れる）
		if( Def_Sys_TappingMultiHighJump && BMvTbl.CheckCommandString( "0" ) && !BMvTbl.IsCpu() )
		{
			BMvTbl.SetFinalize(256);//２段ハイジャンプへ
			return;
		}
		BMvTbl.SetFinalize();
	}
	function Finalize_Std()
	{
		Battle_Std.SwitchNextMoveTable("Mv_MultiJump_F", [256,"Mv_MultiHighJumpCancel_F"] ); //デフォ,[code,mv]...
	}
}


//三段ジャンプ共通処理
local func_CheckMuiti3DanJump = function()
{
	if( BMvTbl.AddAirJumpCount(0) <= 0 )
	{
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_DoubleMultiJump );
	}
	else
	{
		// 空中ダッシュ系を不可に
		BMvTbl.AddAirCount( def_ACS_AirDash, 1 );
		BMvTbl.AddAirCount( def_ACS_AirBackDash, 1 );
		BMvTbl.AddAirCount( def_ACS_AllAirDash, 1 );
		
		if( Def_Sys_3DanaJumpGuard == 0 )
		{
			BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=254, flag=_ClearFlag_ChangeMv } ); // 三段ジャンプだとガード不可
		}
		
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_TripleMultiJump );//三段ジャンプの行動
	}
}

Std_MoveTable.Mv_MultiJump_F <-
{
	function Init_Std() : (mjump_vector, mjump3_vector, noChickedGuard, mhighjump_vector, func_CheckMuiti3DanJump)
	{
		Battle_Std.InitCharaVector();
		BMvTbl.SetPattern(def_PAT_Jump_F);
		
		// 二段ジャンプや３段ジャンプでベクトルを調整する

		if( BMvTbl.AddAirJumpCount(0) <= 0 )
		{
			//二段ジャンプ
			BMvTbl.SetVector( { x=mjump_vector.fx, y=mjump_vector.y, addx=0, addy=mjump_vector.addy } );
		}
		else
		{
			//三段ジャンプ
			BMvTbl.SetVector( { x=mjump3_vector.fx, y=mjump3_vector.y, addx=0, addy=mjump3_vector.addy } );
		}
		
		// チキガ設定
		if( BMvTbl.AddAirJumpCount(0) <= 0 )
		{
			//二段ジャンプ時
			if( Def_Rule_NoChickenGuardFrame ) noChickedGuard.MultiJumpInit();
		}
		
		func_CheckMuiti3DanJump(); // 三段ジャンプ共通処理
		
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		
		Battle_Std.DrawJumpPar( { x=0, y=-200 } ); // ジャンプ用パーティクル生成
		
		BMvEff.CreateObject( { x=0, y=0, mvname="Mv_JumpKanseiCheckObject", flags=_Position_ToolShift } );
		BMvTbl.SetAirJumpOK(0);  //再度ジャンプできないようにする
		BMvTbl.AddAirJumpCount(1);  //回数を加算
		
		Battle_Std.JumpStatus.Add( def_PP_JS_MultiJumpF ); //ジャンプフラグを立てる
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_PositiveAction ); // 行動コード(ポジティブ)を設定

		Battle_Std.SetPP_JumpStartHeight(); // ジャンプしたときの高さを記憶
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_Jump );
		Battle_Std.MoveCodeEx.AddFlag( 5, def_MC5_EnableAirToLandedShield );
		
		Battle_Std.TypeSE_Play({ type="ジャンプ" });
	}
	function FrameUpdate_Std() : (set_JumpCtrlVector, mhighjump_vector)
	{
		local s = BMvTbl.GetMvStatus();
			
		if( Def_Rule_JumpSideMoveCtrl==1 ) set_JumpCtrlVector();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		if( Def_Sys_GuardFloat_AddMutekiFrame )
		{
			BMvEff.SetPlayerTimer( { muteki_dage=0 } ); // 無敵を消す
		}
	}
}

Std_MoveTable.Mv_MultiHighJumpCancel_F <-
{
	function Init_Std()
	{
		BMvTbl.SetMuki(_Direction_Auto); //振り向いてからベクトルを入れる
		
		//二段ジャンプを消費したコンボ中ならさらにフラグをたてる
		if( Battle_Std.EnemyDamageFlag_Check( def_DF_MultiJumpCanceled ) )
		{
			Battle_Std.EnemyDamageFlag_Add( def_DF_AllJumpCancel_UsedMultiJumpCancel );
		}
		Battle_Std.EnemyDamageFlag_Add( def_DF_MultiJumpCanceled ); // 二段ジャンプ消費
		BMvTbl.SetFinalize();
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable("Mv_MultiHighJump_F");
	}
}

Std_MoveTable.Mv_MultiHighJump_F <-
{
	function Init_Std() : (mjump_vector, mjump3_vector, noChickedGuard, mhighjump_vector, func_CheckMuiti3DanJump)
	{
		Battle_Std.InitCharaVector();
		BMvTbl.SetPattern(def_PAT_Jump_F);
		
		BMvTbl.SetLP(0,1); //ハイジャンプ済み
		BMvEff.CreateObject( { mvname="Mv_HighJumpAfterImageObject" } ); // ハイジャンプ中の残像管理
		BMvTbl.SetVector( { x=mhighjump_vector.fx, y=mhighjump_vector.y, addx=0, addy=mhighjump_vector.addy } );
		
		// チキガ設定
		if( BMvTbl.AddAirJumpCount(0) <= 0 )
		{
			//二段ジャンプ時
			if( Def_Rule_NoChickenGuardFrame ) noChickedGuard.MultiJumpInit();
		}
		
		func_CheckMuiti3DanJump(); // 三段ジャンプ共通処理
		
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		
		Battle_Std.DrawAirDashPar( { x=0, y=-200 } );
		BSound.SE_Play( { type=_SeType_Normal, num=185 } ); // 高速移動音
		
		BMvEff.CreateObject( { x=0, y=0, mvname="Mv_JumpKanseiCheckObject", flags=_Position_ToolShift } );
		BMvTbl.SetAirJumpOK(0);  //再度ジャンプできないようにする
		BMvTbl.AddAirJumpCount(1);  //回数を加算
		
		Battle_Std.JumpStatus.Add( def_PP_JS_MultiJumpF ); //ジャンプフラグを立てる
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_PositiveAction ); // 行動コード(ポジティブ)を設定

		Battle_Std.SetPP_JumpStartHeight(); // ジャンプしたときの高さを記憶
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_Jump );
		Battle_Std.MoveCodeEx.AddFlag( 5, def_MC5_EnableAirToLandedShield );
		
		Battle_Std.TypeSE_Play({ type="ジャンプ" });
	}
	function FrameUpdate_Std() : (set_JumpCtrlVector, mhighjump_vector)
	{
		local s = BMvTbl.GetMvStatus();
		if( Def_Rule_JumpSideMoveCtrl==1 ) set_JumpCtrlVector();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		if( Def_Sys_GuardFloat_AddMutekiFrame )
		{
			BMvEff.SetPlayerTimer( { muteki_dage=0 } ); // 無敵を消す
		}
	}
}

Std_MoveTable.Mv_MultiJumpCancel_B <-
{
	function Init_Std()
	{
		BMvTbl.SetMuki(_Direction_Auto); //振り向いてからベクトルを入れる

		//二段ジャンプを消費したコンボ中ならさらにフラグをたてる
		if( Battle_Std.EnemyDamageFlag_Check( def_DF_MultiJumpCanceled ) )
		{
			Battle_Std.EnemyDamageFlag_Add( def_DF_AllJumpCancel_UsedMultiJumpCancel );
		}
		Battle_Std.EnemyDamageFlag_Add( def_DF_MultiJumpCanceled ); // 二段ジャンプ消費
		BMvTbl.SetFinalize();
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable("Mv_MultiJump_B");
	}
}

Std_MoveTable.Mv_MultiJump_B <-
{
	function Init_Std() : (mjump_vector, mjump3_vector, noChickedGuard, func_CheckMuiti3DanJump)
	{
		Battle_Std.InitCharaVector();
		BMvTbl.SetPattern(def_PAT_Jump_B);
		
		// 二段ジャンプや３段ジャンプでベクトルを調整する
		if( BMvTbl.AddAirJumpCount(0) <= 0 )
		{
			BMvTbl.SetVector( { x=mjump_vector.bx, y=mjump_vector.y, addx=0, addy=mjump_vector.addy } );
			
			if( Def_Rule_NoChickenGuardFrame ) noChickedGuard.MultiJumpInit();
		}
		else
		{
			BMvTbl.SetVector( { x=mjump3_vector.bx, y=mjump3_vector.y, addx=0, addy=mjump3_vector.addy } );
		}
		
		func_CheckMuiti3DanJump(); // 三段ジャンプ共通処理
		
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする

		Battle_Std.DrawJumpPar( { x=0, y=-200 } ); // ジャンプ用パーティクル生成
	
		BMvEff.CreateObject( { x=0, y=0, mvname="Mv_JumpKanseiCheckObject", flags=_Position_ToolShift } );
		BMvTbl.SetAirJumpOK(0);  //再度ジャンプできないようにする
		BMvTbl.AddAirJumpCount(1);  //回数を加算			
		
		Battle_Std.JumpStatus.Add( def_PP_JS_MultiJumpB ); //ジャンプフラグを立てる
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_NegativeAction ); // 行動コード(ネガティブ)を設定

		Battle_Std.SetPP_JumpStartHeight(); // ジャンプしたときの高さを記憶
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_Jump );
		Battle_Std.MoveCodeEx.AddFlag( 5, def_MC5_EnableAirToLandedShield );
		
		Battle_Std.TypeSE_Play({ type="ジャンプ" });
	}
	function FrameUpdate_Std() : (set_JumpCtrlVector)
	{
		local s = BMvTbl.GetMvStatus();
		if( Def_Rule_JumpSideMoveCtrl==1 ) set_JumpCtrlVector();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		if( Def_Sys_GuardFloat_AddMutekiFrame )
		{
			BMvEff.SetPlayerTimer( { muteki_dage=0 } ); // 無敵を消す
		}
	}
}

Std_MoveTable.Mv_MultiJumpCancel_N <-
{
	function Init_Std()
	{
		BMvTbl.SetMuki(_Direction_Auto); //振り向いてからベクトルを入れる

		//二段ジャンプを消費したコンボ中ならさらにフラグをたてる
		if( Battle_Std.EnemyDamageFlag_Check( def_DF_MultiJumpCanceled ) )
		{
			Battle_Std.EnemyDamageFlag_Add( def_DF_AllJumpCancel_UsedMultiJumpCancel );
		}
		Battle_Std.EnemyDamageFlag_Add( def_DF_MultiJumpCanceled ); // 二段ジャンプ消費
		BMvTbl.SetFinalize();
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable("Mv_MultiJump_N");
	}
}

Std_MoveTable.Mv_MultiJump_N <-
{
	function Init_Std() : (mjump_vector, mjump3_vector, noChickedGuard, func_CheckMuiti3DanJump)
	{
		Battle_Std.InitCharaVector();
		BMvTbl.SetPattern(def_PAT_Jump_N);
		
		// 二段ジャンプや３段ジャンプでベクトルを調整する
		if( BMvTbl.AddAirJumpCount(0) <= 0 )
		{
			BMvTbl.SetVector( { x=mjump_vector.nx, y=mjump_vector.y, addx=0, addy=mjump_vector.addy } );
			
			if( Def_Rule_NoChickenGuardFrame ) noChickedGuard.MultiJumpInit();
		}
		else
		{
			BMvTbl.SetVector( { x=mjump3_vector.nx, y=mjump3_vector.y, addx=0, addy=mjump3_vector.addy } );
		}
		
		func_CheckMuiti3DanJump(); // 三段ジャンプ共通処理

		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする

		Battle_Std.DrawJumpPar( { x=0, y=-200 } ); // ジャンプ用パーティクル生成
		
		BMvEff.CreateObject( { x=0, y=0, mvname="Mv_JumpKanseiCheckObject", flags=_Position_ToolShift } );
		BMvTbl.SetAirJumpOK(0);  //再度ジャンプできないようにする
		BMvTbl.AddAirJumpCount(1);  //回数を加算
		
		Battle_Std.JumpStatus.Add( def_PP_JS_MultiJumpN ); //ジャンプフラグを立てる		

		Battle_Std.SetPP_JumpStartHeight(); // ジャンプしたときの高さを記憶
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_Jump );
		Battle_Std.MoveCodeEx.AddFlag( 5, def_MC5_EnableAirToLandedShield );
		
		Battle_Std.TypeSE_Play({ type="ジャンプ" });
	}
	function FrameUpdate_Std() : (set_JumpCtrlVector)
	{
		local s = BMvTbl.GetMvStatus();
		if( Def_Rule_JumpSideMoveCtrl ) set_JumpCtrlVector();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		if( Def_Sys_GuardFloat_AddMutekiFrame )
		{
			BMvEff.SetPlayerTimer( { muteki_dage=0 } ); // 無敵を消す
		}
	}
}



Std_MoveTable.Mv_Crouch <- // しゃがみ移行
{
	function Init_Std() // 
	{
		//print("\n->しゃがみいこう");
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Crouch);
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする		
	}
	//遅立ちテクを残すためにここのUpdateではキー受付をしない
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}

local val_CroTyouhatsuType = chrparam.Get( { type="しゃがみ挑発タイプ", chrnum=_ChrNo } ); 


Std_MoveTable.Mv_Crouch_Wait <- // しゃがみ待機
{
	function Init_Std() // 
	{
		// BMvTbl.SetMuki(_Direction_Auto); // 振り向き処理は別にやるので不要
		BMvTbl.SetPattern(def_PAT_Crouch_Wait);
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		
		BMvTbl.SetLP(0,0); //挑発状態かフラグ　0:通常 1:挑発
		BMvTbl.SetFinalizeCode(0); //初期状態が0でない＋GetFinalizeCodeで分岐してるので初期化
		
		BMvTbl.SetPP(def_PP_TMP0,0); // 挑発カウンタ
		
		BMvTbl.SetPosition( { y=0 } ); // 保険処理で地上につける
		
		//タッグキャラのパートナーのときはしゃがみ待機でまつ必要がないのですぐに終わる
		local is_partner = (BMvCore.GetTagStatus() == 0); // -1 - タッグでない 1 - メイン状態 0 - パートナー状態
		if( is_partner )
		{
			BMvTbl.SetFinalize(0); // 立ち上がる
		}
	}
	function FrameUpdate_Std() : (appeal_finalize, val_CroTyouhatsuType)
	{
		BMvTbl.SetMoveableFlag( { move=1, time=32, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); // ループに含める行動可能
		
		// 下方向でないとき立ち上がる
		if( !BMvTbl.CheckStickHold( (1<<1) | (1<<2) | (1<<3) ) )
		{
			BMvTbl.SetFinalize(0); // コード0を立ち上がりとしてFinalize
		}
		else if( BMvTbl.CheckFurimuki() ) // 振り向きチェック
		{
			BMvTbl.SetFinalize(256); // コード256を振り向きとしてFinalize
		}
		else
		{
			appeal_finalize( { type=val_CroTyouhatsuType, fincode=512, jumpid=512 } );//挑発時はFinalize(PP使用)
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Crouch_toN", [256,"Mv_Furimuki_C"], [512,"Mv_Crouch_Appeal"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_Crouch_Appeal <- // しゃがみニュートラル待機
{
	function Init_Std() // 
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.DataPattern != def_PAT_Crouch_Wait ) BMvTbl.SetPattern(def_PAT_Crouch_Wait);
		BMvTbl.JumpFrameID( 512 );

		if( Def_Dbg_NoPlayUpsetSE == 0 ) Battle_Std.TypeSE_Play({ type="しゃがみ挑発" });
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする		
	}
	function Update_Std() // 
	{
		BMvTbl.SetMoveableFlag( { move=1, time=2, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );	
		if( BMvTbl.CheckFurimuki() ) // 振り向きチェック
		{
			BMvTbl.SetFinalize(256); // コード256を振り向きとしてFinalize
		}
		
		// 下方向でないとき立ち上がる
		if( !BMvTbl.CheckStickHold( (1<<1) | (1<<2) | (1<<3) ) )
		{
			BMvTbl.SetFinalize(0); // コード0を立ち上がりとしてFinalize
		}
		else if( BMvTbl.CheckFurimuki() ) // 振り向きチェック
		{
			BMvTbl.SetFinalize(256); // コード256を振り向きとしてFinalize
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Crouch_Wait", [256,"Mv_Furimuki_C"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_Crouch_toN <- //立ち上がり
{
	function Init_Std() // 
	{
		//print("\n->たちいこう");
	
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Crouch_toN);
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする		
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

// 振り向き音声を再生するべきかどうかチェック
local checkFurimukiVoice = function()
{
	if( Battle_Std.CheckEnemyisBound() ) return 0;
	if( Battle_Std.CheckEnemyisUkemi() ) return 0;
	
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		local e_muki = BMvTbl.GetMuki();
		enemy.pop();
		
		local p_muki = BMvTbl.GetMuki();
		
		if( p_muki == e_muki )
		{
			// お互い右向きとか、お互い左向きとか
			// 先に振り向くキャラがこっちに入ることが多い
			// _dp("\n しゃべってもいい");
			return 1;
		}
		else
		{
			// お互い向き合うorお互い逆を向いている（後者でしゃべらないのは変だけど、レアケースなので除外）
			// 後から振り向くキャラがこのセリフに入ることが多い
			// _dp("\n これはしゃべらない");
			return 0;
		}
	}
	return 0; // 相手が取得できない＝よくわからないので声はなし
}

// 立ち振り向き
Std_MoveTable.Mv_Furimuki_S <- 
{
	function Init_Std() : (checkFurimukiVoice)// 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Furimuki_S);		
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		
		//相手がやられ中や受け身中なら音声は不要なのでチェック
		if( checkFurimukiVoice() )
		{
			Battle_Std.TypeSE_Play({ type="振り向き" });
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

Std_MoveTable.PatMv_Furimuki_S <- 
{
	function Init_Std()
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Furimuki_S);		
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
	}
	function FrameUpdate_Std()
	{
		BtlPt.NoRenderPartner_EnemySPAction(); //自分と相手の超技中は消す
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "PatMv_Neutral" );
	}
}

// しゃがみ振り向き
Std_MoveTable.Mv_Furimuki_C <- 
{
	function Init_Std() : (checkFurimukiVoice)// 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Furimuki_C);		
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		
		//相手がやられ中や受け身中なら音声は不要なのでチェック
		if( checkFurimukiVoice() )
		{
			Battle_Std.TypeSE_Play({ type="振り向き" });
		}
	}
	function Update_Std() // 
	{
		// 下方向でないとき立ち上がる
		if( !BMvTbl.CheckStickHold( (1<<1) | (1<<2) | (1<<3) ) )
		{
			BMvTbl.SetFinalize(256); // コード256を立ち上がりとしてFinalize
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Crouch_Wait", [256,"Mv_Crouch_toN"] ); //デフォ,[code,mv]...
	}
}

// 通常技もある程度統一関数
Std_MoveTable.Mv_Atk_RapidRelayPass_StdA <-
{
	function Init_Std()
	{
		// _dpn("Pass StdA");
		Battle_Std.InitPassAtkMv();
		BMvTbl.SetFinalize();
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Atk_RapidRelayAtk" );
	}
}

Std_MoveTable.Mv_Atk_RapidRelayPass_StdB <-
{
	function Init_Std()
	{
		// _dpn("Pass StdB");
		Battle_Std.InitPassAtkMv();
		BMvTbl.SetFinalize();
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Atk_RapidRelayAtk" );
	}
}

Std_MoveTable.Mv_Atk_RapidRelayPass_StdC <-
{
	function Init_Std()
	{
		// _dpn("Pass StdC");
		Battle_Std.InitPassAtkMv();
		BMvTbl.SetFinalize();
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Atk_RapidRelayAtk" );
	}
}

Std_MoveTable.Mv_Atk_RapidRelayPass_CroA <-
{
	function Init_Std()
	{
		// _dpn("Pass CroA");
		Battle_Std.InitPassAtkMv();
		BMvTbl.SetFinalize();
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Atk_RapidRelayAtk" );
	}
}

Std_MoveTable.Mv_Atk_RapidRelayPass_CroB <-
{
	function Init_Std()
	{
		// _dpn("Pass CroB");
		Battle_Std.InitPassAtkMv();
		BMvTbl.SetFinalize();
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Atk_RapidRelayAtk" );
	}
}

Std_MoveTable.Mv_Atk_RapidRelayPass_CroC <-
{
	function Init_Std()
	{
		// _dpn("Pass CroC");
		Battle_Std.InitPassAtkMv();
		BMvTbl.SetFinalize();
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Atk_RapidRelayAtk" );
	}
}

//いらないかもしれないけど仕様を上と揃える
Std_MoveTable.Mv_Atk_RapidRelayPass_Manual <-
{
	function Init_Std()
	{
		// _dpn("Pass Manual");
		Battle_Std.InitPassAtkMv();
		BMvTbl.SetFinalize();
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Atk_RapidRelayAtk" );
	}
}

// 連打コンボの中継技
Std_MoveTable.Mv_Atk_RapidRelayAtk <-
{
	function Init_Std()
	{
		Battle_Std.InitRapidMv();
		Battle_Std.InitGroundAtk(); //通常攻撃共通Init

		BMvTbl.SetPattern(def_PAT_RapidRelayAtk);
		BMvTbl.SetSkillLv(def_MVSL_RapidRelayAtk);
		
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( { val=1, time=254, flag=_ClearFlag_ChangeMv } );
		
		Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_UniqAttack ); // 特殊技
		
		if( BMvTbl.ChangeMv_GetMvName() == "Mv_Atk_RapidRelayPass_StdC" )
		{
			//_dpn("C>Cの連打コンボ");
			//チュートリアル:mvflag=1 で検知可
			BMvTbl.SetTutoMvFlag( 1 ); // C>Cで出した連打コンボ
		}
		
		if( Def_Sys_KeepUkemiRapidRelayAtk )
		{
			BMvTbl.SetForceUkemiTimeLimitFlag( { val=Def_Sys_KeepUkemiRapidRelayAtk, time=255, flag=_ClearFlag_ChangeMv } );
		}
	}
	function Start_Std()
	{
		Battle_Std.StartGroundAtk();
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="Mv_Atk_RapidRelayAtk_FU" });
	}
	function HitInterrupt_Std() : (tbl_RapidRelayAtkLockStatus)
	{
		Battle_Std.MvRule_Atk_HitInterrupt();
		
		if( Battle_Std.CheckDamageTiming_ExceptDown() )
		{
			Battle_Std.SetPosition_DamageHanteiRect( tbl_RapidRelayAtkLockStatus );
		}
	}
	function Finalize_Std() // 
	{
		//キャラ別に変更することもあり
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

//連打コンボのフィニッシュ浮かせ技
Std_MoveTable.Mv_Atk_RapidFinishAtk <-
{
	function Init_Std() : (_ChrNo)
	{
		Battle_Std.InitRapidMv();
		Battle_Std.InitGroundAtk(); //通常攻撃共通Init

		BMvTbl.SetPattern(def_PAT_RapidFinishAtk);
		BMvTbl.SetSkillLv(def_MVSL_RapidFinishAtk);
		
		//前の行動が連打コンボのときだけ
		if( BMvTbl.ChangeMv_GetMvName()=="Mv_Atk_RapidRelayAtk" )
		{
			Battle_Std.Achievement_Unlock(16);//【トロフィー】お手軽コンボ
			
			BMvEff.AttackInfoString_Set({ word=def_AISW_RapidBeatFinish,} );
			
			//相手の位置が遠いときはベクトルが入る
			if( _ChrNo != Def_ChrNo_Chr009 )//MEMO:キャラ別の挙動を指定できるようにするべき
			{
				Battle_Std.SetVector_ApproachEnemy( { min=100*128, max=300*128, frame=10, guard_par=100, vecflags=_Vector_DivKeep } );
			}
		}

		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( { val=1, time=254, flag=_ClearFlag_ChangeMv } );
		
		Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_UniqAttack ); // 特殊技
	}
	function Start_Std()
	{
		Battle_Std.StartGroundAtk();
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="Mv_Skill_RapidStdB_FU" });
		
		Battle_Std.SetHitMuteki( 1, 8, _HitCheckFlag_Head ); // Param1 & 8 の時、_HitCheckFlag_Head 頭無敵
	}
	function HitInterrupt_Std() : (tbl_RapidAtkFinishStatus)
	{
		Battle_Std.MvRule_Atk_HitInterrupt();
		if( Battle_Std.CheckDamageTiming_ExceptDown() )
		{
			Battle_Std.SetPosition_DamageHanteiRect();
		}

		if( Battle_Std.SetImpactHitEffect( tbl_RapidAtkFinishStatus ) ) // 
		{
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

// 立ち通常技
Std_MoveTable.Mv_Atk_StdA <- 
{
	function Init_Std()
	{
		//前提フラグ設定
		Battle_Std.MoveCode.AddFlag( def_MC_GRDLowBreak ); // GRDブレイクの効果が短いMv
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_AtkLow );

		//初期化処理
		Battle_Std.InitGroundAtk(); //通常攻撃共通Init
		
		BMvTbl.SetPattern(def_PAT_Atk_StdA);
		BMvTbl.SetSkillLv(def_MVSL_AtkStdA);
		
		if( BCMDTbl.CheckComboLimit( DEF_BS_CL_STDA2nd ) )
		{
			BMvTbl.SetComboLimit(DEF_BS_CL_STDA3rd);
		}
		else if( BCMDTbl.CheckComboLimit( DEF_BS_CL_STDA ) )
		{
			BMvTbl.SetComboLimit(DEF_BS_CL_STDA2nd);
		}
		else
		{
			BMvTbl.SetComboLimit(DEF_BS_CL_STDA);
		}
	}
	function Start_Std()
	{
		Battle_Std.StartGroundAtk();
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="立ち弱攻撃" });
		
		Battle_Std.NoWhiffCancel_FromCancel(); //キャンセルで出した場合は空キャン不可に
	}
	function HitInterrupt_Std()
	{
		Battle_Std.MvRule_Atk_HitInterrupt();
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

Std_MoveTable.Mv_Atk_StdB <- 
{
	function Init_Std()
	{
		Battle_Std.InitGroundAtk(); //通常攻撃共通Init
		
		BMvTbl.SetComboLimit(DEF_BS_CL_STDB);
		BMvTbl.SetPattern(def_PAT_Atk_StdB);
		BMvTbl.SetSkillLv(def_MVSL_AtkStdB);
	}
	function Start_Std()
	{
		Battle_Std.StartGroundAtk();
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="立ち中攻撃" });
		
		Battle_Std.Sousai.FrameUpdate();
	}
	function HitInterrupt_Std()
	{
		Battle_Std.MvRule_Atk_HitInterrupt();
		Battle_Std.Sousai.HitInterrupt( { weak=2 } );
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}
Std_MoveTable.Mv_Atk_StdC <- 
{
	function Init_Std()
	{
		Battle_Std.InitGroundAtk(); //通常攻撃共通Init

		BMvTbl.SetComboLimit(DEF_BS_CL_STDC);
		BMvTbl.SetPattern(def_PAT_Atk_StdC);
		BMvTbl.SetSkillLv(def_MVSL_AtkStdC);
	}
	function Start_Std()
	{
		Battle_Std.StartGroundAtk();
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="立ち強攻撃" });
		
		Battle_Std.Sousai.FrameUpdate();
	}
	function HitInterrupt_Std()
	{
		Battle_Std.MvRule_Atk_HitInterrupt();
		Battle_Std.Sousai.HitInterrupt( { weak=2 } );
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

// しゃがみ通常技
Std_MoveTable.Mv_Atk_CroA <- 
{
	function Init_Std()
	{
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_AtkLow );
		Battle_Std.MoveCode.AddFlag( def_MC_GRDLowBreak ); // GRDブレイクの効果が短いMv

		Battle_Std.InitGroundAtk(); //通常攻撃共通Init
		
		if( BCMDTbl.CheckComboLimit( DEF_BS_CL_CROA2nd ) )
		{
			BMvTbl.SetComboLimit(DEF_BS_CL_CROA3rd);
		}
		else if( BCMDTbl.CheckComboLimit( DEF_BS_CL_CROA ) )
		{
			BMvTbl.SetComboLimit(DEF_BS_CL_CROA2nd);
		}
		else
		{
			BMvTbl.SetComboLimit(DEF_BS_CL_CROA);
		}
		
		BMvTbl.SetPattern(def_PAT_Atk_CroA);
		BMvTbl.SetSkillLv(def_MVSL_AtkCroA);
	}
	function Start_Std()
	{
		Battle_Std.StartGroundAtk();
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="しゃがみ弱攻撃" });
		
		Battle_Std.NoWhiffCancel_FromCancel(); //キャンセルで出した場合は空キャン不可に
	}
	function HitInterrupt_Std()
	{
		Battle_Std.MvRule_Atk_HitInterrupt();
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}
Std_MoveTable.Mv_Atk_CroB <- 
{
	function Init_Std()
	{
		Battle_Std.InitGroundAtk(); //通常攻撃共通Init

		BMvTbl.SetComboLimit(DEF_BS_CL_CROB);
		BMvTbl.SetPattern(def_PAT_Atk_CroB);
		BMvTbl.SetSkillLv(def_MVSL_AtkCroB);
	}
	function Start_Std()
	{
		Battle_Std.StartGroundAtk();
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="しゃがみ中攻撃" });
		
		Battle_Std.Sousai.FrameUpdate();
	}
	function HitInterrupt_Std()
	{
		Battle_Std.MvRule_Atk_HitInterrupt();
		Battle_Std.Sousai.HitInterrupt( { weak=2 } );
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}
Std_MoveTable.Mv_Atk_CroC <- 
{
	function Init_Std()
	{
		Battle_Std.InitGroundAtk(); //通常攻撃共通Init

		BMvTbl.SetComboLimit(DEF_BS_CL_CROC);
		BMvTbl.SetPattern(def_PAT_Atk_CroC);
		BMvTbl.SetSkillLv(def_MVSL_AtkCroC);
	}
	function Start_Std()
	{
		Battle_Std.StartGroundAtk();
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="しゃがみ強攻撃" });
		
		Battle_Std.Sousai.FrameUpdate();
	}
	function HitInterrupt_Std()
	{
		Battle_Std.MvRule_Atk_HitInterrupt();
		Battle_Std.Sousai.HitInterrupt( { weak=2 } );
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}

//ジャンプ攻撃着地に与えるヒットステータス
local set_AirAtkLandStatus = function()
{
	local hitst = BMvTbl.GetMvHitStatus();
	if( hitst.Type&_HitType_Damage ) //ダメージ与えていたら
	{
		Battle_Std.PP_AddFlag( def_PP_AirAtkStatus, def_PP_AAS_Damage );
	}
	else if( hitst.Type&_HitType_Guard ) //ガードされていたら
	{
		Battle_Std.PP_AddFlag( def_PP_AirAtkStatus, def_PP_AAS_Guard );
	}

}

// ジャンプ通常技
Std_MoveTable.Mv_Atk_AirA <- 
{
	function Init_Std()
	{
		Battle_Std.MoveCode.AddFlag( def_MC_GRDLowBreak ); // GRDブレイクの効果が短いMv
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_AtkLow );
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_NoYSetVectorAirAtk );
		Battle_Std.PassBeforeMoveCodeEx( 3, def_MC3_CallComboChainMv );
		
		Battle_Std.InitAirAtk(); //通常攻撃共通Init
		
		Battle_Std.SetStatus_AirAtkStatus(); //ジャンプ攻撃の各種フラグをリセット＋立てる
		
		if( BCMDTbl.CheckComboLimit( DEF_BS_CL_AIRA2nd ) )
		{
			BMvTbl.SetComboLimit(DEF_BS_CL_AIRA3rd);
		}
		else if( BCMDTbl.CheckComboLimit( DEF_BS_CL_AIRA ) )
		{
			BMvTbl.SetComboLimit(DEF_BS_CL_AIRA2nd);
		}
		else
		{
			BMvTbl.SetComboLimit(DEF_BS_CL_AIRA);
		}

		BMvTbl.SetPattern(def_PAT_Atk_AirA);
		BMvTbl.SetSkillLv(def_MVSL_AtkAirA);
		

	}
	function Start_Std()
	{
		Battle_Std.StartAirAtk();
	}	
	function FrameUpdate_Std() : (set_AirAtkLandStatus)
	{
		Battle_Std.TypeSE_Play({ type="ジャンプ弱攻撃" });
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			set_AirAtkLandStatus(); // def_PP_AirAtkStatus に着地情報を入れる
			BMvTbl.SetFinalize(256); //着地したらLandへ
		}
		Battle_Std.CheckAirAtkFsiki(); // 切り替え中段は上段に変更
		
		Battle_Std.NoWhiffCancel_FromCancel(); //キャンセルで出した場合は空キャン不可に
	}
	function HitInterrupt_Std()
	{
		Battle_Std.MvRule_Atk_HitInterrupt();
		Battle_Std.MvRule_AirAtk_HitInterrupt();
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Atk_AirA_Land"] ); //デフォ,[code,mv]...
	}	
}

local set_AirAtk_LandMoveableFrame = function( nohit, shield, damage, guard, a_nohit, a_shield, a_damage, a_guard )
{
	local atkst = BMvTbl.GetPP(def_PP_AirAtkStatus);
	
	if( atkst&def_PP_AAS_Shielded ) //シールドされた
	{
		local frame = (atkst&def_PP_AAS_inAssault)? a_shield : shield;
		BMvTbl.SetMoveableFlag( { move=0, time=frame, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		
		if( Def_Sys_AirAtkShielded_NoCancel )
		{
			BMvTbl.SetAsStatusFlag( { normal=_CancelFlag_None, special=_CancelFlag_None, time=254, flag=_ClearFlag_ChangeMv } );//キャンセル不可能に　※判定ツールでキャンセルを設定していることがある
			Battle_Std.MoveCode.AddFlag( def_MC_Shielded ); // シールドを取られたMvとする
		}
	}
	else if( !(atkst&def_PP_AAS_Hit) ) //空振りした（ヒットorガードしなかった）
	{
		local frame = (atkst&def_PP_AAS_inAssault)? a_nohit : nohit;
		
		if( Def_Sys_ExtendAirAtk_LandDelayPlusFrame )
		{
			// 着地前がタメ行動かどうか見る
			// MEMO:着地もタメフラグ継続した方がいいかも
			if( Battle_Std.ChangeMoveCodeEx_CheckFlag( 1, def_MC1_ExtendAction ) )
			{
				// _dpn("タメジャンプ攻撃なので増やす");
				frame += Def_Sys_ExtendAirAtk_LandDelayPlusFrame;
			}
		}
		BMvTbl.SetMoveableFlag( { move=0, time=frame, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		
	}
	else if( atkst&def_PP_AAS_Damage ) //ダメージを与えた
	{
		local frame = (atkst&def_PP_AAS_inAssault)? a_damage : damage;
		BMvTbl.SetMoveableFlag( { move=0, time=frame, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );		
	}
	else if( atkst&def_PP_AAS_Guard ) //ガードされた
	{
		local frame = (atkst&def_PP_AAS_inAssault)? a_guard : guard;
		BMvTbl.SetMoveableFlag( { move=0, time=frame, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );		
	}
	BMvTbl.SetPP(def_PP_AirAtkStatus,0); //ジャンプ攻撃ステータス初期化
}

Std_MoveTable.Mv_Atk_AirA_Land <- 
{
	function Init_Std() : (set_AirAtk_LandMoveableFrame)
	{
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
		
		set_AirAtk_LandMoveableFrame(			//着地硬直を設定
		def_FL_AtkAirA_LandRecovery,			//空振りした
		def_FL_AtkAirA_LandRecovery_Shielded,	//シールドされた
		def_FL_AtkAirA_LandRecovery_Damage,		//ダメージを与えた
		def_FL_AtkAirA_LandRecovery_Guard,		//ガードされた
		def_FL_AtkAirA_LandRecovery_Assault		//アサルトから出して空振りした
		def_FL_AtkAirA_LandRecovery_AssaultShielded,	//アサルトから出してシールドされた
		def_FL_AtkAirA_LandRecovery_AssaultDamage,		//アサルトから出してダメージを与えた
		def_FL_AtkAirA_LandRecovery_AssaultGuard		//アサルトから出してガードされた
		);
	}
	function FrameUpdate_Std()
	{
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

Std_MoveTable.Mv_Atk_AirB <- 
{
	function Init_Std()
	{
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_NoYSetVectorAirAtk );
		Battle_Std.PassBeforeMoveCodeEx( 3, def_MC3_CallComboChainMv );

		Battle_Std.InitAirAtk(); //通常攻撃共通Init

		Battle_Std.SetStatus_AirAtkStatus(); //ジャンプ攻撃の各種フラグをリセット＋立てる
	
		BMvTbl.SetComboLimit(DEF_BS_CL_AIRB);
		BMvTbl.SetPattern(def_PAT_Atk_AirB);
		BMvTbl.SetSkillLv(def_MVSL_AtkAirB);

		if( Def_Sys_NoMoveAirBandCFall )
		{
			BMvTbl.SetMoveableFlag( { move=0, time=1000, flag=_ClearFlag_ChangeMv } ); // Mv中行動不能にする
		}
	}
	function Start_Std()
	{
		Battle_Std.StartAirAtk();
	}	
	function FrameUpdate_Std() : (set_AirAtkLandStatus)
	{
		Battle_Std.TypeSE_Play({ type="ジャンプ中攻撃" });
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			set_AirAtkLandStatus(); // def_PP_AirAtkStatus に着地情報を入れる
			BMvTbl.SetFinalize(256); //着地したらLandへ
		}
		Battle_Std.CheckAirAtkFsiki(); // 切り替え中段は上段に変更
		
		Battle_Std.Sousai.FrameUpdate();
	}
	function HitInterrupt_Std()
	{
		Battle_Std.MvRule_Atk_HitInterrupt();
		Battle_Std.MvRule_AirAtk_HitInterrupt();
		Battle_Std.Sousai.HitInterrupt( { weak=2, isAirAtk=1 } );
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Atk_AirB_Land"] ); //デフォ,[code,mv]...
	}	
}

Std_MoveTable.Mv_Atk_AirB_Land <- 
{
	function Init_Std() : (set_AirAtk_LandMoveableFrame)
	{
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
		
		set_AirAtk_LandMoveableFrame(			//着地硬直を設定
		def_FL_AtkAirB_LandRecovery,			//空振りした
		def_FL_AtkAirB_LandRecovery_Shielded,	//シールドされた
		def_FL_AtkAirB_LandRecovery_Damage,		//ダメージを与えた
		def_FL_AtkAirB_LandRecovery_Guard,		//ガードされた
		def_FL_AtkAirB_LandRecovery_Assault		//アサルトから出して空振りした
		def_FL_AtkAirB_LandRecovery_AssaultShielded,	//アサルトから出してシールドされた
		def_FL_AtkAirB_LandRecovery_AssaultDamage,		//アサルトから出してダメージを与えた
		def_FL_AtkAirB_LandRecovery_AssaultGuard		//アサルトから出してガードされた
		);	
	}
	function FrameUpdate_Std()
	{
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

Std_MoveTable.Mv_Atk_AirC <- 
{
	function Init_Std()
	{
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_NoYSetVectorAirAtk );
		Battle_Std.PassBeforeMoveCodeEx( 3, def_MC3_CallComboChainMv );

		Battle_Std.InitAirAtk(); //通常攻撃共通Init

		Battle_Std.SetStatus_AirAtkStatus(); //ジャンプ攻撃の各種フラグをリセット＋立てる
	
		BMvTbl.SetComboLimit(DEF_BS_CL_AIRC);
		BMvTbl.SetPattern(def_PAT_Atk_AirC);
		BMvTbl.SetSkillLv(def_MVSL_AtkAirC);
		
		if( Def_Sys_NoMoveAirBandCFall )
		{
			BMvTbl.SetMoveableFlag( { move=0, time=1000, flag=_ClearFlag_ChangeMv } ); // Mv中行動不能にする
		}
	}
	function Start_Std()
	{
		Battle_Std.StartAirAtk();
	}	
	function FrameUpdate_Std() : (set_AirAtkLandStatus)
	{
		Battle_Std.TypeSE_Play({ type="ジャンプ強攻撃" });
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			set_AirAtkLandStatus(); // def_PP_AirAtkStatus に着地情報を入れる
			BMvTbl.SetFinalize(256); //着地したらLandへ
		}
		Battle_Std.CheckAirAtkFsiki(); // 切り替え中段は上段に変更
		
		Battle_Std.Sousai.FrameUpdate();
	}
	function HitInterrupt_Std()
	{
		Battle_Std.MvRule_Atk_HitInterrupt();
		Battle_Std.MvRule_AirAtk_HitInterrupt();
		Battle_Std.Sousai.HitInterrupt( { weak=2, isAirAtk=1 } );
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Atk_AirC_Land"] ); //デフォ,[code,mv]...
	}	
}

Std_MoveTable.Mv_Atk_AirC_Land <- 
{
	function Init_Std() : (set_AirAtk_LandMoveableFrame)
	{
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
		
		set_AirAtk_LandMoveableFrame(			//着地硬直を設定
		def_FL_AtkAirC_LandRecovery,			//空振りした
		def_FL_AtkAirC_LandRecovery_Shielded,	//シールドされた
		def_FL_AtkAirC_LandRecovery_Damage,		//ダメージを与えた
		def_FL_AtkAirC_LandRecovery_Guard,		//ガードされた
		def_FL_AtkAirC_LandRecovery_Assault		//アサルトから出して空振りした
		def_FL_AtkAirC_LandRecovery_AssaultShielded,	//アサルトから出してシールドされた
		def_FL_AtkAirC_LandRecovery_AssaultDamage,		//アサルトから出してダメージを与えた
		def_FL_AtkAirC_LandRecovery_AssaultGuard		//アサルトから出してガードされた
		);		
	}
	function FrameUpdate_Std()
	{
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}



local pat_num_Eff_RunStep = BMvEff.GetPatternNum( { datatype=1, pat="Eff_RunStep" } );

Std_MoveTable.Mv_Null_RundDashEff <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove  | _ObjFlags_NoRender|_ObjFlags_EraseParentPatChange } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPattern(990); //非表示でパターン設定してないと0番のpatで色々なる
		
		BMvTbl.SetLP(0,0);//足音管理
	}
	function Update_Std() : (footstep_senum_array, pat_num_Eff_RunStep)
	{
		local player = BMvCore.GetPlayerCharaData();

		//足音のタイミングで表示する
		if( player.push() )
		{
			local oya_mvs = BMvTbl.GetMvStatus();
			player.pop();
			
			if( oya_mvs.isFrameUpdate && oya_mvs.Param0 == 10 )
			{
				local pos = BMvEff.Random_PointRect( { sx=-10, sy=-8, ex=10, ey=8 } );
				local eff = BMvEff.CreateObject( { start_pat=pat_num_Eff_RunStep, datatype=1, x=pos.x, y=pos.y, flags=_Position_ToolShift } );
				if( eff.push() )
				{
					BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround } );
					eff.pop();
				}
				
				local setype = BMvTbl.GetLP(0);
				BMvTbl.SetLP(0, 1-setype ); // 0 1 0 1 ...
				local use_senum = footstep_senum_array[ setype%footstep_senum_array.len() ];
				if( use_senum != -1 )
				{
					if( typeof use_senum == "array" )
					{
						BSound.SE_Play( { type=use_senum[0], num=use_senum[1] } );
					}
					else
					{
						BSound.SE_Play( { type=_SeType_Normal, num=use_senum } );
					}
				}
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

local pat_num_Eff_DashGKemuriS = BMvEff.GetPatternNum( { datatype=1, pat="Eff_DashGKemuriS" } );

//スライドダッシュエフェクト
Std_MoveTable.Mv_Null_SlideDashEff <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove  | _ObjFlags_NoRender|_ObjFlags_EraseParentPatChange } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPattern(990); //非表示でパターン設定してないと0番のpatで色々なる
	}
	function Update_Std() : (pat_num_Eff_DashGKemuriS)
	{
		local mvs = BMvTbl.GetMvStatus();

		if( mvs.MvCount%6==0 )
		{
			local pos = BMvEff.Random_PointRect( { sx=-10, sy=-8, ex=10, ey=8 } );
			local eff = BMvEff.CreateObject( { start_pat=pat_num_Eff_DashGKemuriS, datatype=1, x=pos.x, y=pos.y, flags=_Position_ToolShift } );
			if( eff.push() )
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_MoveTimeStopAll } );
				eff.pop();
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_Null_BackStepEff <-
{
	function Init_Std() : (pat_num_Eff_DashGKemuriS)
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove  | _ObjFlags_NoRender|_ObjFlags_EraseParentPatChange } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		local eff = BMvEff.CreateObject( { start_pat=pat_num_Eff_DashGKemuriS, datatype=1, x=0*128 } );
		if( eff.push() )
		{
			BMvTbl.SetMuki( _Direction_Reverse );
			
			eff.pop();
		}
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_Null_JumpLandEff <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove  | _ObjFlags_NoRender|_ObjFlags_EraseParentPatChange } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		local eff = BMvEff.CreateObject( { start_pat=20, datatype=1, x=0*128 } );
		if( eff.push() )
		{
			BMvTbl.SetMuki( _Direction_Reverse );
			
			eff.pop();
		}
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}




local dashstop_frame = chrparam.Get( { type="ダッシュ停止不能Ｆ", chrnum=_ChrNo } );
local dashnoatk_frame = chrparam.Get( { type="ダッシュ攻撃不能Ｆ", chrnum=_ChrNo } );
if( Def_Sys_DashStartupAct )
{
	dashnoatk_frame = 0;//これの設定だけだと6ABで通常技が漏れるので注意
}

local dash_effect_tbl = chrparam.Get( { type="前ダッシュエフェクト", chrnum=_ChrNo } );

local backdash_effect_tbl = chrparam.Get( { type="バックダッシュエフェクト", chrnum=_ChrNo } );
local backdashstop_effectmv = chrparam.Get( { type="バックダッシュ停止エフェクト", chrnum=_ChrNo } );

local dash_f_vector_tbl = chrparam.Get( { type="前ダッシュベクトル", chrnum=_ChrNo } );

local pat_num_Eff_DashGKemuriL = BMvEff.GetPatternNum( { datatype=1, pat="Eff_DashGKemuriL" } );
local pat_num_Eff_DashPar = BMvEff.GetPatternNum( { datatype=1, pat="Eff_DashPar" } );

//ダッシュ開始時のエフェクト呼び出し処理
//ダッシュエフェクトの管理オブジェクトも生成
local callDashInitEffect = function() : (dash_effect_tbl, pat_num_Eff_DashGKemuriL, pat_num_Eff_DashPar)
{
	// _dpn("callDashInitEffect");
	
	local scale = dash_effect_tbl.param[0]*100;
	local eff = BMvEff.CreateObject( { start_pat=pat_num_Eff_DashGKemuriL, datatype=1, x=100*128 } );
	if( eff.push() )
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_MoveTimeStopAll } );
		BMvTbl.SetScale( { x=scale, y=scale } );
		eff.pop();
	}
	local eff = BMvEff.CreateObject( { start_pat=pat_num_Eff_DashPar, datatype=1, x=100*128 } );
	if( eff.push() )
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_MoveTimeStopAll } );
		BMvTbl.SetScale( { x=scale, y=scale } );
		eff.pop();
	}
	local eff = BMvEff.CreateObject( { mvname=dash_effect_tbl.mv } ); //ダッシュ管理エフェクト呼び出し
	if( eff.push() )
	{
		//ObjectのInitタイミングだと既にMvが変化している可能性がある
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv } );
		eff.pop();
	}
	BSound.SE_Play( { type=_SeType_Player, num=42 } );//ダッシュSE呼び出し
}

//Mv_Dash_Fで呼ばれるダッシュのベクトルやエフェクトを呼び出す処理
local setDashFrontVector = function() : (dash_f_vector_tbl, callDashInitEffect)
{
	local mvs = BMvTbl.GetMvStatus();
	if( mvs.CallCount != 0 ) return 0;

	local mvcount = mvs.MvCount;
	if( mvcount in dash_f_vector_tbl )
	{
		local tmp = dash_f_vector_tbl[mvcount];

		local vec = { x=0, addx=0 };
		if( "x" in tmp ) vec.x = tmp.x;
		if( "addx" in tmp ) vec.addx = tmp.addx;
		if( "max" in tmp )
		{
			BMvTbl.SetVector_MaxX( tmp.max );
		}
		else
		{
			BMvTbl.SetVector_MaxX( 0 );
		}
		BMvTbl.SetVector( { x=vec.x, addx=vec.addx, flsgs=_Vector_Normal } );
		
		if( "effect" in tmp )
		{
			callDashInitEffect();
		}
	}
}

//キャラ差の生まれないダッシュっぽいベクトルやエフェクトを呼び出す処理
local setCommonDashFrontVector = function() : (callDashInitEffect)
{
	local mvs = BMvTbl.GetMvStatus();
	if( mvs.CallCount != 0 ) return 0;

	local mvcount = mvs.MvCount;
	if( mvcount == 0 )
	{
		BMvTbl.SetVector( { x=256, y=0, addx=0, addy=0, flags=_Vector_Normal } );
	}
	else if( mvcount == 5 )
	{
		BMvTbl.SetVector( { x=1600, y=0, addx=270, addy=0, flags=_Vector_Normal } );
		BMvTbl.SetVector_MaxX( 4000 );
		
		callDashInitEffect();
	}
}


Std_MoveTable.Mv_Dash_F <- // 前ダッシュ移動部分
{
	function Init_Std() : (dashnoatk_frame)
	{
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMuki(_Direction_Auto);
	
		BMvTbl.SetPattern(def_PAT_Dash_F); //"DashFLoop"

		if( Def_Sys_DashStartupAct != 1 )
		{
			//ボイス再生
			Battle_Std.TypeSE_Play({ type="前ダッシュ" });
		}
		
		BMvEff.CreateObject( { mvname="Mv_DashCountObject" } ); //ダッシュカウンタ管理
		
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_PositiveAction ); // 行動コード(ポジティブ)を設定
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
		
		//BMvTbl.SetLP(8,0); // デバッグ用、ガードフラグ
		BMvTbl.SetLP(9,0); // 反対に向かってダッシュしている時間
		
		//dashnoatk_frame だけ硬直で、その後は行動可能だがガードはできない。dashstop_frame を超えるとダッシュ停止に進めるのでガードができる。
		BMvTbl.SetMoveableFlagEx( { move=0, timeA=dashnoatk_frame, timeB=255, flag=_ClearFlag_ChangeMv  } );
	}
	function Update_Std() : (dashstop_frame, dashnoatk_frame)
	{
		//ダッシュ投げとか用にベクトル記憶しておく
		local vec = BMvTbl.GetVector( { flags=_Vector_Normal } );
		BMvTbl.SetVector( { x=vec.x, addx=vec.addx, flags=_Vector_Keep } );
		
		local s = BMvTbl.GetMvStatus();
		
		if( Def_Sys_DashStartupAct == 1 && s.MvCount == 5 )
		{
			//ボイス再生
			Battle_Std.TypeSE_Play({ type="前ダッシュ" });
		}
		
		//FrameIDが100だと途中で停止できるタイプのダッシュなんだ
		if( s.FrameID == 100 && s.MvCount>dashstop_frame) // ホールド可
		{
			// if( !BMvTbl.CheckStickHold( (1<<6) | (1<<3) ) && !(BMvTbl.CheckButtonHold( (1<<0)|(1<<1) )>=100) ) // 6か3にはいっていなかったら,A+B
			//A+Bも条件にいれると、ダッシュ中に攻撃が出せなかったりで、推奨する操作としてはいまいち
			// if( !BMvTbl.CheckStickHold( (1<<6) | (1<<3) ) ) // 6か3にはいっていなかったら
			if( !BMvTbl.CheckStickHold( (1<<6) | (1<<3) | (1<<0) | (1<<2) ) ) // 6か3か0にはいっていなかったら
			{
				BMvTbl.SetFinalize(0);			
			}
			if( BMvTbl.CheckStickHold( (1<<0)|(1<<2) ) ) // 0のときは相手が近いととまる
			{
				if( s.MvCount > 120 )
				{
					BMvTbl.SetFinalize(0);
				}
				if( Battle_Std.CheckEnemyDistance( 185 ) )
				{
					BMvTbl.SetFinalize(0);
				}
			}
			
			//走りすぎは止める(念の為)
			if( s.MvCount > 600 )
			{
				BMvTbl.SetFinalize(0);
			}
		}
		
		if( s.MvCount==dashnoatk_frame )
		{
			//ここから先は行動可能
			// _dp("\n 行動可能");
			// 2にした方が操作性は良いが、ダッシュでくぐるとバクステが漏れたりするので×
			BMvTbl.SetCommandLongDelay(1); //受付時間増加（先行入力用）
			
			BMvTbl.SetMoveableFlag( { move=1, time=600, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする(念の為)
			if( Def_Sys_DashGuard == 0 )
			{
				BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=600, flag=_ClearFlag_ChangeMv } ); // ガード不可に
			}
			//BMvTbl.SetLP(8,1); // デバッグ用、ガードフラグ
		}

		/*
		if( BMvTbl.GetLP(8)==1 || !BCMDTbl.CheckCancel(_SkillType_None) )
		{
			// _dpn("ガードできないフレーム:"+s.MvCount);
		}
		*/
		
		// 離れるようなダッシュを検知してダッシュを止める
		// 向きが相手を向いているかどうかでチェック
		if( BMvTbl.CheckFurimuki() )
		{
			// 振り向き要求がある＝反対を向いている
			local count = BMvTbl.AddLP(9,1); // 反対向かっている時間
			if( count >= 40 )
			{
				BMvTbl.SetFinalize(0);
			}
		}
		else
		{
			BMvTbl.SetLP(9,0); // 反対に向かってダッシュしている時間を初期化
		}
	}
	function FrameUpdate_Std() : (setDashFrontVector)
	{
		//移動中行動可能にする（ダッシュの時間が分からないのでループにいれてる）
		// BMvTbl.SetMoveableFlag( { move=1, time=2, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding ) BMvTbl.SetFinalize(0);
		
		setDashFrontVector();

		// ダッシュ停止先をキャッシュ予約
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Dash_F_Stop, frame=0, rest=4 } );
	}
	function LastUpdate_Std() //ダッシュから抜けるときに呼ぶ
	{
		// LastUpdateタイミングでベクトル与えるときはやられ中かチェックする
		// つかまれ時のBound_Captureだとベクトル初期化がされないので動きっぱなしになる
		if( Battle_Std.CheckPlayerisBound() ) return; // バウンド時はなし
		
		local vec = BMvTbl.GetVector( { flags=_Vector_Normal } ); //vec に現在のベクトルを格納
		BMvTbl.SetVector( { x=vec.x, addx=-(vec.x/10),flags=_Vector_DivKeep } ); // 収束でダッシュ慣性を登録
		
		BMvEff.CreateObject( { mvname="Mv_DashKanseiMng"} );//
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_DashStop_F" );
	}		
}

Std_MoveTable.Mv_DashStop_F <- // 前ダッシュ停止
{
	function Init_Std() // 
	{
		BMvTbl.SetPattern(def_PAT_Dash_F_Stop); //DashFStop
		Battle_Std.InitCharaVector();
		
		//Battle_Std.JumpFrameIDEX(256, def_PAT_Dash_F, 0); //設定FrameID, 上書きPattern, 失敗時FinalizeCode
		//ダッシュ停止効果音の再生　29
		// BSound.SE_Play( { type=_SeType_Normal, num=176 } ); //_SeType_Normal ---汎用 _SeType_Player ---キャラ
		BMvEff.CreateObject( { datatype=1, start_pat=44 } );
		
		//停止は行動可能
		BMvTbl.SetMoveableFlag( { move=1, time=64, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_PositiveAction ); // 行動コード(ポジティブ)を設定
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}		
}


Std_MoveTable.Mv_DashCountObject <- //ダッシュカウンタを設定・初期化する
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender  } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		
		local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		if( player.push() )
		{
			BMvEff.StdCall( { type=6, no=102  , param=[ 1,0,0,0,0, 0,0,0,0,0, 0,0 ]} ); //ダッシュカウンタ
			
			player.pop();
		}
		
		BMvTbl.SetLP(0,0); // ダッシュじゃないMvになってから何フレーム経過したか
	}
	function FrameUpdate_Std() // 
	{
		//終了条件
		//ダッシュ以外で行動可能になる
		//ジャンプする
		// _dpn("チェック中");
		local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		local endflag = false;
		if( player.push())
		{
			local pmvs = BMvTbl.GetMvStatus();
			local isDashMv = Battle_Std.IsMatchMvNameArray( ["Mv_DashWait_F","Mv_Dash_F","Mv_DashStop_F"] );
			local isMovable = BCMDTbl.CheckCancel( _SkillType_None );
			local isAir = BMvTbl.CheckPosState( _PosState_Air );
			player.pop();
			
			//ジャンプしたら終了
			if( isAir ) endflag = true;
			
			//ダッシュ以外の行動になった
			if( !isDashMv )
			{
				//行動可能なら終了
				if( isMovable ) endflag = true;
				
				//ダッシュ以外の行動のまま少したっても終わる
				if( pmvs.CallCount==1 )//1Fに1回
				{
					BMvTbl.AddLP(0,1);//ダッシュ以外の行動時間加算
				}
				if( BMvTbl.GetLP(0)>16 )//16F
				{
					endflag = true;
				}
			}
			else
			{
				//ダッシュ中の行動
				BMvTbl.SetLP(0,0);//ダッシュじゃないMvの時間リセット
			}
		}
		
		if ( endflag )	
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		// _dpn("チェックおわり");
		local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得	
		if( player.push() )
		{
			BMvEff.StdCall( { type=6, no=103  , param=[ 1,0,0,0,0, 0,0,0,0,0, 0,0 ]} ); //ダッシュカウンタ
			
			player.pop();
		}
		BMvTbl.SetDeleteMoveTable();
	}
}


local dageki_mutekiF = chrparam.Get( { type="バクステ打撃無敵Ｆ", chrnum=_ChrNo } );
local nage_mutekiF = chrparam.Get( { type="バクステ投げ無敵Ｆ", chrnum=_ChrNo } );

Std_MoveTable.Mv_Dash_B <- // バクステ
{
	function Init_Std() :(dageki_mutekiF,nage_mutekiF)
	{
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Dash_B);
		BMvEff.SetPlayerTimer( { muteki_nage=nage_mutekiF, muteki_dage=dageki_mutekiF } ); //バクステの無敵時間
		BMvEff.SetPlayerTimer( { muteki_nageX=nage_mutekiF, muteki_dageX=dageki_mutekiF } ); //バクステの無敵時間
		Battle_Std.TypeSE_Play({ type="後ろダッシュ" });
		
		local isReversal = Battle_Std.Reversal.CheckTime_DrawInfo(); // リバーサルなら文字表示
		local isBtnDash = ( BMvTbl.GetCmdNumber()==def_CN_Dash_B_Douji )? 1 : 0;
		if( isBtnDash )
		{
			// _dp("\n ボタンダッシュ");
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_GenFlag ); // ボタンダッシュ	
		}
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
		
		if( Def_Sys_ChangeExtraBackStepMuteki )
		{
			//dageki_mutekiF+3Fだけ頭無敵がつく
			BMvTbl.SetHitCheckFlag( { type=0, val=_HitCheckFlag_Head|_HitCheckFlag_FireBall, time=dageki_mutekiF+Def_Sys_ChangeExtraBackStepMuteki, flag=_ClearFlag_ChangeMv } ); // 無敵
		}
		
		// 攻撃ではないけど、バクステを狩れたかどうかは知りたい情報なので例外的に入れる（前受身と同じイメージ）
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動

		//デバッグ用
		local pos = BMvTbl.GetPosition();
		BMvTbl.SetLP(9,pos.x);
		BMvTbl.SetLP(8,0);//無敵が切れたところ
	}
	function Update_Std() : (dageki_mutekiF)
	{
		if(1)
		{
			if( BMvTbl.GetMvStatus().MvCount == dageki_mutekiF )
			{
				local pos = BMvTbl.GetPosition();
				BMvTbl.SetLP(8,pos.x);
			}
			if( BMvTbl.GetMvStatus().MvCount == 10 )
			{
				local pos = BMvTbl.GetPosition();
				local start_pos = BMvTbl.GetLP(9);
				_dpn("旧無敵:"+(start_pos-pos.x)/128 );
			}
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
	function LastUpdate_Std()
	{
		local start_pos = BMvTbl.GetLP(9);
		local muteki_pos = BMvTbl.GetLP(8);
		local pos = BMvTbl.GetPosition();
		local mvs = BMvTbl.GetMvStatus();
		_dpn((mvs.MvCount-2)+","+(start_pos-pos.x)/128+","+(start_pos-muteki_pos)/128 );
	}
}

const Def_SMF_Shield_PlusHold = 600;//加えるホールド可能時間
const Def_SMF_Shield_HoldMargin = 10;//最低このFはボタン離しても効果なし
const Def_SMF_Shield_ReleaseMargin = 10;//ボタン離しのあと、硬直に進むまでのマージン（食らう直前にボタンを離してOKにする） -2F後にエフェクト縮小開始
const Def_SMF_Shield_SuccessWait = 15;//シールド成功後にシールドMVで何フレームとまるか　短いとシールド成功後に投げとかで確定とりやすい

local moonLvShieldStatus = [
	{ Lv= 0, SousaiFrame =19, EndFrame= 2, Delay = 5 },// 0 満タン・MoonDrive
	{ Lv= 1, SousaiFrame =19, EndFrame= 4, Delay = 7 },// 1
	{ Lv= 2, SousaiFrame =19, EndFrame= 4, Delay = 7 },// 2
	{ Lv= 3, SousaiFrame =19, EndFrame= 4, Delay = 7 },// 3
	{ Lv= 4, SousaiFrame =19, EndFrame= 4, Delay = 7 },// 4
	{ Lv= 5, SousaiFrame =19, EndFrame= 4, Delay = 7 },// 5 半分
	{ Lv= 6, SousaiFrame =21, EndFrame= 5, Delay = 8 },// 6
	{ Lv= 7, SousaiFrame =21, EndFrame= 5, Delay = 8 },// 7
	{ Lv= 8, SousaiFrame =21, EndFrame= 5, Delay = 8 },// 8
	{ Lv= 9, SousaiFrame =21, EndFrame= 5, Delay = 8 },// 9
	{ Lv=10, SousaiFrame =22, EndFrame= 6, Delay = 8 },//10 空
	
	{ Lv=11, SousaiFrame =16, EndFrame= 6, Delay = 7 },//11 空キャンシールド 満タン・MoonDrive
	{ Lv=12, SousaiFrame =16, EndFrame= 8, Delay = 5 },//12 空キャンシールド
	{ Lv=13, SousaiFrame =16, EndFrame= 8, Delay = 5 },//13 空キャンシールド
	{ Lv=14, SousaiFrame =16, EndFrame= 8, Delay = 5 },//14 空キャンシールド
	{ Lv=15, SousaiFrame =16, EndFrame= 8, Delay = 5 },//15 空キャンシールド
	{ Lv=16, SousaiFrame =16, EndFrame= 8, Delay = 5 },//16 空キャンシールド 半分
	{ Lv=17, SousaiFrame =16, EndFrame=11, Delay = 2 },//17 空キャンシールド
	{ Lv=18, SousaiFrame =16, EndFrame=11, Delay = 2 },//18 空キャンシールド
	{ Lv=19, SousaiFrame =16, EndFrame=11, Delay = 2 },//19 空キャンシールド
	{ Lv=20, SousaiFrame =16, EndFrame=11, Delay = 2 },//20 空キャンシールド
	{ Lv=21, SousaiFrame =16, EndFrame=13, Delay = 0 },//21 空キャンシールド 空
]
//SousaiFrame : シールドで取れる全体F＝被フェイタル時間。19FにしておくとBシルカンでフェイタルしない。
//EndFrame : フェイタル終了からの硬直。ループ。
//Delay : シールド終了後の硬直でガード可能になるまでのF。最大10F(PATの限界)
//Delay〜10Fの間は行動不可だがガードだけできる
//SousaiFrame=19で5F詐欺でちょいため開放がギリ取れるが、リバサ6F暴れに5F打撃で全対応できる

local getMoonLvShieldStatus = function( lv = -1 ) : (moonLvShieldStatus)
{
	local penalty_lv = 0;
	if( lv == -1 )
	{
		//月ゲージの残量でペナルティレベルを決める
		if( Battle_Std.MoonDrive_IsActive() )
		{
			penalty_lv = 0;
		}
		else
		{
			local moon_cost = tDDC.Moon_GetValue()/1000;//0〜10
			penalty_lv = 10 - moon_cost;
			// _dpn("moon_cost:"+moon_cost+" penalty_lv:"+penalty_lv);
		}
	}
	else
	{
		penalty_lv = lv;
	}
	// _dpn("penalty_lv:"+penalty_lv);
	
	return moonLvShieldStatus[penalty_lv];
}	

local makemv_Shield = function( param={} ) : ( shieldParams, getMoonLvShieldStatus )
{
	local retmv = {};
	
	local mvparam = 0;
	
	switch( param.type )
	{
	case "Std":
		mvparam = shieldParams.Std;
		break;
	case "Cro":
		mvparam = shieldParams.Cro;
		break;
	case "Air":
		mvparam = shieldParams.Air;
		break;
	}
	

	
	retmv.Init_Std <- function() : (mvparam, getMoonLvShieldStatus)
	{
		BMvEff.ClearGuardSP_Success(); // SPガードの成功状態を初期化（これorガードで初期化される）
		BMvEff.GuardSP_Set( { val=2 } ); //SPガード状態の設定
		
		// 振り向き処理
		// シールド返しのときは地上でも空中でも振り向くが、特定のフラグのときは振り向かない
		// 生発動のときは、地上でのみ振り向く（空中で振り向くと、シールドズラし押し空中投げで振り向きテクになる）
		
		// 相手の攻撃の状態次第では振り向かない
		// 6CとかシールドカウンターCの最初の方とか
		local no_furimuki_sc = 0;//シールドのときに振り向かない属性があるか
		local is_shield_cancel = Battle_Std.ChangeMoveCodeEx_CheckFlag( 0, def_MC_Shielded ); // シールド返しかどうか

		local from_shieldounter = Battle_Std.ChangeMoveCodeEx_CheckFlag( 4, def_MC4_ShieldCounter ); // 前の行動がシルカンかどうか（シルカンのシールド返しは弱め）
		local from_airshield_almostlanded = Battle_Std.ChangeMoveCodeEx_CheckFlag( 5, def_MC5_AirShield_AlmostLanded ); // 着地間際に出した空中シールドか
		
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			if( Battle_Std.MoveCodeEx.CheckFlag( 4, def_MC4_NoFurimukase_ShieldCancel ) )// シールド返しのときに振り向かせない技
			{
				no_furimuki_sc = 1;
			}
			
			enemy.pop();
		}
		
		//シールドの使用回数をカウントアップ
		if( mvparam.activity_slot && mvparam.activity )
		{
			Battle_Std.CharaBattleActivity_Increment( mvparam.activity_slot, mvparam.activity );
		}
		
		BMvTbl.SetPattern( mvparam.initPat );
		if( mvparam.isAir )
		{
			//Xベクトルに制限かけて、空中ダッシュシールドとかでかっとばないように
			
			local vec = BMvTbl.GetVector( { flags=_Vector_Normal } );
			BMvTbl.SetVector( { x=vec.x, y=vec.y, addx=vec.addx, addy=vec.addy, flags=_Vector_Keep } );//保存
			local xMax = 3000;
			local addyMax = 200;
			local addyMin = 150;
			
			//前の行動がシールドとられ状態である（シールドキャンセルの空中シールド）
			if( is_shield_cancel )
			{
				if( !no_furimuki_sc )
				{
					Battle_Std.SetMukiAuto();
				}
				
				vec.y = -1400;
				vec.addy = 250;
				xMax = 500; // あんまり動かないように？
				
				if( Def_Sys_LowAirShieldCancel_AddYVec )
				{
					//y=-100 -1400で-2F　通常(〜1.32)
					//y=-  0 -2000で-2F
					//低すぎるときは補正をかける
					local pos = BMvTbl.GetPosition();
					if( pos.y >= -100*128 )
					{
						local par = pos.y/128 + 100;
						if( par > 100 ) par = 100;
						if( par <   0 ) par =   0;
						local add_y_vec = -600 * par / 100;
						if( add_y_vec )
						{
							vec.y = vec.y + add_y_vec;
						}
						_dpn("低空シールド返し:"+par+" addy:"+add_y_vec);
					}
				}
				
				
				if( vec.x >  xMax ) vec.x =  xMax;
				if( vec.x < -xMax ) vec.x = -xMax;
				
				if( vec.addy > addyMax ) vec.addy = addyMax;
				if( vec.addy < addyMin ) vec.addy = addyMin;//重力なしはありえない
				
				Battle_Std.InitCharaVector();//慣性とかXMAXを消す
				BMvTbl.SetVector( {  x=vec.x, addx=0, y=vec.y, addy=vec.addy, flags=_Vector_Normal } );
			}
			else
			{
				//通常の空中シールド
				if( vec.x >  xMax ) vec.x =  xMax;
				if( vec.x < -xMax ) vec.x = -xMax;
				
				if( vec.addy > addyMax ) vec.addy = addyMax;
				if( vec.addy < addyMin ) vec.addy = addyMin;//重力なしはありえない
				
				BMvTbl.SetVector( {  x=vec.x, addx=0, addy=vec.addy, flags=_Vector_Normal } );
			}
		}
		else
		{
			if( !no_furimuki_sc && !from_airshield_almostlanded )
			{
				Battle_Std.SetMukiAuto();
			}
			
			Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		}
		
		//シールドされキャンセルのときはカウンタを加算
		Battle_Std.AddShieldedCancelCount( 1 );
		
		//シールドエフェクト呼び出し
		Battle_Std.CallBarrierEffect( 0 );
		
		//シールド発生SE
		if( Def_Sys_GroShield_FromLandingAirShield && from_airshield_almostlanded )
		{
			// _dpn("二重に音声を再生しない");
		}
		else
		{
			Battle_Std.TypeSE_Play( { type="シールド発動" } );
		}
		BSound.SE_Play( { type=_SeType_Normal, num=36 } );
		
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
		
		local moon_shield_st = getMoonLvShieldStatus();
		local penalty_lv = moon_shield_st.Lv;
		
		//空キャンシールドの弱体化
		//処理を限定的にするため、行動不能から出していて、前の行動が立ちAかしゃがみAなら空キャン扱いにする
		if( Def_Sys_ChangeFrame_WhiffCancelShield )
		{
			local from_movable = (BMvTbl.GetMvCancel( _SkillType_None ) == 255);//行動可能から
			local from_mvname = BMvTbl.ChangeMv_GetMvName();
			local hit_status = ( BMvTbl.GetMvHitStatus().Type & _HitType_Hit )? 1 : 0;
			local whiff_cancel_shield = ( !from_movable && (!hit_status && (from_mvname == "Mv_Atk_StdA" || from_mvname == "Mv_Atk_CroA" ) ) )? 1 : 0;

			BMvTbl.SetLP(5,whiff_cancel_shield); //記憶
			
			if( whiff_cancel_shield )
			{
				_dpn("空振りキャンセルシールド");
				penalty_lv = penalty_lv + 11;//レベルを下げる
				BMvEff.AttackInfoString_Set({ word=def_AISW_Whiff_Penalty,} );//アナウンス表示
				
				//チュートリアル:mvflag=2 で検知可
				BMvTbl.SetTutoMvFlag( 2 );//空振りシールドのチュートリアル用フラグ
			}
		}
		// _dpn("シールドペナLV:"+penalty_lv+" PenaF:"+moon_shield_st.SousaiFrame+" Delay:"+moon_shield_st.Delay );

		BMvTbl.SetLP(1,0); // シールドに成功すると1,ヒットストップ終わると10
		BMvTbl.SetLP(2,-1); // ボタンを離したら硬直Fになる
		BMvTbl.SetLP(3,penalty_lv); // ペナルティLV
		BMvTbl.SetLP(4,-1); // 離した時間 -1:離してない 0〜:離してから何フレーム　※これを見てシールドエフェクトが変化
		BMvTbl.SetLPEx(1,5,0); // シールドで月を減らしたかどうか
		BMvTbl.SetLPEx(1,6,0); // シールド押しっぱなしカウンタ
		
		// シールド返しか記憶　1:シールド返し　10:シルカンのシールド返し
		local shield_cancel_st = 0;
		if( is_shield_cancel )
		{
			shield_cancel_st = 1;
			if( from_shieldounter )
			{
				shield_cancel_st = 10;
			}
		}
		
		BMvTbl.SetLPEx(1,7, shield_cancel_st); // シールド返しかどうか記憶　1:シールド返し　10:シルカンのシールド返し
		BMvTbl.SetLPEx(1,8,0); // シールドを離したときのMvCount記憶
		BMvTbl.SetLPEx(1,9,100); // シールドサイズ（子が参照）

		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_Shield );
		
		//投げ無敵の削除
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_nageX=0 } ); //無敵時間は無し
	}
	
	retmv.Update_Std <- function() : (mvparam, getMoonLvShieldStatus)
	{
		local mvs = BMvTbl.GetMvStatus();
		local mvCount = mvs.MvCount;
		local penalty_lv = BMvTbl.GetLP(3);
		local is_whiff_cancel_shield = (penalty_lv>=11);//空キャンシールドかどうか
		
		if( mvCount == 3 )
		{
			//同時押しの猶予考慮
			Battle_Std.InitShieldCost();
			
			// ↑にまとめてもいいかも
			if( Def_Sys_HoldShield_UseCost )
			{
				BMvTbl.SetPP(def_PP_MoonChargeTmp,0);//デメリットとしてムーンチャージのちょいため分を消す
			}
		}
		
		local end_ok_min_frame = getMoonLvShieldStatus(penalty_lv).SousaiFrame;
		
		//Dをはなしたちょっと後に終わる（バンッてボタンを押して離すとシールドとれない対策）
		//BMvTbl.GetPP(def_PP_ShieldPenalty);
		local shield_end = 0;
		{
			if( BMvTbl.GetLP(4) != -1 ) // 一度でもボタンを離した
			{
				local release_frame = BMvTbl.AddLP(4,1);//Dを離してからの時間を加算
				local release_timing_mvcount = BMvTbl.GetLPEx(1,8);
				
				local end_timing = release_timing_mvcount + Def_SMF_Shield_ReleaseMargin - 1; // このフレームで終わるはず
				if( end_timing < end_ok_min_frame )
				{
					end_timing = end_ok_min_frame;
				}
				local left_frame = end_timing - mvCount;
				local max_frame = (Def_SMF_Shield_ReleaseMargin - 2);
				if( max_frame < 1 ) max_frame = 1; //0divしない用
				if( left_frame <= max_frame )
				{
					// シールドサイズ調整
					local left_par = left_frame * 100 / max_frame;
					
					local shield_size_par = 60 + (left_par*30/100);//シールドエフェクトを小さくしたい
					if( shield_size_par <  50 ) shield_size_par =  50;
					if( shield_size_par > 100 ) shield_size_par = 100;
					// _dpn("left_frame:"+left_frame+" left_par:"+left_par+"shield_size_par:"+shield_size_par);
					BMvTbl.SetLPEx(1,9,shield_size_par); // シールドサイズ（子が参照）
					
				}
				// _dpn("left_frame:"+left_frame);
			}

			local releaseBtn = (is_whiff_cancel_shield || BMvTbl.CheckButtonHold( (1<<3) ) == 0);//Dを離したかどうか
			if( releaseBtn )
			{
				local release_cnt = BMvTbl.GetLP(4);
				if( release_cnt == -1 )
				{
					BMvTbl.SetLP(4,1);//ボタンを離したのを記憶、カウント開始
					BMvTbl.SetLPEx(1,8,mvCount); // 離したときのMvCountを記憶
				}
				if( mvCount >= Def_SMF_Shield_HoldMargin && release_cnt >= Def_SMF_Shield_ReleaseMargin )
				{
					shield_end = 1;
				}
			}
			else
			{
				// Dホールドしてる
				// （空キャンシールドのときは、D押してても入らない）
				
				// シールド再度張り直し処理
				local about_last_released = ( BMvTbl.GetLP(4) != -1 ); // 過去にボタン離しをしてる（-1で再更新されるので要注意）
				if( about_last_released )
				{
					// 一度離してるっぽくてD押してるとき
					
					local d_release_mvcount = BMvTbl.GetLPEx(1,8); // D離したときのMvCount
					if( d_release_mvcount > 0 && mvCount >= end_ok_min_frame )
					{
						_dpn("一度D離したら、ホールド中の再張りは不可");
						
						local release_cnt = BMvTbl.GetLP(4);
						if( mvCount >= Def_SMF_Shield_HoldMargin && release_cnt >= Def_SMF_Shield_ReleaseMargin )
						{
							shield_end = 1;
						}
					}
					else
					{
						// 再貼り可能時間中にDホールドしてる
						_dpn("Dおしっぱで貼り直し");
						BMvTbl.SetLP(4,-1);//ボタンを離したの戻す
						BMvTbl.SetLPEx(1,8,0); // シールドを離したときのMvCount記憶
						BMvTbl.SetLPEx(1,9,100); // シールドサイズ（子が参照）
					}
				}
			}
		}
		//Def_SMF_Shield_ReleaseMargin
		
		
		/*
		// シールド返し自体が難しくなるおそれもあって、わかりにくさが結構あるので廃止
		// フェイタルとかは変わらず、パニッシュしない方向の方がよさそう？
		if( Def_Sys_ShieldCancelFrameBonus )
		{
			local is_shield_cancel = BMvTbl.GetLPEx(1,7);
			if( is_shield_cancel )
			{
				end_ok_min_frame = end_ok_min_frame-2;//硬直減る 2F減ると月0以外フェイタルしない
			}
		}
		*/
		if( mvCount < end_ok_min_frame ) // SousaiFrame
		{
			//保証フレーム中なので抜けることはできない
			BMvTbl.SetLPEx(1,6,mvCount); // シールド押しっぱなしカウンタ
		}
		else if( mvCount < end_ok_min_frame+Def_SMF_Shield_PlusHold )
		{
			//おしっぱ可能フレーム
			if( shield_end )
			{
				BMvTbl.SetFinalize( 0 );
			}
			
			
			//おしっぱ時間に応じて月が減っていく処理
			if( Def_Sys_HoldShield_UseCost )
			{
				//ムーンドライブ中はムーンドライブ時間を減らすべき
				
				local moon_is_min = Battle_Std.MoonIcon_CheckCost( 1000 );
				if( !moon_is_min )
				{
					//月が空のときはおしっぱすら不可
					BMvTbl.SetFinalize( 0 );
				}
				else
				{
					BMvTbl.AddLPEx(1,6,1); // シールド押しっぱなしカウンタ
				}
				
				local moon_upcnt = 45;//どれだけためたら1ブロック減るか
				
				// TODO:コストなくなりそうなら、エフェクトの縮小処理があった方が見やすい
				
				if( BMvTbl.GetLPEx(1,6)>=moon_upcnt )
				{
					BMvTbl.SetLPEx(1,6,0); // シールド押しっぱなしカウンタ初期化
					tDDC.Moon_AddValue( -1000 );// シールド失敗　ムーンドライブ中も減る（段階的の減り方の方がやりこみっぽい気はする）
					BMvTbl.SetLPEx(1,5,1); // シールドで月を減らしたかどうか
				}
			}
		}
		else
		{
			//おしっぱの限界をこえた
			BMvTbl.SetFinalize( 0 );
		}
		
		// _dpn(mvCount+1+" : Sousai");
	}
	
	retmv.FrameUpdate_Std <- function() : (mvparam)
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvparam.isAir )
		{
			if( mvs.isLanding )
			{
				// 着地時
				if( Def_Sys_GroShield_FromLandingAirShield )
				{
					// 1F減らすと格ゲー的なフレーム数になる
					local fall_frame = mvs.MvCount-1;
					local hold_d_button = (BMvTbl.CheckButtonHold( (1<<3) ) != 0)? 1 : 0;
					
					// 本来着地硬直があったはずのタイミングで着地シールドがだせるようになってしまうのはよくないので
					// 特定のMVでのみこの処理を反映させる
					local enable_mv = Battle_Std.ChangeMoveCodeEx_CheckFlag( 5, def_MC5_EnableAirToLandedShield ); // 着地間際シールド対応
					local check_furimuki = BMvTbl.CheckFurimuki(); // 相手が反対にいて振り向きが必要かどうか　※意図せず背向けシールドになるのはあんまりだ
					
					// _dpn("fall_frame:"+fall_frame+" hold_d_button:"+hold_d_button);
					if( enable_mv && fall_frame <= Def_Sys_GroShield_FromLandingAirShield && hold_d_button && !check_furimuki )
					{
						// シールドした直後に着地した
						Battle_Std.MoveCodeEx.AddFlag( 5, def_MC5_AirShield_AlmostLanded ); // 着地間際に出した空中シールド
						// 方向キーで立ちシールドとしゃがみシールドを切り替える
						if( BMvTbl.CheckStickHold( (1<<1)|(1<<2)|(1<<3) ) )
						{
							BMvTbl.SetFinalize(960);
						}
						else
						{
							BMvTbl.SetFinalize(950);
						}
					}
					else
					{
						BMvTbl.SetFinalize(900);//普通の着地へ
					}
				}
				else
				{
					BMvTbl.SetFinalize(900);
				}

			}
		}
	}
	
	retmv.SetShieldPenalty <- function( damage=0 ) : (mvparam)
	{
		//ここにくるのはシールド失敗時のみ
		// _dpn("シールド失敗であります！");
		
		//ヒート中は予約してたゲージ消費を消化
		local gauge_st = BMvEff.Liberate_Get();
		if( gauge_st == _SpGaugeMode_Liberate || gauge_st == _SpGaugeMode_OverLiberate )
		{
			BMvEff.SetSpGauge( { mode=_SpGauge_UseBuffer } );
		}
		//シールド返しのときは月の消費をなくす
		local isCancelShield = (Def_Sys_ChangeShieldCancelMoonCost && BMvTbl.GetLPEx(1,7) != 0)? 1 : 0; // シールド返しかどうか記憶　1:シールド返し　10:シルカンのシールド返し
		//失敗による月ゲージ減少
		//スカりによる減少と、被弾による減少がある
		// Def_ShieldFaildMoonAdd : シールド失敗時
		// Def_ShieldFatalDamageMoonAdd : 被弾時
		if( Def_ShieldFaildMoonAdd )
		{
			if( (!isCancelShield && BMvTbl.GetLPEx(1,5)==0) || damage ) // まだ減らしてない or 被弾（強制減らし）
			{
				BMvTbl.SetLPEx(1,5,0); // シールドで月を減らしたかどうか
				
				local add_moon = (damage)? Def_ShieldFatalDamageMoonAdd : Def_ShieldFaildMoonAdd;
				
				tDDC.Moon_AddValue( add_moon );// シールド失敗　ムーンドライブ中も減る
			}
		}
	}
	
	if( mvparam.isAir && mvparam.landMv )
	{
		retmv.Finalize_Std <- function() : (mvparam)
		{
			local fincode = BMvTbl.GetFinalizeCode();
			if( Def_Sys_GroShield_FromLandingAirShield && (fincode == 950 || fincode == 960) )
			{
				// 空中シールドから地上シールドに移行したとき
				_dpn("空中シールドから地上シールドへ移行");
			}
			else
			{
				SetShieldPenalty();//ファイナライズ時はまず失敗（成功時はガードのMVに進むので）
			}
			
			Battle_Std.SwitchNextMoveTable( mvparam.finMv, [900,mvparam.landMv], [950,mvparam.landStdMv], [960,mvparam.landCroMv] ); //デフォ,[code,mv]...
		}
	}
	else
	{
		retmv.Finalize_Std <- function() : (mvparam)
		{
			SetShieldPenalty();//ファイナライズ時はまず失敗（成功時はガードのMVに進むので）
			
			BMvTbl.SetNextMoveTable( mvparam.finMv );
		}
	}
	
	retmv.LastUpdate_Std <- function()
	{
		BMvEff.GuardSP_Set( { val=0 } ); //SPガード状態の解除
		
		BMvTbl.SetPP(def_PP_MoonChargeTmp,0);//終わるときに初期化
		
		if( BMvTbl.FromFinalize()==0 )
		{
			//途中で抜けたとき
			//シールド成功か、ズラし押しか、被弾したとき

			//ファイナライズ時以外で失敗にしたいとき…は失敗時と、ズラし押しで抜けたとき？
			if( BMvEff.GuardSP_Success() )
			{
				// _dpn("シールド成功での抜け")
			}
			else
			{
				if( Battle_Std.CheckPlayerisBound() || Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_Damaged ) )
				{
					//投げで被弾したとき(要するにフェイタル)
					//打撃は入ってこない
					SetShieldPenalty( 1 );//被弾用マイナス
				}
				else if( Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_DoujiEndYoyaku ) )
				{
					//ズラし押しで抜けた時にベクトルを戻す処理
					local vec = BMvTbl.GetVector( { flags=_Vector_Keep } );
					BMvTbl.SetVector( { x=vec.x, y=vec.y, addx=vec.addx, addy=vec.addy, flags=_Vector_Normal } );//保存を戻す
					
					//シールド発動音声やSEをフェードアウト
					Battle_Std.TypeSE_AllStop( { type="シールド発動", fadetime=0 } );
					BSound.SE_Stop( { type=_SeType_Normal, num=36, fadetime=0 } );
				}
			}
		}
	}
	
	
	return retmv;

}

Std_MoveTable.Mv_StdShield <- makemv_Shield( { type="Std" } );
Std_MoveTable.Mv_CroShield <- makemv_Shield( { type="Cro" } );
Std_MoveTable.Mv_AirShield <- makemv_Shield( { type="Air" } );

local makemv_ShieldSuccess = function( param={} ) : ( shieldParams)
{
	local retmv = {};
	
	local mvparam = 0;
	
	switch( param.type )
	{
	case "Std":
		mvparam = shieldParams.Std;
		break;
	case "Cro":
		mvparam = shieldParams.Cro;
		break;
	case "Air":
		mvparam = shieldParams.Air;
		break;
	}
	
	retmv.Init_Std <- function() : (mvparam)
	{
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_ShiledSuccess );
		
		//ディレイをかけて出せすぎるのは問題なので、一定時間でフラグは消える
		Battle_Std.PassBeforeMoveCodeEx( 4, def_MC4_Enable_ShieldCounter ); // シールドカウンターが出せる のを引き継ぎ
		
		// val=3でないと、設置飛び道具のシールドでガード切り替えできなくてハメになる
		// MvGuardとシールド成功後ガード切り替えできるまでは、val=3にして安全にする
		// val=2にしたら、D解除ですぐに行動可能になるようにする
		BMvEff.GuardSP_Set( { val=3 } ); //SPガード状態の設定　3 - ガード操作可能にする（背面もシールド可）
		
		BMvTbl.SetPattern( mvparam.initPat );
		
		//成功の絵まで進める
		if( BMvTbl.GetMvStatus().FrameID == 5 )
		{
			BMvTbl.JumpFrameID(10);
		}

		//シールドエフェクト呼び出し
		Battle_Std.CallBarrierEffect( 1 );
		
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_Shield );
		
		//投げ無敵の削除
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_nageX=0 } ); //無敵時間は無し
		
		// 通常シールドと同じ変数を使ってる（エフェクトが参照してるため）
		BMvTbl.SetLP(4,-1); // 離した時間 -1:離してない 0〜:離してから何フレーム　※これを見てシールドエフェクトが変化
		BMvTbl.SetLPEx(1,8,0); // シールドを離したときのMvCount記憶
		BMvTbl.SetLPEx(1,9,100); // シールドサイズ（子が参照）
	}
	
	retmv.Update_Std <- function() : (mvparam)
	{
		local mvs = BMvTbl.GetMvStatus();
		local mvCount = mvs.MvCount;
		local releaseBtn = (BMvTbl.CheckButtonHold( (1<<3) ) == 0);//Dを離したかどうか
		
		local shield_end = 0;
		{
			if( BMvTbl.GetLP(4) != -1 ) // 一度でもボタンを離した
			{
				local release_frame = BMvTbl.AddLP(4,1);//Dを離してからの時間を加算
				local release_timing_mvcount = BMvTbl.GetLPEx(1,8);
				
				local end_timing = release_timing_mvcount + Def_SMF_Shield_ReleaseMargin - 1; // このフレームで終わるはず
				if( end_timing < Def_SMF_Shield_SuccessWait )
				{
					end_timing = Def_SMF_Shield_SuccessWait;
				}
				local left_frame = end_timing - mvCount;
				local max_frame = (Def_SMF_Shield_ReleaseMargin - 2);
				if( max_frame < 1 ) max_frame = 1; //0divしない用
				if( left_frame <= max_frame )
				{
					// シールドサイズ調整
					local left_par = left_frame * 100 / max_frame;
					
					local shield_size_par = 60 + (left_par*30/100);//シールドエフェクトを小さくしたい
					if( shield_size_par <  50 ) shield_size_par =  50;
					if( shield_size_par > 100 ) shield_size_par = 100;
					// _dpn("left_frame:"+left_frame+" left_par:"+left_par+"shield_size_par:"+shield_size_par);
					BMvTbl.SetLPEx(1,9,shield_size_par); // シールドサイズ（子が参照）
				}
				// _dpn("left_frame:"+left_frame);
			}

			if( releaseBtn )
			{
				local release_cnt = BMvTbl.GetLP(4);
				if( release_cnt == -1 )
				{
					BMvTbl.SetLP(4,1);//ボタンを離したのを記憶、カウント開始
					BMvTbl.SetLPEx(1,8,mvCount); // 離したときのMvCountを記憶
				}
				if( mvCount >= Def_SMF_Shield_SuccessWait && release_cnt >= Def_SMF_Shield_ReleaseMargin )
				{
					shield_end = 1;
				}
			}
			else
			{
				// Dホールドしてる
				// （空キャンシールドのときは、D押してても入らない）
				
				// シールド再度張り直し処理
				local about_last_released = ( BMvTbl.GetLP(4) != -1 ); // 過去にボタン離しをしてる（-1で再更新されるので要注意）
				if( about_last_released )
				{
					// 一度離してるっぽくてD押してるとき
					
					local d_release_mvcount = BMvTbl.GetLPEx(1,8); // D離したときのMvCount
					if( d_release_mvcount > 0 && mvCount >= Def_SMF_Shield_SuccessWait )
					{
						_dpn("一度D離したら、ホールド中の再張りは不可");
						
						local release_cnt = BMvTbl.GetLP(4);
						if( mvCount >= Def_SMF_Shield_SuccessWait && release_cnt >= Def_SMF_Shield_ReleaseMargin )
						{
							shield_end = 1;
						}
					}
					else
					{
						// 再貼り可能時間中にDホールドしてる
						_dpn("Dおしっぱで貼り直し");
						BMvTbl.SetLP(4,-1);//ボタンを離したの戻す
						BMvTbl.SetLPEx(1,8,0); // シールドを離したときのMvCount記憶
						BMvTbl.SetLPEx(1,9,100); // シールドサイズ（子が参照）
					}
				}
			}			
		}		
		
		
		if( mvCount < Def_SMF_Shield_SuccessWait )
		{
		}
		else if( mvCount < Def_SMF_Shield_SuccessWait+Def_SMF_Shield_PlusHold )
		{
			//おしっぱ可能フレーム
			if( shield_end )
			{
				BMvTbl.SetFinalize( 0 );
			}
			else
			{
				if( Def_Sys_ShieldSuccessGuardStatusType )
				{
					// _dpn("押しっぱなしで意図的に待機してるので見た目とシールドの性能を揃える");
					BMvEff.GuardSP_Set( { val=2 } ); //SPガード状態の設定
				}
			}
		}
		else
		{
			//おしっぱの限界をこえた
			BMvTbl.SetFinalize( 0 );
		}
	}
	
	retmv.FrameUpdate_Std <- function() : (mvparam)
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvparam.isAir )
		{
			if( mvs.isLanding )
			{
				BMvTbl.SetFinalize(900);
			}
		}
	}
	
	if( mvparam.isAir && mvparam.landMv )
	{
		retmv.Finalize_Std <- function() : (mvparam)
		{
			Battle_Std.SwitchNextMoveTable( mvparam.finMvSuc, [900,mvparam.landMvSuc] ); //デフォ,[code,mv]...
		}
	}
	else
	{
		retmv.Finalize_Std <- function() : (mvparam)
		{
			BMvTbl.SetNextMoveTable( mvparam.finMvSuc );
		}
	}
	
	retmv.LastUpdate_Std <- function()
	{
		BMvEff.GuardSP_Set( { val=0 } ); //SPガード状態の解除
	}
	
	return retmv;

}


//シールドに成功するとMv_Guard > Mv_StdShieldSuccess と移行する
Std_MoveTable.Mv_StdShieldSuccess <- makemv_ShieldSuccess( { type="Std"} );
Std_MoveTable.Mv_CroShieldSuccess <- makemv_ShieldSuccess( { type="Cro"} );
Std_MoveTable.Mv_AirShieldSuccess <- makemv_ShieldSuccess( { type="Air"} );


//シールドエフェクトのＭｖ
Std_MoveTable.Mv_BarrierEff <-
{
	function Init_Std()
	{
		BMvTbl.SetLP(0,0); //状態。消滅フレームへ進んだかどうか。
	}
	function Update_Std()
	{
		if( Def_Sys_ChangeShieldEffect_EasyToSeeEnd )
		{
			// シールドエフェクトのサイズをシールド終了タイミングにあわせて小さくする
			if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) )
			{
				local player = BMvCore.GetPlayerCharaData();
				if( player.push() )
				{
					local mvname = BMvTbl.GetMvName();
					local shield_size_par = BMvTbl.GetLPEx(1,9); // シールドサイズ（子が参照）
					player.pop();
					
					// MvGuardのこともあるけど
					// ガード時はそもそもこのMV呼ばなければいいのでは説はある
					if( mvname == "Mv_StdShield" || mvname == "Mv_CroShield" || mvname == "Mv_AirShield" ||
					mvname == "Mv_StdShieldSuccess" || mvname == "Mv_CroShieldSuccess" || mvname == "Mv_AirShieldSuccess"
					)
					{
						// _dpn("shield_size_par:"+shield_size_par);
						
						if( shield_size_par <= 100 && shield_size_par >= 50 ) // 貼り直しがあるので等倍の100も処理
						{
							// _dpn("shield_size_par:"+shield_size_par);
							BMvTbl.SetScale( { x=shield_size_par*100, y=shield_size_par*100 } );
						}
					}
				}
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//シールドカウンター関係
Std_MoveTable.Mv_ShieldCounterGro <-
{
	function Init_Std()
	{
		Battle_Std.InitShieldCounter();
		
		BMvTbl.SetPattern(def_PAT_ShieldCounterGro);
		Battle_Std.SetVector_ApproachEnemy( { min=120*128, max=350*128, power=1000, frame=10, vecflags=_Vector_Div } );
	}
	function Start_Std()
	{
		if( !Battle_Std.TypeSE_Play({ type="シールド地上反撃" }) )
		{
			Battle_Std.TypeSE_Play({ type="シールド反撃" });
		}

		Battle_Std.Achievement_Unlock(17);//【トロフィー】シールドカウンター
		Battle_Std.CharaBattleActivity_Increment(85,"シールドカウンター(A)使用");
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount<3 )
		{
			BMvTbl.SetMuki( _Direction_Auto );
		}
		
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			if( !Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_GenFlag ) )
			{
				Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_GenFlag );//Mv内有効フラグ(無敵をクリアを記憶)
				BMvEff.SetPlayerTimer( { muteki_nage=5, muteki_dage=5 } ); //無敵をクリア
			}
			break;
		}
	}
	function HitInterrupt_Std()
	{
		if( Battle_Std.CheckDamageTiming_ExceptDown( 1 ) )
		{
			Battle_Std.SetPosition_DamageHanteiRect();
		}
		if( Battle_Std.SetImpactHitEffect( { aerial=1, frameid=100, offx=100, offy=-100 } ) ) // 
		{
		}
	}
	function Finalize_Std() : (val_ShieldCounterGro_FinalizeMv)
	{
		BMvTbl.SetNextMoveTable(val_ShieldCounterGro_FinalizeMv);
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //無敵をクリア
	}
}

Std_MoveTable.Mv_ShieldCounterAir <-
{
	function Init_Std()
	{
		Battle_Std.InitShieldCounter();

		BMvTbl.SetPattern(def_PAT_ShieldCounterAir);
		Battle_Std.SetVector_ApproachEnemy( { min=120*128, max=350*128, power=1000, frame=10, vecflags=_Vector_Div } );
		// BMvTbl.SetVector( { y=-1000, addy=250, flags=_Vector_Normal } );//発生6F時　Y=-2500
		BMvTbl.SetVector( { y=-1190, addy=250, flags=_Vector_Normal } );//発生9F時
		
		BMvTbl.SetHitCheckFlag( { type=1, val=_HitCheckFlag_Head, time=255, flag=_ClearFlag_ChangeMv } ); // 頭無敵にスカる
	}
	function Start_Std()
	{
		Battle_Std.TypeSE_Play({ type="シールド反撃" });

		Battle_Std.Achievement_Unlock(17);//【トロフィー】シールドカウンター
		Battle_Std.CharaBattleActivity_Increment(85,"シールドカウンター(A)使用");
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount<3 )
		{
			BMvTbl.SetMuki( _Direction_Auto );
		}
		
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			if( !Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_GenFlag ) )
			{
				Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_GenFlag );//Mv内有効フラグ(無敵をクリアを記憶)
				BMvEff.SetPlayerTimer( { muteki_nage=5, muteki_dage=5 } ); //無敵をクリア
				BMvTbl.SetVector( { x=0, y=0, addx=0, addy=250, flags=_Vector_Normal } );
			}
			break;
		}
	}
	function HitInterrupt_Std()
	{
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable("Mv_Neutral");
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //無敵をクリア
	}
}


//シールドダイブ
local makemv_ShieldCounterDive = function( param={} )
{
	local ret_tmpl = {};
	
	local mvParam = {
		jumpF = 6, //フェードで消えて攻撃PATに移るまでの時間　※フェードアウトの時間はアニメ的に固定
		moveF = 5, // 相手の裏に移動
		seachF = 13, // 攻撃開始から相手の位置にくっつくフレーム
		atkPat = def_PAT_ShieldDive,
		revShieldYuuyoF = 3, // フェードインより何フレ前から裏にいくか
	}
	
	switch( param.type )
	{
	case "Gro":
		break;
	case "Air":
		mvParam.atkPat = def_PAT_ShieldDiveAir;//発生早いPATじゃないと不自然に相手に張り付かせる必要が出る
		mvParam.seachF = 8;
		mvParam.revShieldYuuyoF = 3; // 5だと地上と同じファジー猶予3F、3だとファジー猶予1Fだが地上Bシルカンと揃う
		if( Def_Sys_NerfShieldCounter )
		{
			// 5F遅くする
			mvParam.jumpF = 6+5;
			mvParam.revShieldYuuyoF = 3+5;
		}
		break;
	}
	
	ret_tmpl.Init_Std <- function()
	{
		Battle_Std.InitShieldCounter();

		BMvTbl.SetPattern(def_PAT_Jump_F);
		
		//演出
		local pos = BMvTbl.GetPosition();
		if( pos.y >= -64*128 )
		{
			//おおよそ地面
			BMvEff.CreateObject( { datatype=1, start_pat=35 } );
		}
		
		BMvTbl.SetVector( { x=700, y=-2700, addy=200, flags=_Vector_Normal } );
		BMvTbl.SetAsStatusFlag( { normal=_CancelFlag_None, special=_CancelFlag_None, time=254, flag=_ClearFlag_ChangeMv } );
		
		BSound.SE_Play( { type=_SeType_Normal, num=170 } );
		
		Battle_Std.TypeSE_Play({ type="シールド裏反撃" });
		
		BMvTbl.SetDrawAlpha( { val=255, time=2, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );//不透明で開始（フェード準備）
		
		BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Add } ); //重なり判定無し
		
		//ジャンプ攻撃扱い
		BMvTbl.SetHitCheckFlag( { type=1, val=_HitCheckFlag_Head, time=255, flag=_ClearFlag_ChangeMv } ); // 頭無敵にスカる
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_NoFurimukase_ShieldCancel );// シールド返しのときに振り向かせない技
		
		if( Def_Sys_NerfShieldCounter )
		{
			Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_Impossible_ShieldCancel ); // シールド返し不可にする
		}
		
		local pos = BMvTbl.GetPosition();
		local muki = BMvTbl.GetMuki();
		BMvTbl.SetLP(0,pos.y);//開始Y座標を記憶
		BMvTbl.SetLP(1,muki);//開始向きを記憶　※ワープタイミングで位置関係からの更新あり（廃止）
		BMvTbl.SetLP(3,0); // 発動時どれくらい離れていたかによって遅らせる発生F

		BMvTbl.SetLP(4,0); // サーチ不可行動を検知すると1、以降サーチが弱くなる
		BMvTbl.SetLP(5,99); // 硬直F（着地硬直用）
		BMvTbl.SetLP(6,0); // ダメージを記憶（着地硬直用）
	}
	
	ret_tmpl.Start_Std <- function()
	{
		Battle_Std.Achievement_Unlock(17);//【トロフィー】シールドカウンター
		Battle_Std.CharaBattleActivity_Increment(86,"シールドカウンター(B)使用");
	}

	ret_tmpl.Update_Std <- function() : (mvParam)
	{
		local mvs = BMvTbl.GetMvStatus();
		local frame = mvs.MvCount;
		
		local active_delay = BMvTbl.GetLP(3);//距離によって遅らせる発生フレーム
		
		// _dpn("frame:"+frame+" active_delay:"+active_delay);
		
		local totalF = mvParam.jumpF+active_delay+mvParam.moveF; // これを超えるとフェードインする
		// _dpn(format("[%3d] jumpF:%d moveF:%d seachF:%d delay:%d -> %d",frame, mvParam.jumpF, mvParam.moveF, mvParam.seachF, active_delay, totalF ) );
		
		// totalF より前
		// frame < mvParam.jumpF : フェードアウト
		// frame >=mvParam.jumpF && frame < totalF : 透明で相手の前にひっつき
		// frame >= totalF-mvParam.revShieldYuuyoF && frame < totalF : 相手の背中に移動＆シールドで振り向き可能に

		// frame == mvParam.jumpF + active_delay : 攻撃PAT開始
		// frame == mvParam.jumpF + mvParam.moveF : 振り向き可能に（保険処理）

		// totalF より後
		// frame >= totalF : フェードイン
		// frame >= totalF && frame <= totalF + mvParam.seachF : 相手にサーチでひっついて空振りしないようにする
		
		//フェード関連
		if( frame < mvParam.jumpF )
		{
			// _dpn("フェードアウト中…");
			//フェードアウト
			local alpha = BMvTbl.GetDrawAlpha();
			alpha -= 40;
			if( alpha < 0 ) alpha = 0;
			BMvTbl.SetDrawAlpha( { val=alpha, time=10, flag=_ClearFlag_ChangeMv } );
		}
		else if( frame >=mvParam.jumpF && frame < totalF )
		{
			// _dpn("透明になって相手にひっついている...");
			if( frame == mvParam.jumpF )
			{
				// _dpn("ひっつく最初のフレーム");
				//最初に相手との距離に応じて発生を遅らせる
				//最大1000 これより遠いのはすべて最大
				//最小 500 これより近いのはすべて最低
				local kyori = abs(Battle_Std.GetEnemyDistance()/128);
				if( kyori <  500 ) kyori =  500;
				if( kyori > 1000 ) kyori = 1000;
				local kyori_par = (kyori-500)/5;
				// _dpn("距離:"+kyori+" kyori_par:"+kyori_par );
				
				local max_delay = 5;//最大遅延F
				local set_delay = max_delay * kyori_par / 100;
				BMvTbl.SetLP(3,set_delay);
				// _dpn("距離:"+kyori+" 割合:"+kyori_par+" 遅延F:"+set_delay);
				
				//相手のシールド返しの判定に出ないといけないので、相手の向きの逆の位置に出るようにする
				if(0)
				{
					//変にワープするので廃止、最初の移動の向き準拠に
					//性能的にはBシルカンは裏に行ってほしいが、とは言え見た目がおかしいのでやめる
					local enemy = BMvCore.GetEnemyCharaData();
					if( enemy.push() )
					{
						local emuki = BMvTbl.GetMuki();
						enemy.pop();

						BMvTbl.SetLP(1,emuki*-1);//反転
					}
				}
			}
			// _dpn("消えている状態");
			BMvTbl.SetDrawAlpha( { val=0, time=10, flag=_ClearFlag_ChangeMv } );
			BMvEff.SetObjectFlags( { flags= _ObjFlags_NoRender } );//描画自体を消してセイバーの剣も消す

			//この間、相手と同じ座標にしておく
			local epos = Battle_Std.GetEnemyPosition();
			local muki = BMvTbl.GetLP(1);
			BMvTbl.SetPosition( { x=epos.x-50*128*muki, y=epos.y - 90*128 } );

			Battle_Std.InitCharaVector();
		}
		else if( frame >= totalF )
		{
			//フェードイン
			local alpha = BMvTbl.GetDrawAlpha();
			alpha += 30;
			if( alpha > 255 )
			{
				alpha = 255;
			}
			BMvTbl.SetDrawAlpha( { val=alpha, time=10, flag=_ClearFlag_ChangeMv } );
		}
		
		if( Def_Sys_NerfShieldCounter && frame >= totalF-mvParam.revShieldYuuyoF && frame < totalF )
		{
			local epos = Battle_Std.GetEnemyPosition();
			local muki = BMvTbl.GetLP(1);
		
			// _dpn("振り向き可能へ");
			// 少し前の段階からシールドで振り向き可能にする
			Battle_Std.MoveCodeEx.DelFlag( 4, def_MC4_NoFurimukase_ShieldCancel );// シールド返しのときに振り向かせない技
			BMvTbl.SetPosition( { x=epos.x+50*128*muki, y=epos.y - 90*128 } );
		}
		
		if( frame == mvParam.jumpF+active_delay )
		{
			// _dpn("攻撃PATへ変更");
			BMvTbl.SetPattern( mvParam.atkPat );
			BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Add } ); //重なり判定無し
			Battle_Std.SetMukiAuto();//相手の方を振り向く
			BMvTbl.SetDrawAlpha( { val=0, time=10, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );//透明にしてフェード準備
		}
		
		//どんだけ発生が遅れても振り向かないフラグ消去時間は固定（保険処理）
		if( frame == (mvParam.jumpF+mvParam.moveF) )
		{
			// _dpn("振り向かないフラグ消去");
			Battle_Std.MoveCodeEx.DelFlag( 4, def_MC4_NoFurimukase_ShieldCancel );// シールド返しのときに振り向かせない技
		}
		
		if( frame == totalF )
		{
			// _dpn("フェード開始して攻撃");

			//重なりを出す前に、相手との距離を見てかなり近かったら必ず相手の背後かつ近くに出現するように調整する
			local epos = Battle_Std.GetEnemyPosition();
			local muki = BMvTbl.GetLP(1);
			BMvTbl.SetPosition( { x=epos.x+50*128*muki } );			

			//自分が行きたい先の壁に相手が張り付いてるなら中央へちょっと引っ張る
			BtlPl.SetPos_MakeGamenHajiSpace_Enemy( { x=50, muki=muki } );

			BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Erase } ); //重なり判定消去戻し
			BMvEff.EraseObjectFlags( { flags= _ObjFlags_NoRender } );
			Battle_Std.SetMukiAuto();
			
			Battle_Std.InitCharaVector();
			BMvTbl.SetVector( { x=-400, addx=0, y=-800, addy=100, flags=_Vector_Normal } );
		}

		if( mvParam.seachF > 0 && frame >= totalF && frame <= totalF + mvParam.seachF )
		{
			// _dpn("サーチ中:"+frame);
			//攻撃開始時に相手の近くだったとき、攻撃するまでの間ある程度サーチする
			local ppos = BMvTbl.GetPosition();
			local epos = Battle_Std.GetEnemyPosition();
			
			local width = abs(ppos.x - epos.x);//距離
			local height = epos.y - ppos.y;//距離　+だと自分より下、-だと自分より上
			
			// _dpn("height:"+height/128+" width:"+width/128);
			//相手がBCシルカンのときは追わない？
			local serch_ng = BMvTbl.GetLP(4);//サーチのひっつきをやらない条件
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				local emvname = BMvTbl.GetMvName();
				local no_seach = Battle_Std.MoveCodeEx.CheckFlag( 4, def_MC4_NoSeachShieldDive );
				local shielded = Battle_Std.MoveCode.CheckFlag( def_MC_Shielded );
				local shield = Battle_Std.MoveCodeEx.CheckFlag( 4, def_MC4_Shield );
				// _dpn("shielded:"+shielded+" shield:"+shield);
				
				enemy.pop();
				
				//同じような処理がいっぱい合っておかしいが…
				//BCシルカン、サーチ除外行動、シールド返し以外で別の行動にうつったら除外
				if( emvname == "Mv_ShieldedCancelEx" || no_seach || (!shielded && !shield) ) serch_ng = 1;
			}
			//相手がシールドのときは強めに追う？
			
			if( serch_ng )
			{
				BMvTbl.SetLP(4,1); // サーチ不可行動を検知すると1、以降サーチが弱くなる
			}
			
			//max_wは時間とともに低下していく
			local mode_cnt_par = (frame - totalF )*100 / mvParam.seachF;//0で割らないように
			if( mode_cnt_par <   0 ) mode_cnt_par =   0;
			if( mode_cnt_par > 100 ) mode_cnt_par = 100;
			// _dpn("mode_cnt_par:"+mode_cnt_par);

			local max_w = 150*128 + (250*mode_cnt_par/100*128); // この距離より離れていたらくっつく　時間経過でガバになっていく
			local max_h = 150*128 + (50*mode_cnt_par/100*128); // この距離より離れていたらくっつく
			
			if( !serch_ng )
			{
				BMvTbl.SetMuki( _Direction_Auto );//端で重なりがない相手だと当たらない事があるので向き調整
				
				if( width >= max_w )
				{
					local muki = BMvTbl.GetLP(1);
					local set_x = epos.x + (max_w*muki);
					BMvTbl.SetPosition( { x=set_x } );

					local move_len = abs(ppos.x - set_x);
					if( move_len > 0 )
					{
						//移動したときは少し慣性っぽくベクトルを残す
						local set_vecx = move_len/2;
						// _dpn("set_vecx:"+set_vecx);
						if( set_vecx > 1000 ) set_vecx = 1000;
						BMvTbl.SetVector( { x=set_vecx, flags=_Position_ChangeMuki } );
					}
				}
				if( height >= max_h )
				{
					local set_y = epos.y - max_h;
					BMvTbl.SetPosition( { y=set_y } );
					
					local move_len = abs(ppos.y - set_y);//移動距離
					if( move_len > 0 )
					{
						//移動したときは少し慣性っぽくベクトルを残す
						local set_vecy = move_len/2;
						if( set_vecy > 1000 ) set_vecy = 1000;
						BMvTbl.SetVector( { y=-set_vecy } );
					}					
				}
				else if( height <= -max_h )
				{
					local set_y = epos.y + max_h;
					BMvTbl.SetPosition( { y=set_y } );
					
					local move_len = abs(ppos.y - set_y);//移動距離
					if( move_len > 0 )
					{
						//移動したときは少し慣性っぽくベクトルを残す
						local set_vecy = move_len/2;
						if( set_vecy > 1000 ) set_vecy = 1000;
						BMvTbl.SetVector( { y=set_vecy } );
					}
				}
			}
		}
		
		//FrameUpdateでやると着地時に1Fズレるので注意
		if( Def_Sys_ShieldCounterB_ChangeRecovery )
		{
			local mvs = BMvTbl.GetMvStatus();
			if( BMvTbl.GetLP(5) > 0 && mvs.isUpdate )
			{
				local left_delayframe = BMvTbl.AddLP(5,-1);//減らす
				// _dpn("left_delayframe:"+left_delayframe);
				if( left_delayframe <= 0 )
				{
					// _dpn("行動可能に");
					BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } );
				}
			}
		}
	}

	ret_tmpl.FrameUpdate_Std <- function()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding )
		{
			BMvTbl.SetFinalize(100);
		}
		
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			local vec = BMvTbl.GetVector( { flags=_Vector_Normal } );
			BMvTbl.SetVector( { x=vec.x, addx=0, y=1300, addy=200, flags=_Vector_Normal } );
			BMvEff.SetPlayerTimer( { muteki_nage=3, muteki_dage=0 } ); //無敵をクリア（持続2F）
			if( Def_Sys_ShieldCounterB_ChangeRecovery )
			{
				BMvTbl.SetLP(5,19); // 硬直F 19F=ヒットで五分 16F=ヒットで+3F
			}
			break;
		}
	}
	
	ret_tmpl.HitInterrupt_Std <- function()
	{
		if( Battle_Std.CheckDamageTiming() )
		{
			BMvTbl.SetLP(6,1);//ヒットを記憶
		}
	}

	ret_tmpl.Finalize_Std <- function()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [100,"Mv_ShieldDiveLand"] ); //デフォ,[code,mv]...
	}
	
	ret_tmpl.LastUpdate_Std <- function()
	{
		BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Erase } ); //重なり判定消去戻し
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //無敵をクリア
		BMvEff.EraseObjectFlags( { flags= _ObjFlags_NoRender } );
	}
	
	return ret_tmpl;
}

Std_MoveTable.Mv_ShieldDive <- makemv_ShieldCounterDive( { type="Gro" } );
Std_MoveTable.Mv_ShieldDiveAir <- makemv_ShieldCounterDive( { type="Air" } );


Std_MoveTable.Mv_ShieldDiveLand <-
{
	function Init_Std()
	{
		Battle_Std.MoveCode.AddFlag( def_MC_Atk ); // 行動コード(通常技)を設定
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動

		Battle_Std.InitCharaVector();
		//着地パターンは判定ツール側で指定（絵によって着地絵が違うと思うので）
		
		//高空時の着地硬直を調整する
		if( Def_Sys_ShieldCounterB_ChangeRecovery )
		{
			local left_delayframe = BMvTbl.GetLP(5);//残りの硬直
			if( left_delayframe <= 0 )
			{
				BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } );
			}
			else
			{
				BMvTbl.SetMoveableFlagEx( { move=0, timeA=14, timeB=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
			}
		}
		else
		{
			BMvTbl.SetMoveableFlagEx( { move=0, timeA=14, timeB=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		}
		
		BMvTbl.SetAsStatusFlag( { normal=_CancelFlag_None, special=_CancelFlag_None, time=254, flag=_ClearFlag_ChangeMv } );
		
		// これを有効にすると着地もシールド返しできて読み合いが変わりすぎるので廃止
		// Battle_Std.PassBeforeMoveCodeEx( 0, def_MC_Shielded ); //シールドをとられたのを引き継ぐ
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable("Mv_Neutral");
	}
}

local pat_num_moon_skill = BMvEff.GetPatternNum( { datatype=1, pat="moon_skill" } );//事前に取得

local makemv_ShieldCounterEx = function( param={} ) : (pat_num_moon_skill, _ChrNo)
{
	local retmv = {};
	
	local mvparam = {
		isShieldCounter = 0,
		isShieldedCancel = 0,
		noSeachMove = 0,
		setHoseiPenalty = 0,
	};
	
	switch( param.type )
	{
	case "ShieldCounter":
		mvparam.isShieldCounter = 1;
		break;
	case "ShieldedCancel":
		mvparam.isShieldedCancel = 1;
		mvparam.noSeachMove = 1;
		mvparam.setHoseiPenalty = 1;
		break;
	}
	
	retmv.SetAngleVector <- function( param={} )
	{
		local vec = BMvEff.GetVector_FromAngle( { angle=param.angle, speed=param.speed } );
		BMvTbl.SetVector( { x=vec.x, y=vec.y, flags=_Vector_Normal } );
	}

	retmv.Init_Std <- function() : (mvparam, pat_num_moon_skill)
	{
		Battle_Std.InitShieldCounter();
		
		//万が一埋まっていたら着地してしまうので高さを0にする
		if( BMvTbl.GetPosition().y > 0 )
		{
			BMvTbl.SetPosition( { y=0 } );
		}

		BMvTbl.SetPattern(def_PAT_ShieldCounterEx);
		
		BMvTbl.SetLP(0,0);//ヒット時は1以上になって、毎フレーム減っていく
		BMvTbl.SetLP(1,0);//上記処理をやるかどうか

		BMvTbl.SetLP(3,0);//移動開始後1
		BMvTbl.SetLP(5,0);//着地したら1(保険処理)

		local eff = BMvEff.CreateObject( { datatype=1, start_pat=pat_num_moon_skill, x=0, y=-200*128 } );
		
		if( mvparam.noSeachMove )
		{
			Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_NoSeachShieldDive );//Bシルカンがサーチしない技
		}
		
		//シールドされキャンセルのときはカウンタを加算（違うときにリセットをしない）
		Battle_Std.AddShieldedCancelCount( 0 );
		
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_AirAtkKirikaeTyudanCheckStart ); // ここから出したジャンプ攻撃は切り替え中段チェックする
		
		//FrameIDジャンプがあるので抜け先を予約しておく
		Battle_Std.CallSkillSoonCaches( [200, 5] ); // FrameID, rest
	}
	retmv.Start_Std <- function() : (mvparam)
	{
		Battle_Std.TypeSE_Play({ type="シールド反撃" });
		
		if( Battle_Std.MoonDrive_IsActive() )
		{
			Battle_Std.Moon_UseMoonCost( Def_MoonShieldCounter_MoonDrive ); // 月を消費＆ゲージ増加制限(不足時という状況はないけど)
		}
		else
		{
			Battle_Std.Moon_UseMoonCost( Def_MoonShieldCounter ); // 月を消費＆ゲージ増加制限(不足時という状況はないけど)
		}
		
		if( mvparam.isShieldCounter )
		{
			Battle_Std.Achievement_Unlock(17);//【トロフィー】シールドカウンター
			Battle_Std.CharaBattleActivity_Increment(87,"シールドカウンター(B+C)使用");
		}
	}
	retmv.Update_Std <- function() : (mvparam)
	{
		local mvs = BMvTbl.GetMvStatus();
		local frame = mvs.MvCount;
		
		if( frame == 8-5 && BMvTbl.GetLP(5)==0 )
		{
			//移動開始
			//相手が近いときはあまり速度をあげないほうがいいかもだが固定で様子見
			SetAngleVector( { angle=0.4, speed=7000 } );
			
			//移動エフェクト
			Battle_Std.DrawAirDashPar( { x=0, y=-250 } );
			
			BMvTbl.SetLP(3,1);//移動開始後1
		}
		
		//ヒット後のズラし処理中
		if( BMvTbl.GetLP(1)==1 )
		{
			if( BMvTbl.GetLP(0)>0 ) //ヒット時は1以上になって、毎フレーム減っていく。なんフレズラすか
			{
				local left = BMvTbl.GetLP(0);
				BMvTbl.AddLP(0,-1);//ヒット中に減っていく
				local zure = left*left*27/10;
				if( zure > 200 ) zure = 200;
				if( zure <   0 ) zure = 0;
				// _dpn("zure:"+zure);
				
				local vec = BMvTbl.GetVector();
				local posst = BMvEff.GetAngle_FromVector( { x=vec.x, y=vec.y } );
				local pow = 6000*zure/100;
				
				// SetPositionで動かすと、次回updateまで内部の値は画面外扱いになってしまう
				// 1Pが外にいって、2Pが反対の向きに攻撃したり、コマンドの向きが逆になることがあるので、画面外補正が必要
				local vec = BMvEff.GetVector_FromAngle( { angle=posst.angle, speed=pow } );
				BtlPl.SetPos_SetPositionInStage( { x=vec.x, y=vec.y, flags=_Position_Add|_Position_ChangeMuki } ); // ステージ内補正付きSetPosition
				
				if( Def_Sys_ShieldedCancelExMuteki && mvparam.isShieldedCancel )
				{
					BMvEff.SetPlayerTimer( { muteki_nage=2, muteki_dage=2 } ); //無敵を延長　※updateなので1Fだと足りない
				}
				else
				{
					//移動中なので序盤だけちょっと無敵にする
					//5なのはBCシルカンをシールドしてBCシルカンで追いかけたときの発生がそこなため
					if( left >= 5 )
					{
						BMvEff.SetPlayerTimer( { muteki_nage=2, muteki_dage=2 } ); //無敵を延長　※updateなので1Fだと足りない
					}
				}
			}
			else
			{
				BMvTbl.SetLP(1,0);//ズラし処理は終わり
				BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Erase } ); //重なり判定消去戻し
				
				BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //無敵をクリア
				BMvTbl.SetVector( { x=1500, y=-1200, addx=0, addy=220, flags=_Vector_Normal } );
				
				//行動可能にする
				//シールドをとられたときは行動可能にしない
				Battle_Std.MoveCodeEx.DelFlag( 4, def_MC4_Impossible_ShieldCancel ); // 移動中のキャンセル不可を戻す
				BMvTbl.SetCommandLongDelay(2); //受付時間増加（先行入力用） ※2じゃないとシールドキャンセルが出しにくい
				// if( !Battle_Std.MoveCodeEx.CheckFlag( 0, def_MC_Shielded ) ) // 弱いので廃止
				{
					BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
				}
			}
		}
		else
		{
			BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Erase } ); //重なり判定消去戻し
		}
	}
	retmv.FrameUpdate_Std <- function()
	{
		local mvs = BMvTbl.GetMvStatus();
		local frame = mvs.MvCount;
		
		if( frame <= 3 && BMvTbl.GetLP(3)==0 && BMvTbl.GetLP(5)==0 ) // 移動開始前
		{
			//ベクトルを入れると他のシールドカウンターと逆向きに出てしまうことがあるので何もしない
			BMvTbl.SetMuki( _Direction_Auto );
		}
		
		if( mvs.isLanding )
		{
			// _dpn("着地");
			BMvTbl.SetLP(5,1);//着地したら1(保険処理)
		}
		
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100://攻撃開始
			break;
		case 150://持続途中
			break;
		case 200://持続終了
			BMvTbl.SetVector( { x=1500, y=-1200, addx=0, addy=220, flags=_Vector_Normal } );
			
			BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Erase } ); //重なり判定消去戻し
			if( BMvTbl.GetLP(1)==0 )
			{
				//ヒットしてないとき、持続＆無敵終了と同時に行動可能にする最強技にする
				BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //無敵をクリア
				Battle_Std.MoveCodeEx.DelFlag( 4, def_MC4_Impossible_ShieldCancel ); // 移動中のキャンセル不可を戻す
				BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
				BMvTbl.SetCommandLongDelay(2); //受付時間増加（先行入力用） ※2じゃないとシールドキャンセルが出しにくい
			}
			else if( BMvTbl.GetLP(1)==1 )
			{
				//ヒットしているor相殺のときは持続終了時の無敵を1Fつけて終わりにする
				//無敵をクリア…するけど1F余裕を入れてUpdateのズラし処理で無敵を続かせて、設置などに不自然に負けないようにする
				BMvEff.SetPlayerTimer( { muteki_nage=1, muteki_dage=1 } ); 
			}
			break;
		}
	}
	retmv.HitInterrupt_Std <- function() : (mvparam, _ChrNo)
	{
		if( Def_Sys_KeepActive_ScHitToPartner && Battle_Std.CheckDamageTiming_OnlyPartner( 1 ) )
		{
			_dpn("パートナーにヒットしたらパートナーを無敵にしつつ攻撃出現を復活させる");
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				local partner = BMvCore.GetPertnerCharaData();
				if( partner.push() )
				{
					// _dpn("ちょっと無敵にする");
					BMvEff.SetPlayerTimer( { muteki_dage=8 } ); //無敵
					partner.pop();
				}
				enemy.pop();
			}
			//ヒット数を復活させる
			BMvTbl.CalcHitValue(1);

			// ヒット情報初期化して以降のヒット処理をしない
			// また、初期化をしないとパートナーにあたったフラグが立ったままなので
			// CheckDamageTiming_OnlyPartnerに入り続けてしまう
			BMvTbl.ClearHitStatus();
			
			// ヒットストップを0にする
			BMvTbl.SetHitStop(0, _ValSet);
		}			
		
		if( Battle_Std.CheckHitTiming() )
		{
			//ヒット時や相殺時にグッと加速して、貫通っぽくする
			//相手位置に向けてワープとかすると、同技相殺のときちょっとおかしいのでやらない
			BMvTbl.SetLP(0,9);//ヒットストップ中に何フレーム進めるか
			BMvTbl.SetLP(1,1);//ヒットストップ中の移動処理中
			BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Add } ); //重なり判定無し
			Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_Impossible_ShieldCancel ); // 移動中はストップ中扱いなのでキャンセル不可に
			
			BMvTbl.JumpFrameID(200);//決めポーズ後落下へ進む
		}
		
		if( _ChrNo == Def_ChrNo_Chr017 )
		{
			if( Battle_Std.CheckSousaiHitTiming() )
			{
				//シールドカウンター同士で相殺したとき、時間停止のようになっているが設置はパートナーの攻撃などが確定してしまうのが見た目的によくない
				//ただ現状はそういうのもテクニックなので、頻度が高すぎるマーリオゥのシスターだけ限定で直す
				//そもそも停止中は無敵にした方が良い気はするが、時間停止中にカウントが進まない無敵設定がない
				local is_sc_sousai = 0;
				local enemy = BMvCore.GetEnemyCharaData();
				if( enemy.push() )
				{
					if( Battle_Std.MoveCodeEx.CheckFlag( 4, def_MC4_ShieldCounter ) )
					{
						_dpn("相手もシールドカウンターなのできっとシルカン同士の相殺");
						is_sc_sousai = 1;
						BMvTbl.SetHitCheckFlag( { type=0, val=Def_HitCheckFlag_Partner, time=2, flag=_ClearFlag_ChangeMv  } ); // パートナーと弾無敵(時間停止みたいなものなので短いFで良い)
					}
					enemy.pop();
				}
				if( is_sc_sousai )
				{
					BMvTbl.SetHitCheckFlag( { type=0, val=Def_HitCheckFlag_Partner, time=2, flag=_ClearFlag_ChangeMv  } ); // パートナーと弾無敵(時間停止みたいなものなので短いFで良い)
				}
			}
		}
		
		if( Battle_Std.CheckDamageTiming() )
		{
			if( mvparam.setHoseiPenalty && Def_Sys_ShieledBCShieldCounter_HoseiPenalty )
			{
				//シールドされBCは補正を少し悪くして特大リターンにならないように（元々70%）
				// BMvEff.ComboView_Set( { val=50, type=0 } ); // 上書き補正
				BMvEff.ComboView_Set( { val=70, type=1 } ); // 乗算補正
			}
		}
	}
	retmv.Finalize_Std <- function()
	{
		BMvTbl.SetNextMoveTable("Mv_Neutral");
	}
	retmv.LastUpdate_Std <- function()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //無敵をクリア
		BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Erase } ); //重なり判定消去戻し
		
		//空中浮遊しないように仕込み
		if( !Battle_Std.CheckPlayerisBound() && BMvTbl.GetLP(5)==0 )
		{
			//211004:着地したあとや被弾後に落下ベクトルを入れるのはおかしいので除外
			local vec = BMvTbl.GetVector( {  flags=_Vector_Normal } );
			if( vec.addy < 220 )
			{
				BMvTbl.SetVector( { addy=220 } );//最低限の重力を設定
			}
		}
	}
	
	return retmv;
}

Std_MoveTable.Mv_ShieldCounterEx <- makemv_ShieldCounterEx( { type="ShieldCounter" } ); // シールドカウンター
Std_MoveTable.Mv_ShieldedCancelEx <- makemv_ShieldCounterEx( { type="ShieldedCancel" } ); // シールドされキャンセル


//シールドの硬直部分
local makemv_ShieldDelay = function( param={} ) : (getMoonLvShieldStatus)
{
	local retmv = {};
	
	local mvparam =
	{
		initPat = def_PAT_Barrier_Std,
		finMv = "Mv_Neutral",
		isAir = 0,
		landMv = 0,
		plusDelay = 0,
	}
	
	switch( param.type )
	{
	case "Std":
		mvparam.initPat = def_PAT_Barrier_Std;
		// mvparam.finMv = "Mv_Neutral";
		mvparam.finMv = "Mv_StdShieldFree";
		break;
	case "Cro":
		mvparam.initPat = def_PAT_Barrier_Cro;
		// mvparam.finMv = "Mv_Crouch_Wait";
		mvparam.finMv = "Mv_CroShieldFree";
		mvparam.plusDelay = 2; // ペナルティに加算するフレーム
		break;
	case "Air":
		mvparam.initPat = def_PAT_Barrier_Air;
		mvparam.isAir = 1;
		mvparam.finMv = "Mv_AirShieldFall";
		mvparam.landMv = "Mv_AirShieldLand";
		break;
	}
	
	retmv.Init_Std <- function() : (mvparam)
	{
		//振り向きはおかしいので消した
		BMvTbl.SetPattern( mvparam.initPat );
		
		Battle_Std.CallBarrierEndEffect();
		
		BMvTbl.JumpFrameID(10); // ループ頭に
		
		BMvEff.GuardSP_Set( { val=0 } );//SPガードを解除
		
		// Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_Shield ); // シールドの硬直はシールド扱いにしない
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_NoAddDamageMoon ); // 被弾で月が増えない行動
		
		//ここから先はカウンターを消去する（Bシルカンでフェイタルしないように）
		BMvTbl.SetCounterHitFlag( { val=0, time=254, flag=_ClearFlag_ChangeMv } );//カウンターなし
		
		BMvTbl.SetLP(0,0);
		// BMvTbl.SetLP(1,0);//シールド成功したかどうか
		BMvTbl.SetLP(2,0); //Endへ進んだかどうか
		// BMvTbl.SetLP(3,0);//前の行動から引き継ぎ
		// BMvTbl.SetLPEx(1,7,0);//前の行動から引き継ぎ　シールド返しかどうか　0:生　1:シールド返し　10:シルカンのシールド返し
	}
	
	retmv.FrameUpdate_Std <- function() : (mvparam, getMoonLvShieldStatus)
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvparam.isAir )
		{
			if( mvs.isLanding )
			{
				BMvTbl.SetFinalize(900);
				return;
			}
		}
		
		local penalty_lv = BMvTbl.GetLP(3);
		local shield_end = getMoonLvShieldStatus(penalty_lv).EndFrame + mvparam.plusDelay;
		local shield_delay = getMoonLvShieldStatus(penalty_lv).Delay;
		local shield_sousai = getMoonLvShieldStatus(penalty_lv).SousaiFrame;
		
		// _dpn("mvs.MvCount:"+mvs.MvCount+" shield_end:"+shield_end+" shield_delay:"+shield_delay+" c:"+mvs.FrameCallCount );

		if( BMvTbl.GetLP(2)==0 && mvs.MvCount >= shield_end )
		{
			//ループアニメを終了して10Fの硬直へ(JumpFrameIDなので結果11Fになる)
			BMvTbl.SetLP(2,1); // Endへ進んだ
			BMvTbl.JumpFrameID(20); // ループ抜けの硬直部分
		}
		
		/*
		// 悪くはないけど大きく変わりすぎる
		local is_shield_cancel = BMvTbl.GetLPEx(1,7);//シールド返しかどうか　1:シールド返し　10:シルカンのシールド返し
		if( Def_Sys_ShieldCancelFrameBonus && is_shield_cancel )
		{
			BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		}
		*/
		local view_frame = mvs.MvCount + shield_sousai + 1;
		local direct_shield = ( BMvTbl.GetLPEx(1,7)==0 )? 1 : 0;//生シールド？
		if( Def_Sys_NoShieldCancel_DelayNoGuard && direct_shield )
		{
			shield_delay = shield_delay + Def_Sys_NoShieldCancel_DelayNoGuard; // 生シールドのときはガードできるまで遅くなる硬直増
		}
		

		if( !mvparam.isAir && mvs.MvCount >= (shield_end + shield_delay) )
		{
			//硬直は終わり
			if( Def_Sys_ShieldPenaltyDelayType )
			{
				//行動不能のまま・ガードだけ可能にする
				//生シールドのときは2F硬直のあとガード可能になる
				if( BMvTbl.GetLP(0)==0 )
				{
					BMvTbl.SetLP(0,1); // 処理終わり

					//ガード可能に
					// BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動不能にする　※不要だと思うが
					BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=254, flag=_ClearFlag_ChangeMv } ); // ガードを反転
				}
				
				if( Def_Dbg_LocalDebugMode && mvs.CallCount == 0 && view_frame <= (shield_sousai + shield_end + 10 ) )
				{
					_dpn(view_frame+" : ガードだけ可");
				}
			}
			else
			{
				BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
			}
		}
		else
		{
			if( Def_Dbg_LocalDebugMode && mvs.CallCount == 0 && view_frame <= (shield_sousai + shield_end + 10 ) )
			{
				_dpn(view_frame+" : 硬直");
			}
		}
		
		//PATの限界値にきたら終わる
		//この処理をしないとJumpFrameIDとFrameUpdateのタイミング次第で1Fズレてしまう（PATのFRAのDelay次第でズレる）
		if( mvs.MvCount >= shield_end + 10 && mvs.DataDelayVal != 0 && BMvTbl.GetFinalizeCode()==0 )
		{
			//mvs.DataDelayValのチェックはFinalizeを同時にやらないためにいれている
			BMvTbl.SetFinalize(0);
		}
	}
	
	if( mvparam.isAir && mvparam.landMv )
	{
		retmv.Finalize_Std <- function() : (mvparam)
		{
			Battle_Std.SwitchNextMoveTable( mvparam.finMv, [900,mvparam.landMv] ); //デフォ,[code,mv]...
		}
	}
	else
	{
		retmv.Finalize_Std <- function() : (mvparam)
		{
			BMvTbl.SetNextMoveTable( mvparam.finMv );
		}
	}
	
	retmv.LastUpdate_Std <- function()
	{
		BMvEff.GuardSP_Set( { val=0 } );//SPガードを解除
	}
	
	
	return retmv;

}

Std_MoveTable.Mv_StdShieldDelay <- makemv_ShieldDelay( { type="Std" } );
Std_MoveTable.Mv_CroShieldDelay <- makemv_ShieldDelay( { type="Cro" } );
Std_MoveTable.Mv_AirShieldDelay <- makemv_ShieldDelay( { type="Air" } );


local makemv_ShieldSucDelay = function( param={} )
{
	local retmv = {};
	
	local mvparam =
	{
		initPat = def_PAT_Barrier_Std,
		finMv = "Mv_Neutral",
		isAir = 0,
		landMv = 0,
	}
	
	switch( param.type )
	{
	case "Std":
		mvparam.initPat = def_PAT_Barrier_Std;
		// mvparam.finMv = "Mv_Neutral";
		mvparam.finMv = "Mv_StdShieldFree";
		break;
	case "Cro":
		mvparam.initPat = def_PAT_Barrier_Cro;
		// mvparam.finMv = "Mv_Crouch_Wait";
		mvparam.finMv = "Mv_CroShieldFree";
		break;
	case "Air":
		mvparam.initPat = def_PAT_Barrier_Air;
		mvparam.isAir = 1;
		mvparam.finMv = "Mv_AirShieldSucFall";
		mvparam.landMv = "Mv_AirShieldSucLand";
		break;
	}
	
	retmv.Init_Std <- function() : (mvparam)
	{
		BMvTbl.SetPattern( mvparam.initPat );
		
		Battle_Std.CallBarrierEndEffect();
		
		BMvTbl.JumpFrameID(20); // ループ頭に？
		
		BMvEff.GuardSP_Set( { val=0 } );//SPガードを解除
		
		// Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_Shield ); // これがあると被弾時にフェイタルしてしまう
		// Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動（動けるので違う）
		
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		
		// BMvTbl.SetLP(1,0);//シールド成功したかどうか
	}
	
	retmv.FrameUpdate_Std <- function() : (mvparam)
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvparam.isAir )
		{
			if( mvs.isLanding )
			{
				BMvTbl.SetFinalize(900);
			}
		}
	}
	
	if( mvparam.isAir && mvparam.landMv )
	{
		retmv.Finalize_Std <- function() : (mvparam)
		{
			Battle_Std.SwitchNextMoveTable( mvparam.finMv, [900,mvparam.landMv] ); //デフォ,[code,mv]...
		}
	}
	else
	{
		retmv.Finalize_Std <- function() : (mvparam)
		{
			BMvTbl.SetNextMoveTable( mvparam.finMv );
		}
	}
	
	retmv.LastUpdate_Std <- function()
	{
		BMvEff.GuardSP_Set( { val=0 } );//SPガードを解除
	}
	
	
	return retmv;

}

Std_MoveTable.Mv_StdShieldSucDelay <- makemv_ShieldSucDelay( { type="Std" } );
Std_MoveTable.Mv_CroShieldSucDelay <- makemv_ShieldSucDelay( { type="Cro" } );
Std_MoveTable.Mv_AirShieldSucDelay <- makemv_ShieldSucDelay( { type="Air" } );



Std_MoveTable.Mv_StdShieldFree <- // 地上シールドのフリーモーション
{
	function Init_Std() : (pat_StdShieldFreeMotion )
	{
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		if( pat_StdShieldFreeMotion )
		{
			BMvTbl.SetPattern(pat_StdShieldFreeMotion);
		}
		else
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

Std_MoveTable.Mv_CroShieldFree <- // 地上シールドのフリーモーション
{
	function Init_Std() : (pat_CroShieldFreeMotion )
	{
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		if( pat_CroShieldFreeMotion )
		{
			BMvTbl.SetPattern(pat_CroShieldFreeMotion);
		}
		else
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}


local pat_AirShieldModoriFall = chrparam.Get( { type="空中シールドからの戻りパターン", chrnum=_ChrNo } );

//シールド成功or失敗時の落下と着地
Std_MoveTable.Mv_AirShieldFall <-
{
	function Init_Std() : (pat_AirShieldModoriFall)
	{
		BMvTbl.SetPattern( pat_AirShieldModoriFall );
		local isSuccess = (BMvTbl.GetLP(1)>0);
		if( isSuccess )
		{
			BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		}
		else
		{
			BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動不能にする
			Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
			Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_NoAddDamageMoon ); // 被弾で月が増えない行動
		}

		// BMvTbl.SetLP(1,0);//シールド成功したかどうか
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding )
		{
			BMvTbl.SetFinalize(100);
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [100,"Mv_AirShieldLand"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_AirShieldSucFall <-
{
	function Init_Std() : (pat_AirShieldModoriFall)
	{
		BMvTbl.SetPattern( pat_AirShieldModoriFall );
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		// Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
		// Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_NoAddDamageMoon ); // 被弾で月が増えない行動
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding )
		{
			BMvTbl.SetFinalize(100);
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [100,"Mv_AirShieldSucLand"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_AirShieldLand <-
{
	function Init_Std()
	{
		BMvTbl.SetPattern(21);
		//シールドの着地硬直
		
		local shield_cancel_st = BMvTbl.GetLPEx(1,7); // シールドキャンセルかどうか　1:シールド返し　10:シルカンのシールド返し
		// _dpn("is_shield_cancel:"+is_shield_cancel);
		
		local isSuccess = (BMvTbl.GetLP(1)>0);
		if( isSuccess )
		{
			BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		}
		else 
		{
			// 着地硬直を設定　シールド返しのときは強いけど、シルカンのシールド返しは弱いまま
			local land_delay_frame = 12;
			if( shield_cancel_st == 1 )
			{
				land_delay_frame = 2;
			}
			else if( shield_cancel_st == 10 )
			{
				land_delay_frame = 12;//12Fのまま
			}
			BMvTbl.SetMoveableFlag({ move=0, time=land_delay_frame, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv }); //着地硬直
			Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
			Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_NoAddDamageMoon ); // 被弾で月が増えない行動
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable("Mv_Neutral");
	}
}

Std_MoveTable.Mv_AirShieldSucLand <-
{
	function Init_Std()
	{
		// Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
		// Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_NoAddDamageMoon ); // 被弾で月が増えない行動
		
		BMvTbl.SetPattern(21);
		//シールドの着地硬直
		
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable("Mv_Neutral");
	}
}


// 投げ
local set_dash_pattern = function()
{
	BMvTbl.SetPattern(def_PAT_Dash_F);
	// Battle_Std.TypeSE_Play({ type="前ダッシュ" });
	Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
	BMvTbl.SetMuki(_Direction_Auto); // 急に振り向くのはやっぱり変かな
}

Std_MoveTable.Mv_Throw_F_Dash <-
{
	function Init_Std() : (set_dash_pattern)
	{
		set_dash_pattern(); // 状況に応じたダッシュパターン設定
		
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_PositiveAction ); // 行動コード(ポジティブ)を設定
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
		Battle_Std.SetNoMovableMove(); // 動けないMV
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_EnableTech );
		
		Battle_Std.CharaBattleActivity_Increment(110,"地上投げ使用");
		Battle_Std.InitAtkSkillMv(); // 通常技や必殺技の共通初期化
		BMvTbl.SetCounterHitFlag( { val=1, time=254, flag=_ClearFlag_ChangeMv } );//カウンター
		
		BMvTbl.SetPP(def_PP_ThrowDashFrame,0); // ダッシュの時間記憶（投げ抜け用）
		BMvTbl.SetLP(0,0); // 次のフレームで投げるフラグ
	}
	function FrameUpdate_Std() : (setCommonDashFrontVector)
	{
		setCommonDashFrontVector(); //キャラ差のないダッシュっぽいエフェクトやベクトル処理

		local mvs = BMvTbl.GetMvStatus();
		local dash_frame = mvs.MvCount;

		if( dash_frame > 15 )
		{
			BMvTbl.SetFinalize(0);
		}

		//相手が近いならつかみにいく
		if( Battle_Std.CheckEnemyDistance( 185 ) )
		{
			//地上受身で跳ねているときに掴みに行くのアレなので除外
			local no_cap = 0;
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				if( Battle_Std.MoveCodeEx.CheckFlag( 3, def_MC3_WaitCap_ThrowFDash ) )
				{
					no_cap = 1;
				}
				enemy.pop();
			}
			
			//掴みに行かない条件をチェック
			if( !no_cap )
			{
				BMvTbl.SetLP(0,1); // 以降のフレームで投げモーションに進むフラグ
			}
		}
		
		if( BMvTbl.GetLP(0)==1 )
		{
			local enemy_is_throw_dash = 0;
			local enemy_dash_frame = 0;
			local enemy_is_shield_miss_guard = 0;
			
			//相手が投げ前のダッシュモーションで次Fで投げようとしてるときは、すぐに投げにいかない
			//相手が失敗シールドガード中は少し待機する
			
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				local emv = BMvTbl.GetMvName();
				if( emv == "Mv_Throw_F_Dash" || emv == "Mv_Throw_F" )
				{
					enemy_is_throw_dash = 1;
					enemy_dash_frame = BMvTbl.GetPP(def_PP_ThrowDashFrame);
				}
				if( Def_Sys_ShieldMissGuard_LastNoNageMuteki && emv == "Mv_Guard" )
				{
					if( Battle_Std.MoveCodeEx.CheckFlag( 5, def_MC5_ShieldMissGuard ) )
					{
						// _dpn("シールド失敗ガードみたいね");
						local bs = BtlMvStd.GetBoundStatus();
						if( bs.isBound )
						{
							if( bs.GetCountNow() > 3 ) // ちょい早めに終わってフレームを埋める
							{
								enemy_is_shield_miss_guard = 1;
							}
						}
					}
				}
				enemy.pop();
			}
			
			if( enemy_is_throw_dash )
			{
				local player_dash_frame = BMvTbl.GetPP(def_PP_ThrowDashFrame);//投げ抜け処理用に相手と揃えるためにPP版を使う
				if( player_dash_frame >= enemy_dash_frame )
				{
					//こっちの方が先にダッシュMvに入ったみたいなので投げへ進む
					BMvTbl.SetFinalize(0);
				}
				//相手が先にダッシュしてるっぽいしちょっと待つ
			}
			else if( enemy_is_shield_miss_guard )
			{
				// _dpn("待機");
			}
			else
			{
				BMvTbl.SetFinalize(0);
			}
		}
	}
	function Update_Std()
	{
		BMvTbl.AddPP(def_PP_ThrowDashFrame,1);
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Throw_F" );
	}
	function LastUpdate_Std() //ダッシュから抜けるときに呼ぶ
	{
		local vec = BMvTbl.GetVector( { flags=_Vector_Normal } ); //vec に現在のベクトルを格納
		if( Def_Sys_GroundDashThrow_MinVector )
		{
			if( vec.x < Def_Sys_GroundDashThrow_MinVector )
			{
				vec.x = Def_Sys_GroundDashThrow_MinVector;
			}
		}
		
		//めちゃ近いときは慣性なしにする
		//端背負いで投げスカ後に隙間生まれたりするのがアレなので入れてる
		//慣性自体はなるべくいれておかないと、投げが後ろ歩きでスカるので必要
		if( Def_Sys_TruncationThrowFDashVec )
		{
			local back_stage_kyori = Battle_Std.GetBackStageDistance();
			// _dpn("back_stage_kyori:"+back_stage_kyori);
			
			local mvcount = BMvTbl.GetMvStatus().MvCount;
			// _dpn("距離:"+Battle_Std.GetEnemyDistance()/128 ) 
			if( mvcount <= 0 && Battle_Std.CheckEnemyDistance( 160 ) && back_stage_kyori <= 0 ) // かなり近くて端背負いのときだけ
			{
				vec.x = 0;
			}
		}

		if( vec.x > 0 )
		{
			// _dpn("vec:"+vec.x);
			vec.x = vec.x * 40 / 100; // ダッシュ慣性のりにくくしてみる
			// _dp(" -> "+vec.x );
			BMvTbl.SetVector( { x=vec.x, addx=-(vec.x/10),flags=_Vector_DivKeep } ); // 収束でダッシュ慣性を登録
		}
	}
}

//投げ
Std_MoveTable.Mv_Throw_F <-
{
	function Init_Std() // 
	{
		// _dp("\n Mv_Throw_F_Init()");
		
		//基本的には投げ入力時の方向で投げるが
		//つかむ直前に入れ直してもそっちに投げる
		if( !BMvTbl.CheckStickHold( (1<<0) ) )
		{
			Battle_Std.SetTechReverse( 1 );//レバー逆入れならdef_PP_TechReverseに記憶
		}
		
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		Battle_Std.InitAtkSkillMv(); // 通常技や必殺技の共通初期化
		BMvTbl.SetCounterHitFlag( { val=1, time=254, flag=_ClearFlag_ChangeMv } );//カウンター
		
		//Battle_Std.InitVector(); // ベクトル初期化
		// BMvTbl.SetMuki(_Direction_Auto);//走って逆に振り向いたら変でしょ
		BMvTbl.SetPattern(def_PAT_Throw_F);
		BMvTbl.ClearHitStatus(); // ヒット情報のクリア
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_EnableTech );//投げ抜け可能な行動
		Battle_Std.MoveCode.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		Battle_Std.MoveCode.AddFlag( def_MC_GRDBreak_FatalDmgHosei ); // 行動コード(GRDブレイクで攻撃力アップ)を設定
		
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
		// Battle_Std.SetNoMovableMove(); // 動けないMV　※フリーモーションがあるキャラが多いので廃止

//		Battle_Std.DelPSFlag( def_PP_PS_isThrowMv ); //投げ属性モーションを削除
		//BMvTbl.SetLP(0,0); //カウンタ初期化
		BMvTbl.SetLP(1,0); //再生済みフラグ
		
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Throw_F_TechWait, frame=0, rest=2 } ); // 投げつかみ分岐先予約		
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Throw_F_Hit, frame=0, rest=6 } ); // 投げ成立先予約
		
		if( BMvTbl.GetCmdNumber()==def_CN_Throw_F && Battle_Std.GS_CheckFlag( def_PP_GS_SlideDashThrow ) ) // スライド投げ
		{
			_dp("\n ★★スライドダッシュ投げ★★");
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_GenFlag ); // Mv_Throw_F + def_MC1_GenFlag == スライド投げ
		}
		
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_TechCheck );//投げ抜けされる技
		
		if( Def_Sys_EnableGroundThrowWhiffGuard )
		{
			BMvTbl.SetVirtualGuardFlag( { val=16, time=4, flag=_ClearFlag_ChangeMv } ); // 特殊判定15を発生まで空振りガード判定にする
		}
		
		Battle_Std.GS_DelFlag( def_PP_GS_AtkToNoAddDamageMoon ); // 被弾で月が増えない行動への攻撃かどうかの記憶を初期化
	}
	function HitInterrupt_Std()
	{
		//この時点で相手はダメージ状態…ではない（つかみ命令入ってない）
		//のけぞりは当然入ってくる
		local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
		
		local isBMCapture = false;//金投げ
		local isNoAddDamageMoonMv = 0;
		if( enemy.push() )
		{
			local hs = BtlMvStd.GetBoundStatus();
			isBMCapture = ((hs.isCapture&(1<<1))!=0); //Bound or Muteki Capture
			//print("\nhs.isCapture"+hs.isCapture+" isBMCapture:"+isBMCapture);
			
			isNoAddDamageMoonMv = Battle_Std.MoveCodeEx.CheckFlag( 4, def_MC4_NoAddDamageMoon );
			enemy.pop();
		}
		local tukami_success = 0;
		if( isBMCapture ) //BM掴み（金投げ）かどうか
		{
			// _dm("Boundか投げ無敵中をつかんだので補正をかけます");

			//コンボ補正あり
			BMvEff.ComboView_Set( { val=def_HOSEI_BoundMutekiCapture, type=1 } ); // 乗算
			// BMvEff.StdCall( { type=6, no=112, param=[ def_HOSEI_BoundMutekiCapture,1,0,0,0, 0,0,0,0,0, 0,0 ]} );

			// Battle_Std.DrawDebugAttackInfo("! Gouin Nage");	
			tukami_success = Battle_Std.SetThrowHitFinalize(512); // ヒット分岐ファイナライズ
		}
		else
		{
			tukami_success = Battle_Std.SetThrowHitFinalize(256); // ヒット分岐ファイナライズ
		}

		if( tukami_success )
		{
			if( isNoAddDamageMoonMv )
			{
				Battle_Std.GS_AddFlag( def_PP_GS_AtkToNoAddDamageMoon );
			}
		}
		// 相手にフラグを与える
		if( enemy.push() )
		{
			// print("\n 状態セット:"+_AsFlag_DamageEx);
			// BMvTbl.SetAsFlag( { as_flags=_AsFlag_DamageEx, time=64, flag=0 } ); // 特殊やられ
			
			enemy.pop();
		}
	}
	function FrameUpdate_Std()//
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		//local mvcnt = BMvTbl.GetLP(0); //カウンタ取得
		//BMvTbl.AddLP(0,1); //1F進める
		
		if( s.MvCount>=6 && (BMvTbl.GetLP(1)==0) ) //投げ失敗確定後＆フラグがたっていない
		{
			BMvTbl.SetLP(1,1); //再生済み
			Battle_Std.TypeSE_Play({ type="投げスカり" });
			Battle_Std.MoveCodeEx.DelFlag( 7, def_MC7_EnableTech );//投げ抜け可能な行動
			
			BMvTbl.SetCounterHitFlag( { val=0, time=254, flag=_ClearFlag_ChangeMv } );//カウンターなし
		}
	}
	function Finalize_Std() : (_ChrNo)
	{
		//BMvTbl.SetLP(0,0); //カウンタ初期化
		BMvTbl.SetLP(1,0); //カウンタ初期化

		// Mv_Atk_ThrowMissはネコアルク専用の飛び先
		if( _ChrNo == Def_ChrNo_Chr019 )
		{
			Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Throw_F_TechWait"], [512,"Mv_Throw_F_TechWait2"], [1024,"Mv_Atk_ThrowMiss"] ); //デフォ,[code,mv]...
		}
		else
		{
			Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Throw_F_TechWait"], [512,"Mv_Throw_F_TechWait2"] ); //デフォ,[code,mv]...
		}
	}
	function LastUpdate_Std()
	{
	}
}



Std_MoveTable.Mv_Throw_F_TechWait <- //つかんでから投げ抜けを待つまで〜分岐
{	
	function Init_Std()
	{
		Battle_Std.InitVector(); // ベクトル初期化(一応)
		Battle_Std.MoveCode.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		Battle_Std.ThrowTech.SetMuteki(); //つかみ中は自分も相手も無敵にする	
		Battle_Std.PlayerSE_StopLastPlaySound( 1 ); //直前に再生した音声を停止
		Battle_Std.SetNoMovableMove(); // 動けないMV
		
		//前の行動のつかみ時の状況をチェック
		Battle_Std.PassBeforeMoveCodeEx( 7, def_MC7_EnemyTechImpossible );
		if( Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_EnemyTechImpossible ) )
		{
			BMvTbl.SetFinalize(512); //投げ抜けできないフレーム中なので終わろう
		}
		else //投げぬけ失敗フレームではない投げ
		{
			Battle_Std.EnemyCharaBattleActivity_Increment(121,"投げでつかまれた回数");
			
			//掴んだ相手側に投げられ回数を加算
			local enemy = BMvCore.GetCaptureCharaData();
			if( enemy.push() )
			{
				BMvEff.AddSkillCount( _SkillCount_Throw ); // 履歴カウンタを加算
				
				enemy.pop();
			}
			BMvEff.ThrowChara_SetCamera( 1 ); //投げているキャラをカメラ処理に含める
		}
		
		Battle_Std.ThrowTech.SetPos(); //つかむ前の自分と相手の座標を記憶する
		
		BMvTbl.SetPattern(def_PAT_Throw_F_TechWait); //投げ抜け待機パターンに変更(ここで相手はのけぞる)
		
		Battle_Std.ThrowTech.SetThrowParam(); //エフェクト座標に相手をやられ絵でセット
		
		//相手のけぞってからの処理
		Battle_Std.ThrowTech.ShiftOverGamenHajiX(); //相手が画面外にいたら自分の座標ごと補正をかける	
		Battle_Std.ThrowTech.DrawThrowEffect(0); //ヒット座標につかみエフェクト表示
		
		local enemy = BMvCore.GetCaptureCharaData();
		if( enemy.push() )
		{
			// BMvTbl.SetAsFlag( { as_flags=_AsFlag_DamageEx, time=255, flag=_ClearFlag_ChangeMv } ); // 特殊やられ
			
			enemy.pop();
		}
		
		Battle_Std.PassHitMoveCodes(); // ヒット分岐でのMvCode引継ぎ
	}
	function Update_Std() //投げぬけ猶予中
	{

		local s = BMvTbl.GetMvStatus(); // ステータス取得
		//print("\nTh1:Frame:"+s.FrameID);
		if( s.MvCount>def_FL_Tech )
		{
			BMvTbl.SetFinalize(0); //投げ抜け猶予が終わったので終わる
			return;
		}
		
		if ( Battle_Std.ThrowTech.CheckTechCommand() ) //相手が投げ抜けコマンドを入れた
		{
			local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
			if( enemy.push() )
			{
				local delay = def_FL_Tech - s.MvCount;
				// Battle_Std.DrawDebugAttackInfo("TechSafe: "+delay+"F" );
				
				enemy.pop();
			}
			
			Battle_Std.ThrowTech.DrawTechEffect(); //投げ抜け演出を表示
			Battle_Std.ThrowTech.TechRelease(); //投げ抜けされた時の開放処理
			BMvTbl.SetFinalize(256);
		}
	}
	function Finalize_Std() // 
	{
		local fin_code = BMvTbl.GetFinalizeCode();
		if( fin_code != 256 )
		{
			Battle_Std.CharaBattleActivity_Increment(111,"地上投げ成功");
			//投げ成功回数/(投げ成功回数+投げ失敗回数)
			Battle_Std.CharaBattleActivity_Calc( {
				title="地上投げ成功確率", 
				molecule=Battle_Std.CharaBattleActivity_Count("地上投げ成功"), denominator=(Battle_Std.CharaBattleActivity_Count("地上投げ成功")+Battle_Std.CharaBattleActivity_Count("地上投げ失敗"))
			} );
		}
		Battle_Std.SwitchNextMoveTable("Mv_Throw_F_Hit", [256,"Mv_Teched"],[512,"Mv_Throw_F_TechMissWait"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );	
		BMvEff.ThrowChara_SetCamera( 0 ); //投げているキャラをカメラ処理に含めない
	}
}


Std_MoveTable.Mv_Throw_F_TechWait2 <- //（金投げ）つかんでから投げ抜けを待つまで〜分岐
{	
	function Init_Std()
	{
		Battle_Std.InitVector(); // ベクトル初期化(一応)
		Battle_Std.MoveCode.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		Battle_Std.ThrowTech.SetMuteki(); //つかみ中は自分も相手も無敵にする	
		Battle_Std.PlayerSE_StopLastPlaySound( 1 ); //直前に再生した音声を停止
		Battle_Std.SetNoMovableMove(); // 動けないMV
		
		//前の行動のつかみ時の状況をチェック
		Battle_Std.PassBeforeMoveCodeEx( 7, def_MC7_EnemyTechImpossible )
		if( Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_EnemyTechImpossible ) )
		{
			BMvTbl.SetFinalize(512); //投げ抜けできないフレーム中なので終わろう
		}
		else //投げぬけ失敗フレームではない投げ
		{
			Battle_Std.EnemyCharaBattleActivity_Increment(121,"投げでつかまれた回数");
			
			//掴んだ相手側に投げられ回数を加算
			local enemy = BMvCore.GetCaptureCharaData();
			if( enemy.push() )
			{
				BMvEff.AddSkillCount( _SkillCount_Throw ); // 履歴カウンタを加算
				
				enemy.pop();
			}
			BMvEff.ThrowChara_SetCamera( 1 ); //投げているキャラをカメラ処理に含める
		}
		
		Battle_Std.ThrowTech.SetPos(); //つかむ前の自分と相手の座標を記憶する
		
		BMvTbl.SetPattern(def_PAT_Throw_F_TechWait); //投げ抜け待機パターンに変更(ここで相手はのけぞる)
		
		Battle_Std.ThrowTech.SetThrowParam(); //エフェクト座標に相手をやられ絵でセット
		
		//相手のけぞってからの処理
		Battle_Std.ThrowTech.ShiftOverGamenHajiX(); //相手が画面外にいたら自分の座標ごと補正をかける	
		Battle_Std.ThrowTech.DrawThrowEffect(1); //ヒット座標につかみエフェクト表示
		
		local enemy = BMvCore.GetCaptureCharaData();
		if( enemy.push() )
		{
			//※この処理なに？ 通常投げとの差異がある
			BMvTbl.SetAsFlag( { as_flags=_AsFlag_DamageEx, time=255, flag=_ClearFlag_ChangeMv } ); // 特殊やられ
			
			enemy.pop();
		}
		
		Battle_Std.PassHitMoveCodes(); // ヒット分岐でのMvCode引継ぎ
	}
	function Update_Std() //投げぬけ猶予中
	{

		local s = BMvTbl.GetMvStatus(); // ステータス取得
		//print("\nTh2:Frame:"+s.FrameID);
		
		if( s.MvCount>def_FL_BoundTech )
		{
			BMvTbl.SetFinalize(0); //投げ抜け猶予が終わったので終わる
			return;
		}
		
		if ( Battle_Std.ThrowTech.CheckTechCommand() ) //相手が投げ抜けコマンドを入れた
		{
			local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
			if( enemy.push() )
			{
				local delay = def_FL_BoundTech - s.MvCount;
				// Battle_Std.DrawDebugAttackInfo("TechSafe: "+delay+"F" );
				
				enemy.pop();
			}
			
			Battle_Std.ThrowTech.DrawTechEffect(); //投げ抜け演出を表示
			Battle_Std.ThrowTech.TechRelease(); //投げ抜けされた時の開放処理
			BMvTbl.SetFinalize(256);
		}
	}
	function Finalize_Std() // 
	{
		local fin_code = BMvTbl.GetFinalizeCode();
		if( fin_code != 256 )
		{
			Battle_Std.CharaBattleActivity_Increment(111,"地上投げ成功");
			//投げ成功回数/(投げ成功回数+投げ失敗回数)
			Battle_Std.CharaBattleActivity_Calc( {
				title="地上投げ成功確率", 
				molecule=Battle_Std.CharaBattleActivity_Count("地上投げ成功"), denominator=(Battle_Std.CharaBattleActivity_Count("地上投げ成功")+Battle_Std.CharaBattleActivity_Count("地上投げ失敗"))
			} );
		}
		Battle_Std.SwitchNextMoveTable("Mv_Throw_F_Hit", [256,"Mv_Teched"],[512,"Mv_Throw_F_TechMissWait"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );	
		BMvEff.ThrowChara_SetCamera( 0 ); //投げているキャラをカメラ処理に含めない
	}
}

// 投げ抜け不能フレームの時　と　行動不能を単純に掴んだ時 がある
Std_MoveTable.Mv_Throw_F_TechMissWait <- //投げ抜けされないつかみの時
{	
	function Init_Std()
	{
		Battle_Std.TypeSE_Play({ type="投げ抜けされないつかみ成功" });
		
		Battle_Std.MoveCode.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		Battle_Std.SetNoMovableMove(); // 動けないMV

		Battle_Std.ThrowTech.SetMuteki(); //つかみ中は自分も相手も無敵にする	
		
		Battle_Std.PassHitMoveCodes(); // ヒット分岐でのMvCode引継ぎ
	}
	function Update_Std() //投げぬけ猶予中
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		//すぐ投げるとわかりにくいのでdef_FL_BoundTech分まつ
		if( s.MvCount>def_FL_BoundTech ) BMvTbl.SetFinalize(0); //投げ抜け猶予が終わったので終わる
		//if( s.MvCount>def_FL_Tech ) BMvTbl.SetFinalize(0); //　演出長すぎだからこうする
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Throw_F_Hit", [256,"Mv_Teched"] ); //デフォ,[code,mv]...
	}	
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
	}	
}

Std_MoveTable.Mv_Throw_F_Hit <- //投げ成立（以降は投げ抜け不可）
{
	function Init_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
		Battle_Std.MoveCode.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		Battle_Std.SetNoMovableMove(); // 動けないMV
		
		//相手の無敵は解除
		local enemy = BMvCore.GetCaptureCharaData();
		if( enemy.push() )
		{
			BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );
			
			enemy.pop();
		}
	
		Battle_Std.TypeSE_Play({ type="投げつかみ成功" });
		
		//パターンが最後まできてれば次に進む。まだならUpdate中もチェックするからそこで。
		//local s = BMvTbl.GetMvStatus(); // ステータス取得					
		//if( s.DataPattern==def_PAT_Throw_F_TechWait && s.FrameID==0 )

		//逆投げだったらここで反転
		if( BMvTbl.GetPP(def_PP_TechReverse) == 1 )
		{
			// _dp("\n 後ろ投げ");
			BMvTbl.SetMuki(_Direction_Reverse);	//逆投げなんで反転
			Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_ReverseThrow );
		}
		
		Battle_Std.ThrowTech.SetThrowParam(); //エフェクト座標に相手をやられ絵でセット

		//パターンを変更
		BMvTbl.SetPattern(def_PAT_Throw_F_Hit);
		
		Battle_Std.Create_TechDelayCheckObject(); //相手の投げコマンドチェックオブジェクト生成
		
		Battle_Std.PassHitMoveCodes(); // ヒット分岐でのMvCode引継ぎ
		local isSidou = Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_SidouHitSkill );
		local isFatal = Battle_Std.EnemyDamageFlag_Check( def_DF_FatalCounter );
		local noAddDamageMoon = Battle_Std.GS_CheckFlag( def_PP_GS_AtkToNoAddDamageMoon );
		Battle_Std.GS_DelFlag( def_PP_GS_AtkToNoAddDamageMoon );//使ったので初期化
		
		if( enemy.push() )
		{
			// print("\n 状態クリア:"+_AsFlag_DamageEx);
			BMvTbl.SetAsFlag( { as_flags=_AsFlag_DamageEx, time=0, flag=0 } ); // 特殊やられを消す
			
			BMvTbl.SetCaptureHitFlag( { val=_CaptureHitFlag_Parent, time=255, flag=_ClearFlag_ChangeMv } ); // 掴んだ相手以外の攻撃がヒットしない
			
			if( isSidou && !isFatal && !noAddDamageMoon )
			{
				Battle_Std.Moon_AddValue(Def_DamageInitMoonAdd);//やられ初段でのボーナス
			}
			enemy.pop();
		}
		if( isSidou )
		{
			Battle_Std.Moon_AddValue(Def_AttackDamageInitMoonAdd,1);//攻撃初段でのボーナス（パートナー側からの呼び出しも有効）
			if( isFatal )
			{
				Battle_Std.Moon_AddValue(Def_FatalAttackDamageInitMoonAdd,1);//フェイタルのボーナス（パートナー側からの呼び出しも有効）
				
				if( Def_Sys_FatalHoseiBonus )
				{
					BMvEff.ComboView_Set( { val=def_HOSEI_FatalCounterThrow, type=1 } ); // 乗算
				}
			}
		}
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="投げ成功" });	
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
		
		//通常投げ始動は最低保証に制限をかける
		Battle_Std.SetHosyoHosei_Multi( def_HosyoHosei_NormalThrow );
		// Battle_Std.SetHosyoHosei( def_HosyoHosei_NormalThrow );
		
		if( !Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_GenFlag ) )//LastUpdateの追撃不能を消す
		{
			//そもそも基本的に追撃不能にする
			//MEMO:追撃不能にしたくなかったらなんかする？
			//MEMO:ムーンドライブでのみ追撃可能とか？
			Battle_Std.NoCansel_NoAttackHit();
		}
	}
}

//相手側に生成される
Std_MoveTable.Mv_Obj_CheckTechDelay <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender  } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );	
	}
	function Update_Std()
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		local flags = false;
		//print("\nFrame:"+s.MvCount);

		local p = BMvCore.GetPlayerCharaData(); // 情報を得る
		
		if( p.push() ) // 有効かどうか一応チェック
		{
			if( BMvTbl.CheckCommandString( { command="A+D", lastdelay=1 } ) ) flags = true;
			
			p.pop();
		}
		
		if( flags )
		{
			local frame = (s.MvCount+1);
			// Battle_Std.DrawDebugAttackInfo("TECH LATE: "+frame+"FRAME" );
			// _dm("投げ抜け:"+frame+"F遅い");
			BMvTbl.SetFinalize(0);
		}
		if( s.MvCount>60 ) BMvTbl.SetFinalize(0); //とりあえず遅すぎるのは終わる
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//投げ抜けする側はBoundです

Std_MoveTable.Mv_Teched <- //投げ抜けられ（つかんだ絵でプルプル）
{
	function Init_Std() // 
	{
		BMvTbl.SetPattern(def_PAT_GuardS); //立ちガードの見た目でプルプルする
		//BMvTbl.SetMuki(_Direction_Auto); //相手の方を向く
		Battle_Std.MvAction.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定 (バーストされない)
		
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );		
		BMvEff.SetExist( { level=_Exist_NoCamera, mode=_ExistMode_Add } ); //カメラから切り離す
		
		BMvTbl.SetLP(0,0); //カウンタ初期化
		BMvTbl.SetLP(1,0); //状態変数初期化
		
		Battle_Std.CharaBattleActivity_Increment(115,"地上投げ失敗");
		/*
		//投げ失敗回数/(投げ成功回数+投げ失敗回数)
		Battle_Std.CharaBattleActivity_Calc( {
			title="地上投げ失敗確率", 
			molecule=Battle_Std.CharaBattleActivity_Count("地上投げ失敗"), denominator=(Battle_Std.CharaBattleActivity_Count("地上投げ成功")+Battle_Std.CharaBattleActivity_Count("地上投げ失敗"))
		} );
		*/
	}	
	function FrameUpdate_Std()
	{
		local mvcnt = BMvTbl.GetLP(0); //カウンタ取得
		BMvTbl.AddLP(0,1); //1F進める		

		BMvTbl.SetMuki(_Direction_Auto); //相手の方を向く

		local s = BMvTbl.GetMvStatus(); // ステータス取得
		
		//バグ対策
		if( s.MvCount > 60 )
		{
			BMvTbl.SetFinalize(0);
		}
		
		if( s.MvCount%4==0 && BMvTbl.GetLP(1)==0 ) //プルプルさせる
		{
			BMvTbl.SetLP(1,1); //状態変更
			BMvTbl.SetPosition( { x=6, y=0, flags=_Position_ChangeMuki|_Position_Add|_Position_CaptureShift } );
		}
		else if( (s.MvCount+2)%4==0 && BMvTbl.GetLP(1)==1 )
		{
			BMvTbl.SetLP(1,0); //状態変更
			BMvTbl.SetPosition( { x=-6, y=0, flags=_Position_ChangeMuki|_Position_Add|_Position_CaptureShift } );
		}
		
		//アニメパターンのループ処理
		if( s.MvCount%6==0 )
		{
			if( Def_Rule_GuardPose_LoopFrames == 2 )
			{
				local frame = BMvTbl.Frame_Proc( 0, _ValAdd );
				BMvTbl.Frame_Proc( 1-frame, _ValSet ); //１枚目と２枚目でループ
			}
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
		BMvEff.SetExist( { level=_Exist_NoCamera, mode=_ExistMode_Erase } ); //カメラに含める
	}	
}

//投げ抜け押し返し攻撃
Std_MoveTable.Mv_Bound_0023 <- 
{
	function Init_Std() // 
	{
		Battle_Std.BoundInit();
		//print("\n投げ抜け攻撃！");
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
		BMvTbl.SetLP(0,0); //投げ抜けフラグ初期化
		Battle_Std.TypeSE_Play({ type="投げ抜け" });
		BMvTbl.SetPrio( _CharaPrio_Near ); //一番手前にする
		
		BMvEff.AddSkillCount( _SkillCount_ThrowRecover ); // 履歴カウンタを加算
		Battle_Std.MoveCode.AddFlag( def_MC_NoBurst ); // 行動コード(バーストできない)を設定 
		
		BMvTbl.SetAsFlag( { as_flags=_AsFlag_DamageEx, time=255, flag=_ClearFlag_ChangeMv } ); // 特殊やられ
		
		Battle_Std.CharaBattleActivity_Increment(122,"地上投げ抜け成功");
		//投げ抜け成功回数/投げでつかまれた回数
		Battle_Std.CharaBattleActivity_Calc( {
			title="地上投げ抜け成功確率", 
			molecule=Battle_Std.CharaBattleActivity_Count("地上投げ抜け成功"), denominator=(Battle_Std.CharaBattleActivity_Count("投げでつかまれた回数"))
		} );
		
		if( Def_ThrowTechHit_AddMoon )
		{
			Battle_Std.Moon_AddValue(Def_ThrowTechHit_AddMoon);
		}
	}
	function Update_Std()
	{
		//地上状態では符号が反転しないようにする
		if( BMvTbl.CheckPosState( _PosState_Ground  ) )
		{
			//今プラスのベクトルで、次のフレームがマイナスベクトルか？
			local vec = BMvTbl.GetVector( { flags=_Vector_Bound });
			//print(format("\n x:%d addx:%d",vec.x, vec.addx));
			if( (( vec.x<0 ) && ( (vec.x + vec.addx)>=0 )) || (( vec.x>0 ) && ( (vec.x + vec.addx)<=0 )) )
			{
				BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_Bound } );
			}
		}
		local s = BMvTbl.GetMvStatus(); // ステータス取得					
		
		if( s.MvCount>=16 && (BMvTbl.GetLP(0)==0) )
		{
			//相手を押し返すポイント
			BMvTbl.SetLP(0,1); //投げ抜けフラグ
			
			Battle_Std.UNI_Mv_Bound_0023_Update();
			
			//ここで相手を強引に掴んでMv_Bound_0024で開放する？
			//print("\nここ？");
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				local epos = BMvTbl.GetPosition(); // 位置取得
				
				enemy.pop();

				epos = Battle_Std.GamePos2ShiftPos( epos ); //オフセット座標に変換
				
				epos.x /= 128; //ツール座標に
				
				//epos.x += 50; //少し離す

				local ret = BMvEff.CapturePlayer( { target = enemy } );
				if( ret == 1 )
				{
					BMvEff.ThrowParam( { x=epos.x });
					BMvEff.ThrowRelease( { type=24 } );
				}
				
			}
		}
	}
	function FrameUpdate_Std()
	{
		Battle_Std.UNI_Mv_Bound_0023_FrameUpdate();
	}
	function Finalize_Std() // 
	{
		BtlMvStd.SetBoundFinalize();
	}
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
		BtlMvStd.ClearBound(); // 状態解除
	}
}

//投げ抜けられガードポーズ　※"Mv_Bound_0024"の名前を決めうちしている
Std_MoveTable.Mv_Bound_0024 <- 
{
	function Init_Std() : (val_TechHitEffectYposAr)
	{
		Battle_Std.BoundInit();
		//print("\n投げ抜けられガード！");
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254, muteki_nageX=254 } );
		
		Battle_Std.CreateObjectEX({ x=0, y=val_TechHitEffectYposAr[0], flags=_Position_ToolShift,
		datatype=1, pat="Eff_TechHit",
		objectflags=_ObjFlags_MoveTimeStopAll
		});
		
		//ヒットストップと揺らしを発生
		BMvEff.SetCamera_Quake( { time=12, type=1, } ); //横ゆれ
		BMvEff.SetStopTime( { time=12, stopme=2 } ); // 自分も停止する＆自分の停止が発生していたらそれの消去もする
		
		BMvTbl.SetPrio( _CharaPrio_Far  ); //一番後ろにする	
		
		Battle_Std.MoveCode.AddFlag( def_MC_NoBurst ); // 行動コード(バーストできない)を設定 
	}
	function FrameUpdate_Std()
	{
		Battle_Std.UNI_Mv_Bound_0024_FrameUpdate();
	}
	function Finalize_Std() // 
	{
		BtlMvStd.SetBoundFinalize();
	}
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_nageX=0 } );		
		BtlMvStd.ClearBound(); // 状態解除
	}
}

//空中版↓

//投げ抜けする側はBoundです

Std_MoveTable.Mv_Teched_Air <- //投げ抜けられ（つかんだ絵でプルプル）
{
	function Init_Std() // 
	{
		BMvTbl.SetPattern(def_PAT_GuardA); //立ちガードの見た目でプルプルする
		Battle_Std.MvAction.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定 (バーストされない)
		
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );		
		BMvEff.SetExist( { level=_Exist_NoCamera, mode=_ExistMode_Add } ); //カメラから切り離す
		
		BMvTbl.SetLP(0,0); //カウンタ初期化
		BMvTbl.SetLP(1,0); //状態変数初期化
		
		Battle_Std.CharaBattleActivity_Increment(130,"空中投げ失敗");
		/*
		//投げ失敗回数/(投げ成功回数+投げ失敗回数)
		Battle_Std.CharaBattleActivity_Calc( {
			title="空中投げ失敗確率", 
			molecule=Battle_Std.CharaBattleActivity_Count("空中投げ失敗"), denominator=(Battle_Std.CharaBattleActivity_Count("空中投げ成功")+Battle_Std.CharaBattleActivity_Count("空中投げ失敗"))
		} );
		*/
	}	
	function FrameUpdate_Std()
	{
		local mvcnt = BMvTbl.GetLP(0); //カウンタ取得
		BMvTbl.AddLP(0,1); //1F進める		

		BMvTbl.SetMuki(_Direction_Auto); //相手の方を向く

		local s = BMvTbl.GetMvStatus(); // ステータス取得
		
		//バグ対策
		if( s.MvCount > 60 )
		{
			BMvTbl.SetFinalize(0);
		}
		
		if( s.MvCount%4==0 && BMvTbl.GetLP(1)==0 ) //プルプルさせる
		{
			BMvTbl.SetLP(1,1); //状態変更
			BMvTbl.SetPosition( { x=6, y=0, flags=_Position_ChangeMuki|_Position_Add|_Position_CaptureShift } );
		}
		else if( (s.MvCount+2)%4==0 && BMvTbl.GetLP(1)==1 )
		{
			BMvTbl.SetLP(1,0); //状態変更
			BMvTbl.SetPosition( { x=-6, y=0, flags=_Position_ChangeMuki|_Position_Add|_Position_CaptureShift } );
		}
		
		//アニメパターンのループ処理
		if( s.MvCount%6==0 )
		{
			if( Def_Rule_GuardPose_LoopFrames == 2 )
			{
				local frame = BMvTbl.Frame_Proc( 0, _ValAdd );
				BMvTbl.Frame_Proc( 1-frame, _ValSet ); //１枚目と２枚目でループ
			}
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
		BMvEff.SetExist( { level=_Exist_NoCamera, mode=_ExistMode_Erase } ); //カメラに含める
	}	
}

//投げ抜け押し返し攻撃
Std_MoveTable.Mv_Bound_0025 <- 
{
	function Init_Std() // 
	{
		Battle_Std.BoundInit();
		//print("\n投げ抜け攻撃！");
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
		BMvTbl.SetLP(0,0); //投げ抜けフラグ初期化
		Battle_Std.TypeSE_Play({ type="投げ抜け" });
		BMvTbl.SetPrio( _CharaPrio_Near ); //一番手前にする
		
		BMvEff.AddSkillCount( _SkillCount_ThrowRecover ); // 履歴カウンタを加算
		Battle_Std.MoveCode.AddFlag( def_MC_NoBurst ); // 行動コード(バーストできない)を設定 
		
		BMvTbl.SetAsFlag( { as_flags=_AsFlag_DamageEx, time=255, flag=_ClearFlag_ChangeMv } ); // 特殊やられ
		
		Battle_Std.CharaBattleActivity_Increment(137,"空中投げ抜け成功");
		//投げ抜け成功回数/投げでつかまれた回数
		Battle_Std.CharaBattleActivity_Calc( {
			title="空中投げ抜け成功確率", 
			molecule=Battle_Std.CharaBattleActivity_Count("空中投げ抜け成功"), denominator=(Battle_Std.CharaBattleActivity_Count("空中投げでつかまれた回数"))
		} );
		
		if( Def_ThrowTechHit_AddMoon )
		{
			Battle_Std.Moon_AddValue(Def_ThrowTechHit_AddMoon);
		}
	}
	function Update_Std()
	{
		//地上状態では符号が反転しないようにする
		if( BMvTbl.CheckPosState( _PosState_Air ) )
		{
			//今プラスのベクトルで、次のフレームがマイナスベクトルか？
			local vec = BMvTbl.GetVector( { flags=_Vector_Bound });
			//print(format("\n x:%d addx:%d",vec.x, vec.addx));
			if( (( vec.x<0 ) && ( (vec.x + vec.addx)>=0 )) || (( vec.x>0 ) && ( (vec.x + vec.addx)<=0 )) )
			{
				BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_Bound } );
			}
		}
		local s = BMvTbl.GetMvStatus(); // ステータス取得					
		
		if( s.MvCount>=8 && (BMvTbl.GetLP(0)==0) )
		{
			//相手を押し返すポイント
			BMvTbl.SetLP(0,1); //投げ抜けフラグ
			
			Battle_Std.UNI_Mv_Bound_0025_Update();
			
			//ここで相手を強引に掴んでMv_Bound_0024で開放する？
			//print("\nここ？");
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				local epos = BMvTbl.GetPosition(); // 位置取得
				
				enemy.pop();

				epos = Battle_Std.GamePos2ShiftPos( epos ); //オフセット座標に変換
				
				epos.x /= 128; //ツール座標に
				
				//epos.x += 50; //少し離す

				local ret = BMvEff.CapturePlayer( { target = enemy } );
				if( ret == 1 )
				{
					BMvEff.ThrowParam( { x=epos.x });
					BMvEff.ThrowRelease( { type=26 } );
				}
			}
		}
	}
	function FrameUpdate_Std()
	{
		Battle_Std.UNI_Mv_Bound_0025_FrameUpdate();
	}
	function Finalize_Std() // 
	{
		BtlMvStd.SetBoundFinalize();
	}
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
		BtlMvStd.ClearBound(); // 状態解除
	}
}

//投げ抜けられガードポーズ　※"Mv_Bound_0024"の名前を決めうちしている
Std_MoveTable.Mv_Bound_0026 <- 
{
	function Init_Std() : (val_TechHitEffectYposAr)
	{
		Battle_Std.BoundInit();
		//print("\n投げ抜けられガード！");
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254, muteki_nageX=254 } );
		
		Battle_Std.CreateObjectEX({ x=0, y=val_TechHitEffectYposAr[1], flags=_Position_ToolShift,
		datatype=1, pat="Eff_TechHit",
		objectflags=_ObjFlags_MoveTimeStopAll
		});
		
		//ヒットストップと揺らしを発生
		BMvEff.SetCamera_Quake( { time=12, type=1, } ); //横ゆれ
		// BMvEff.SetStopTime( { time=12, stopme=2 } ); // 自分も停止する＆自分の停止が発生していたらそれの消去もする
		
		BMvTbl.SetPrio( _CharaPrio_Far  ); //一番後ろにする	
		
		Battle_Std.MoveCode.AddFlag( def_MC_NoBurst ); // 行動コード(バーストできない)を設定 
	}
	function FrameUpdate_Std()
	{
		Battle_Std.UNI_Mv_Bound_0026_FrameUpdate();
	}
	function Finalize_Std() // 
	{
		BtlMvStd.SetBoundFinalize();
	}
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_nageX=0 } );		
		BtlMvStd.ClearBound(); // 状態解除
	}
}



//空中版↑

//投げ抜けする側はBoundです
//コマ投げとか用の投げ抜けられ演出
Std_MoveTable.Mv_SkillTeched <- //投げ抜けられ（つかんだ絵でプルプル）
{
	function Init_Std() // 
	{
		//BMvTbl.SetMuki(_Direction_Auto); //振り向きを入れると座標変更前なので逆向いたりするよ
		//BMvTbl.SetPattern(410); //つかみポーズでプルプルする
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );		
	}	
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
	}	
}

//投げ抜けする側はBoundです
//コマ投げとか用の投げ抜けられ演出2(最初からガードポーズに変化している版)
Std_MoveTable.Mv_SkillTechedPatChange <- //投げ抜けられ（つかんだ絵でプルプル）
{
	function Init_Std() // 
	{
		//BMvTbl.SetMuki(_Direction_Auto); //振り向きを入れると座標変更前なので逆向いたりするよ
		BMvTbl.SetPattern(17); //ガードポーズを取る
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );		
	}	
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
	}	
}

//
Std_MoveTable.Mv_SkillTechedRecover <- //投げ抜けられ２（復帰でよけるタイプ）
{
	function Init_Std() // 
	{
		//BMvTbl.SetMuki(_Direction_Auto); //振り向きを入れると座標変更前なので逆向いたりするよ
		//BMvTbl.SetPattern(410); //つかみポーズでプルプルする
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
	}	
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
	}	
}

//イベントとか
//登場タイミングで呼ばれて
// 行動文字列を返す、行動が存在しないまたは""が返されると Mv_Neutral が呼ばれる
// ラウンド頭でスキップした場合もここにとんできて、なんとround=1として扱われる
Std_MoveTable.GetEntranceMvName <- function()
//function Std_MoveTable::GetEntranceMvName()
{
	local pside = BMvTbl.GetPlayerSide();//0:1Pサイド 1:2Pサイド
	local tagStatus = BMvCore.GetTagStatus();//-1:通常 1:タッグのメイン 0:タッグのパートナー
	local roundst = BMvTbl.GetMvRoundStatus(); // これで判別

	BMvEff.Chara_ClearMessageAll();//トレモとかでの勝利字幕の初期化
	//BSound.BGM_SetFade( { val=100, time=60 } );//BGMの戻し
	
	//デバッグ処理
	if( 1 )
	{
		local tag_str = { [-1]="通常キャラ", [1]="メイン", [0]="パートナー" };
	
		// _dpn("★GetEntranceMvName Round:"+roundst.Round+" "+(pside+1)+"Pサイド "+tag_str[tagStatus] );
	}
	
	if( roundst.Round < 0 ) return "Mv_Startup"; // トレーニング -1？0未満だと
	
	if( BMvTbl.TalkScript_IsDone() ) return "Mv_Startup"; // 会話があったらトレーニングと同じ開始状態にする
	
	if( roundst.Round == 0 ) // ラウンド１
	{
		BMvEff.SetCamera_Focus( { time=[0,0,0] } );//カメラ初期化（ラウンドコール時のカメラ処理をリセット）
		BMvEff.ResetCamera();//カメラを中央にする

		local pside = BMvTbl.GetPlayerSide();
		
		//1Pから順番にセリフを言うので待機
		if( pside == 0 ) // 1Por3PならStandby 2Por4PならStandbyWait
		{
			BMvTbl.SetPP( def_PP_StandbyType, def_PP_ST_Standby );
			// print(" -> def_PP_ST_Standby");
		}
		else if( pside == 1 )
		{
			BMvTbl.SetPP( def_PP_StandbyType, def_PP_ST_StandbyWait );
			// print(" -> def_PP_ST_StandbyWait");
		}
	}
	else if( roundst.Round >= 0 ) // ラウンド２以降（もしくはスキップ時）
	{
		BMvEff.SetCamera_Focus( { time=[0,0,0] } );//カメラ初期化（ラウンドコール時のカメラ処理をリセット）
		BMvTbl.SetPP( def_PP_StandbyType, def_PP_ST_Neutral ); // 開幕MV指定
		BMvEff.ResetCamera();//カメラを中央にする
	}
	return "Mv_Startup";

	return "";
}

Std_MoveTable.Mv_Startup <- //開幕かませ・絶対通るようになった
{
	function Init_Std()
	{
		// _dpn("Mv_Startup");
		
		BMvTbl.SetMoveableFlag( { move=0, time=600, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
		
		if( Def_Dbg_LocalDebugScriptPath )
		{
			Battle_Std.DebugFunc.CallStartupDebugScript();
		}
		
		local is_partner = (BMvCore.GetTagStatus() == 0); // -1 - タッグでない 1 - メイン状態 0 - パートナー状態
		if( is_partner )
		{
			switch( BMvTbl.GetPP( def_PP_StandbyType ) )
			{
			case def_PP_ST_Neutral:
				//2ラウンド目以降
				// _dpn(" -> PatMv_StandbyNoMotionPass");
				BMvTbl.SetFinalize(100);
				break;
			case def_PP_ST_Standby:
				//1ラウンド目
				// _dpn(" -> PatMv_Standby");
				BMvTbl.SetFinalize(110);
				break;
			case def_PP_ST_StandbyWait:
				//1ラウンド目の待機側
				// _dpn(" -> PatMv_StandbyWait");
				BMvTbl.SetFinalize(120);
				break;
			default:
				// _dpn(" -> PatMv_StandbyNoMotionPass(Default)");
				BMvTbl.SetFinalize(100);
				break;
			}
			// _dpn("タッグ側の開始:"+BMvTbl.GetFinalizeCode()+" PP:"+BMvTbl.GetPP( def_PP_StandbyType ) );
		}
		else
		{
		
			switch( BMvTbl.GetPP( def_PP_StandbyType ) )
			{
			case def_PP_ST_Neutral:
				BMvTbl.SetFinalize(0);
				break;
			case def_PP_ST_Standby:
				BMvTbl.SetFinalize(10);
				break;
			case def_PP_ST_StandbyWait:
				BMvTbl.SetFinalize(20);
				break;
			default:
				BMvTbl.SetFinalize(0);
				break;
			}
		}
	}
	function Finalize_Std()
	{
		Battle_Std.SwitchNextMoveTable("Mv_StandbyNoMotionPass", [10,"Mv_StandbyCommon1P"], [20,"Mv_StandbyCommon2P"],
		// [100,"PatMv_StandbyNoMotionPass"], [110,"PatMv_Standby"], [120,"PatMv_StandbyWait"] ); //デフォ,[code,mv]...
		[100,"PatMv_StandbyNoMotionPass"], [110,"PatMv_StandbyCommon1P"], [120,"PatMv_StandbyCommon2P"] ); //デフォ,[code,mv]...
	}
}

/*

■登場Mvメモ
1P
Mv_StandbyCommon1P
(Mv_Neutral)

2P
Mv_StandbyCommon2P
(Mv_Neutral)

↓（画面暗転）

1P
Mv_StandbyNoMotionPass
Mv_StandbyNoMotion
Mv_Neutral

2P
Mv_StandbyNoMotionPass
Mv_StandbyNoMotion
Mv_Neutral
*/

//Pass系
//ボイスを決めてパターンを指定して次に備える
//スタートボタンでスキップした場合もここに入るのでパターンは変えないとダメ
Std_MoveTable.Mv_StandbyNoMotionPass <- //登場演出
{
	function Init_Std()
	{
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
		BMvTbl.SetPattern(def_PAT_Neutral);
		
		//ボタンスキップが発生しないように即命令を呼ぶ
		BMvTbl.SetRoundStart(); //戦闘開始可能状態にする
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 10 )
		{
			BMvTbl.SetFinalize(0);
		}
		else
		{
			BMvTbl.Frame_Proc( 0, _ValSet );//今のパターンの頭に移動
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_StandbyNoMotion" );
	}
}

Std_MoveTable.Mv_StandbyNoMotion <-
{
	function Init_Std() // 
	{
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
		
		Battle_Std.InitVector();
		BMvTbl.SetFinalize(0);
		
		//負けラウンドなら
		local isTraining = BMvTbl.GetMvStageStatus().IsTrainingBattle(); // トレーニング系かどうか
		if( !isTraining )
		{
			local rs = BMvTbl.GetMvRoundStatus(); //ラウンドステータス取得
			// _dpn("rs.isLoseRound:"+rs.isLoseRound+" rs.isFirstLoseRound:"+rs.isFirstLoseRound );
			if( rs.isLoseRound && rs.isFirstLoseRound )//負けラウンドかつ初回のみ
			{
				BMvTbl.SetFinalize(100);
			}

			//1ラウンド目にゲージを増やして1ゲージスタートにする
			if( Def_Sys_FirstRoundAddGauge )
			{
				if( rs.Round == 0 )
				{
					// _dpn("ゲージ増加")
					BMvEff.SetSpGauge( { value=Def_Sys_FirstRoundAddGauge*10000, correct=0 } );
				}
			}
		}
	}
	function LastUpdate_Std() //
	{
		BMvTbl.SetRoundStart(); //念の為戦闘開始可能状態にする
	}	
	function Finalize_Std()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [100,"Mv_StandbyBlastWait"] ); //デフォ,[code,mv]...	
	}
}

Std_MoveTable.PatMv_StandbyNoMotionPass <- //登場演出
{
	function Init_Std()
	{
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
		BMvTbl.SetPattern(def_PAT_Neutral);
		
		//ボタンスキップが発生しないように即命令を呼ぶ
		BMvTbl.SetRoundStart(); //戦闘開始可能状態にする
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 10 )
		{
			BMvTbl.SetFinalize(0);
		}
		else
		{
			BMvTbl.Frame_Proc( 0, _ValSet );//今のパターンの頭に移動
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "PatMv_StandbyNoMotion" );
	}
}

Std_MoveTable.PatMv_StandbyNoMotion <-
{
	function Init_Std() // 
	{
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
		
		Battle_Std.InitVector();
		BMvTbl.SetFinalize(0);

		_dpn("PatMv_StandbyNoMotion");
	}
	function LastUpdate_Std() //
	{
		BMvTbl.SetRoundStart(); //念の為戦闘開始可能状態にする
	}	
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "PatMv_Neutral" );
	}
}

// 何度も入ってくるので注意
Std_MoveTable.PatMv_StandbyWait <- //登場演出
{
	function Init_Std()
	{
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
		Battle_Std.InitVector();
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_StandbyWait);
		
		// _dpn("PatMv_StandbyWait");
		
		// BMvTbl.SetLP(9,0); // 特定サポ掛け合いモードか
	}
	function Update_Std()
	{
		// FinalizeタイミングでMvを変えていかないと、
		// ループアニメの抜けが綺麗に繋がらないのでこの仕様
		BMvTbl.AddPP( def_PP_StandbyWaitFrame, 1);

		if( BMvTbl.GetLP(9) == 1 )
		{
			local mvs = BMvTbl.GetMvStatus();

			// 待機時間を取得
			local waitframe = BMvTbl.GetPP( def_PP_ParamStandbyWaitFrame );
			if( waitframe == 0 ) waitframe = 120;
			
			if( mvs.MvCount >= waitframe )
			{
				BMvTbl.SetFinalize( 100 );
			}
		}
	}
	function Finalize_Std() // 
	{
		local waitframe = BMvTbl.GetPP( def_PP_ParamStandbyWaitFrame );
		if( waitframe == 0 ) waitframe = 120;
			
		if( BMvTbl.GetPP(def_PP_StandbyWaitFrame) >= waitframe )
		{
			if( BMvTbl.GetLP(9) == 1 )
			{
				BMvTbl.SetNextMoveTable( "PatMv_StandbyNoPatChange" );
			}
			else
			{
				BMvTbl.SetNextMoveTable( "PatMv_Standby" );
			}
		}
		else
		{
			BMvTbl.SetNextMoveTable( "PatMv_StandbyWait" );
		}
		BMvTbl.SetFinalizeCode( 0 ); // 初期化
	}
}

Std_MoveTable.Mv_StandbyNoPatChange <-
{
	function Init_Std() // 
	{
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
	}
	function LastUpdate_Std() //
	{
		BMvTbl.SetRoundStart(); //戦闘開始可能状態にする
	}	
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}	

Std_MoveTable.Mv_Null_StandbyCamera <-
{
	function Init_Std()
	{
		// _dpn("Mv_Null_StandbyCamera");

		// BMvTbl.SetLP(0,0);// だいたいの音声のフレームが入っているのでカメラの移動フレームに使う
		local voice_frame = BMvTbl.GetLP(0);
		local shift_x = 64*128;
		
		//1Pか2Pかで開始座標は決まる
		local pos_x = ( BMvTbl.GetPlayerSide() == 0 )? -320*128 : 320*128;
		
		// BMvEff.SetCamera_Focus( { num=0, x=pos.x+shift_x*BMvTbl.GetMuki(), y=0, zoom=1.0, time=[10,999,0], type_in=1 } );
		// BMvEff.SetCamera_Focus( { num=1, x=pos.x, y=0, zoom=1.0, time=[voice_frame,255,10], type_in=1 } );

		BMvEff.SetCamera_Focus( { num=0, x=0, y=0, zoom=1.0, time=[0,999,0], type_in=1 } );
		BMvEff.SetCamera_Focus( { num=1, x=pos_x+shift_x*BMvTbl.GetMuki(), y=0, zoom=1.0, time=[10,255,10], type_in=1 } );

		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		
		BMvTbl.SetPattern(990);

		// _dpn("開始 voice_frame:"+voice_frame);
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount == 10 )
		{
			local voice_frame = BMvTbl.GetLP(0);
			local shift_x = 64*128;
		
			//1Pか2Pかで開始座標は決まる
			local pos_x = ( BMvTbl.GetPlayerSide() == 0 )? -320*128 : 320*128;

			BMvEff.SetCamera_Focus( { num=0, x=pos_x+shift_x*BMvTbl.GetMuki(), y=0, zoom=1.0, time=[0,999,0], type_in=1 } );
			BMvEff.SetCamera_Focus( { num=1, x=pos_x, y=0, zoom=1.0, time=[voice_frame,255,10], type_in=1 } );
			
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

// アイコンは時間でも勝手に消えるが、スクリプトでも挙動を操作している
Std_MoveTable.Mv_SystemHereYouAre <-
{
	function Init_Std() : (tbl_OnlineHereYouAreYPosOffSet)
	{
		BMvTbl.SetMuki( _Direction_Right );//文字なので右向き固定
		BMvTbl.SetPosition( { y=-(435-(tbl_OnlineHereYouAreYPosOffSet*25))*128, } );//高さ
		
		// BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera } );//演出でカメラ動くのでなし
		
		//レイヤー構成 : 1P / 2P / 空
		local plside = BMvTbl.GetPlayerSide();
		// _dpn("plside:"+plside);
		local mask = ( plside == 0 )? (1<<1)|(1<<2) : (1<<0)|(1<<2);
		BMvTbl.SetHan6LayerMask( {  val = mask } );
		
		BMvTbl.SetLP(0,0);//消滅開始したら1
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount>600 )//保険処理
		{
			BMvTbl.SetFinalize(0);
			return;
		}
		if( Battle_Std.GetUpdateFrameID( mvs ) == 900 )
		{
			BMvTbl.SetLP(0,1); // 勝手に消滅まで進んだ
		}
		
		if( BMvTbl.GetLP(0)==0 )
		{
			local rs = BMvTbl.GetMvRoundStatus();
			if( rs.CharaMoveMode == _CharaMoveMode_Enable || rs.CharaMoveMode == _CharaMoveMode_Limit )
			{
				// _dpn("きえる");
				// キャラが動けるようになったら消す
				BMvTbl.JumpFrameID(900);
				BMvTbl.SetLP(0,1); // 消滅開始に飛んだので1
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.PatMv_Standby <- //登場演出
{
	function Init_Std()
	{
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
		Battle_Std.InitVector();
		BMvTbl.SetMuki(_Direction_Auto);
		
		_dpn("PatMv_Standby");

		BMvTbl.SetPattern(def_PAT_Standby);
		BMvTbl.JumpFrameID(999);
		/*
		
		// BMvTbl.SetLP(9,0); // 特定サポ掛け合いモードか
		
		if( BMvTbl.GetLP(9) == 0 )
		{
			BMvTbl.SetPattern(def_PAT_Standby);
			
			Battle_Std.TypeSE_Play({ type="登場" });
		}
		*/
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="登場_FU" });
	}
	function LastUpdate_Std() //
	{
		BMvTbl.SetRoundStart(); //戦闘開始可能状態にする
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "PatMv_Neutral" );
	}
}


//汎用登場
Std_MoveTable.Mv_StandbyCommon1P <- //登場演出1P
{
	function Init_Std() // 
	{
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
		BMvTbl.SetRoundStartType(1); // フェードタイプにする

		Battle_Std.InitVector();
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(0);
		
		Battle_Std.CallSystemHereYouAre();
	}
	function Update_Std()
	{
		// 保険処理で15秒で抜ける
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount == 900 )
		{
			BMvTbl.SetRoundStartType(1); // フェードタイプにする
			BMvTbl.SetRoundStart(); //戦闘開始可能状態にする
		}
	}
	function LastUpdate_Std() //
	{
		BMvTbl.SetRoundStart(); //戦闘開始可能状態にする
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

Std_MoveTable.PatMv_StandbyCommon1P <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
		BMvTbl.SetRoundStartType(1); // フェードタイプにする

		Battle_Std.InitVector();
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(0);
		
		Battle_Std.CallSystemHereYouAre();
	}
	function Update_Std()
	{
		// 保険処理で15秒で抜ける
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount == 900 )
		{
			BMvTbl.SetRoundStartType(1); // フェードタイプにする
			BMvTbl.SetRoundStart(); //戦闘開始可能状態にする
		}
	}
	function LastUpdate_Std() //
	{
		BMvTbl.SetRoundStart(); //戦闘開始可能状態にする
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "PatMv_Neutral" );
	}
}

Std_MoveTable.PatMv_StandbyCommon2P <- Std_MoveTable.PatMv_StandbyCommon1P;

Std_MoveTable.Mv_StandbyCommon2P <- //登場演出2P
{
	function Init_Std() // 
	{
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
		BMvTbl.SetRoundStartType(1); // フェードタイプにする

		Battle_Std.InitVector();
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(0);
		
		local eff = BMvEff.CreateObject( { mvname="Mv_Null_StandbyCommonManager" } );
		if( eff.push() )
		{
			BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
			
			eff.pop();
		}
		
		Battle_Std.CallSystemHereYouAre();
	}
	function Update_Std()
	{
		// 保険処理で15秒で抜ける
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount == 900 )
		{
			BMvTbl.SetRoundStartType(1); // フェードタイプにする
			BMvTbl.SetRoundStart(); //戦闘開始可能状態にする
		}
	}
	function LastUpdate_Std() //
	{
		BMvTbl.SetRoundStart(); //戦闘開始可能状態にする
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

Std_MoveTable.Mv_Null_StandbyCommonManager <- //登場演出管理マネージャ 2P側から呼ばれる
{
	function GetTimeline( player, timeline_type ) : (CommonStandbyParams)
	{
		local player_no = BMvTbl.GetLP(7+player);
		local num = BMvTbl.GetLP(0+player);
		
		if( player_no in CommonStandbyParams &&
		num in CommonStandbyParams[player_no] &&
		timeline_type in CommonStandbyParams[player_no][num]
		)
		{
			return CommonStandbyParams[player_no][num][timeline_type];
		}
		return 0;
	}
	function Init_Std() : (CommonStandbyParams)
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_FromParentStop } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		
		//開始時にカメラを画面中央で固定する
		//キャラの開始オフセットが異なることがあり、開始カメラが傾くのを防ぐ
		BMvEff.SetCamera_Focus( { x=0, y=0, zoom=1.0, time=[0,999,0] } );
		
		//参照先テーブルの抽選TL番号
		BMvTbl.SetLP(0,-1); //1Pが抽選したTL番号
		BMvTbl.SetLP(1,-1); //2Pが抽選したTL番号
		
		BMvTbl.SetLP(2,0); //ステップ数
		BMvTbl.SetLP(3,0); // ステップを進ませない残り待機時間）

		BMvTbl.SetLP(4,0); // 参照するのがduetか、さらには反転して参照する必要があるか 1:duet参照 2:反転duet参照
		
		//参照先テーブル
		BMvTbl.SetLP(5,-1); // -1:汎用 0〜:相手キャラ指定(=キャラ番号)
		BMvTbl.SetLP(6,-1); // -1:汎用 0〜:相手キャラ指定(=キャラ番号)

		BMvTbl.SetLP(7,-1); //1Pのキャラ番号
		BMvTbl.SetLP(8,-1); //2Pのキャラ番号

		BMvTbl.SetLP(9,0); //1Pのセリフ中:0 2Pのセリフ中:1
		
		// このオブジェクトが2P側から呼ばれるのでcoreは逆になる
		local cores = [ BMvCore.GetEnemyCharaData(), BMvCore.GetPlayerCharaData() ];
		local chrnos = [0,0];//1Pと2Pのキャラ番号
		
		//1Pと2Pのキャラ番号を取得する
		for( local i=0; i<2; i++ )
		{
			if( cores[i].push() )
			{
				// chrnos[i] = BMvTbl.GetMvStatus().CharaNo;
				chrnos[i] = BMvCore.GetCharaNo();
				cores[i].pop();
			}
			BMvTbl.SetLP(7+i, chrnos[i]);
		}
		
		//0: common / enemy / twin_enemy / duet
		//1:          enemy / twin_enemy / duet
		//2:                  twin_enemy / duet
		//3:                               duet
		local common_pick_ar = [ [], [] ];
		local twin_pick_ar  = [ [], [] ];
		local duet_pick_ar   = [ [], [] ];

		local enemy_pick_ar  = [ [], [] ];
		
		local duet_pick = 0;
		local enemy_pick = [0,0];

		local array_find = function( tbl, name, enemy_no )
		{
			if( name in tbl && tbl[name].len() > 0 )
			{
				foreach( slot, val in tbl[name] )
				{
					if( val == enemy_no ) // 発見
					{
						return 1;
						break;
					}
				}
				return 0;
			}
			else
			{
				return -1;
			}
		}

		//まずはピックアップ処理を行う
		for( local i=0; i<2; i++ )
		{
			local player_no = chrnos[i];
			local enemy_no = chrnos[1-i];
			
			_dpn((1+i)+"P側("+player_no+") 検索開始...");
			if( player_no in CommonStandbyParams && typeof CommonStandbyParams[player_no] == "array" )
			{
				local tbl = CommonStandbyParams[player_no];
				for( local j=0; j<tbl.len(); j++ )
				{
					//-1:未定義なので成功 0:定義してあってない 1:定義してあって発見
					local pick = ( array_find( tbl[j], "Enemy", enemy_no ) );
					
					if( pick != 0 )
					{
						if( array_find( tbl[j], "ExcludeEnemy", enemy_no ) == 1 )
						{
							pick = 0;//除外が定義してあって見つかったら
						}
						else if( "checkfunc" in tbl[j] )
						{
							// _dpn(j+":checkfunc:"+pick);
							local check_result = 1;//1なら入れる
							if( cores[i].push() )
							{
								check_result = tbl[j].checkfunc();//弾く条件があれば0になる
								cores[i].pop();
							}
							if( check_result == 0 )
							{
								pick = 0;//不採用
							}
						}
						
						if( pick != 0 )
						{
							//確定
							if( "duet_timeline" in tbl[j] )
							{
								_dpn(" -> "+j+" duet");
								duet_pick = 1;//duetあり

								duet_pick_ar[i].append( { pl=i, num=j, type=2, param=tbl[j] } );//抽選に追加
								twin_pick_ar[i].append( { pl=i, num=j, type=2, param=tbl[j] } );//抽選に追加
							}
							else if( pick == 1 )//Enemyが定義してあって成功なら
							{
								_dpn(" -> "+j+" enemy");
								enemy_pick[i] = 1;//有効

								enemy_pick_ar[i].append( { pl=i, num=j, type=1, param=tbl[j] } );//抽選に追加
								twin_pick_ar[i].append( { pl=i, num=j, type=1, param=tbl[j] } );//抽選に追加
							}
							else
							{
								_dpn(" -> "+j);

								common_pick_ar[i].append( { pl=i, num=j, type=0, param=tbl[j] } );//抽選に追加
							}
						}
					}
				}
			}
		}
		
		//どれを使うかレベルを決める
		//twin_pick_arは条件が合えば一番良いpick
		
		local target_pick_ar = [0,0];
		local choice_mode = 0;
		if( enemy_pick[0] == 1 && enemy_pick[1] == 1 )
		{
			choice_mode = 3;
			target_pick_ar = twin_pick_ar;
		}
		else if( duet_pick )
		{
			choice_mode = 2;
			target_pick_ar = duet_pick_ar;
		}
		else if( enemy_pick[0] == 1 && enemy_pick[1] == 0 )
		{
			choice_mode = 1;
			target_pick_ar[0] = enemy_pick_ar[0];
			target_pick_ar[1] = common_pick_ar[1];
		}
		else if( enemy_pick[0] == 0 && enemy_pick[1] == 1 )
		{
			choice_mode = 1;
			target_pick_ar[0] = common_pick_ar[0];
			target_pick_ar[1] = enemy_pick_ar[1];
		}
		else
		{
			choice_mode = 0;
			target_pick_ar = common_pick_ar;
		}
		
		//デバッグ用に抽選したメッセージを書き出す
		if( Def_Dbg_LocalDebugMode )
		{
			_dpn("抽選するレベル:"+choice_mode );
			for( local i=0; i<2; i++ )
			{
				local player_no = chrnos[i];
				local enemy_no = chrnos[1-i];
			
				
				for( local j=0; j<target_pick_ar[i].len(); j++ )
				{
					local tmp = target_pick_ar[i][j];
					local target_line = ( "duet_timeline" in tmp.param )? tmp.param.duet_timeline : ( "timeline" in tmp.param )? tmp.param.timeline : 0;
					if( target_line )
					{
						local se = -1;
						for( local k=0; k<target_line.len(); k++ )
						{
							local tmp2 = target_line[k];
							if( "SE" in tmp2 )
							{
								if( "PL" in tmp2 )
								{
									if( tmp2.PL == 0 ) se = tmp2.SE;
								}
								else
								{
									se = tmp2.SE;
								}
							}
						}
						local tag = format("battlevoice_chr%03d_%03d",player_no, se );
						local string = sqfunc.GetExStringText( tag );
						_dpn( format("%dP %d [%3d] %s : %s",(1+i), tmp.type, tmp.num, tag, string ) );
					}
				}
				_dpn("");
			}
		}
		
		//抽選して準備開始
		for( local i=0; i<2; i++ )
		{
			local player_no = chrnos[i];
			local enemy_no = chrnos[1-i];
			
			if( target_pick_ar[i].len() > 0 )
			{
				local use_param_no = BMvEff.Random_Limit( target_pick_ar[i].len() );
				local pick_table = target_pick_ar[i][use_param_no];//pick_arからランダムで１つを抽選する

				if( "duet_timeline" in pick_table.param )
				{
					BMvTbl.SetLP(4,1+i); // 参照するのがduetか、さらには反転して参照する必要があるか 1:duet参照 2:反転duet参照
					BMvTbl.SetLP(0+i, pick_table.num );
					
					if( typeof pick_table.param.WaitPAT[0] == "array" )
					{
						if( cores[i].push() )
						{
							BMvTbl.SetPattern( pick_table.param.WaitPAT[0][0] );
							local pertner = BMvCore.GetPertnerCharaData();
							if( pertner.push() )
							{
								BMvTbl.SetPattern( pick_table.param.WaitPAT[0][1] );
								pertner.pop();
							}
							cores[i].pop();
						}
					}
					else
					{
						if( cores[i].push() )
						{
							BMvTbl.SetPattern( pick_table.param.WaitPAT[0] );
							cores[i].pop();
						}
					}
					
					if( typeof pick_table.param.WaitPAT[1] == "array" )
					{
						if( cores[1-i].push() )
						{
							BMvTbl.SetPattern( pick_table.param.WaitPAT[1][0] );
							local pertner = BMvCore.GetPertnerCharaData();
							if( pertner.push() )
							{
								BMvTbl.SetPattern( pick_table.param.WaitPAT[1][1] );
								pertner.pop();
							}
							cores[1-i].pop();
						}
					}
					else
					{
						if( cores[1-i].push() )
						{
							BMvTbl.SetPattern( pick_table.param.WaitPAT[1] );
							cores[1-i].pop();
						}
					}
					break;//duetやったら抜ける
				}
				else
				{
					if( cores[i].push() )
					{
						if( typeof pick_table.param.WaitPAT == "array" )
						{
							BMvTbl.SetPattern( pick_table.param.WaitPAT[0] );
							local pertner = BMvCore.GetPertnerCharaData();
							if( pertner.push() )
							{
								BMvTbl.SetPattern( pick_table.param.WaitPAT[1] );
								pertner.pop();
							}
						}
						else
						{
							BMvTbl.SetPattern( pick_table.param.WaitPAT );
						}
						
						if( "OffsetPosition" in pick_table.param )
						{
							local pos = pick_table.param.OffsetPosition;
							if( typeof pos == "array" )
							{
								BMvTbl.SetPosition( { x=pos[0].x, y=pos[0].y, flags=_Position_CaptureShift|_Position_Add|_Position_ChangeMuki } );
								local pertner = BMvCore.GetPertnerCharaData();
								if( pertner.push() )
								{
									BMvTbl.SetPosition( { x=pos[1].x, y=pos[1].y, flags=_Position_CaptureShift|_Position_Add|_Position_ChangeMuki } );
									pertner.pop();
								}
							}
							else
							{
								BMvTbl.SetPosition( { x=pos.x, y=pos.y, flags=_Position_CaptureShift|_Position_Add|_Position_ChangeMuki } );
							}
						}

						cores[i].pop();
			
						BMvTbl.SetLP(0+i, pick_table.num );
					}
				}
			}
		}
		// _dpn("1P:"+BMvTbl.GetLP(7)+" 種:"+BMvTbl.GetLP(5)+" TL:"+BMvTbl.GetLP(0)+" 2P:"+BMvTbl.GetLP(8)+" 種:"+BMvTbl.GetLP(6)+" TL:"+BMvTbl.GetLP(1)+" Duet:"+BMvTbl.GetLP(4) );
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount <= 10 )
		{
			return;
		}
		
		// _dpn("step:"+BMvTbl.GetLP(2)+" fra:"+BMvTbl.GetLP(3) );
		local step = BMvTbl.GetLP(2);
		
		local timeline_type = BMvTbl.GetLP(4);// 参照するタイムラインの種類　0:common 1:duet 2:反転duet
		local now_pl_side = BMvTbl.GetLP(9); //common用　1Pのセリフ中:0 2Pのセリフ中:1

		local use_timeline = 0;//最終的に処理で使うタイムライン情報
		// 汎用かduetか反転duetかで使うタイムラインを選ぶ
		switch( timeline_type )
		{
		case 0://common
			// _dpn("汎用");
			if( now_pl_side == 0 )
			{
				use_timeline = GetTimeline( 0, "timeline" );
			}
			else
			{
				use_timeline = GetTimeline( 1, "timeline" );
			}
			break;
		case 1://duet
			use_timeline = GetTimeline( 0, "duet_timeline" );
			break;
		case 2://反転duet
			use_timeline = GetTimeline( 1, "duet_timeline" );
			break;
		}
		
		if( !use_timeline || step >= use_timeline.len() )
		{
			_dpn("step over");
			// もうないので2Pに移るか終わるかする
			if( timeline_type==0 && now_pl_side == 0 )
			{
				now_pl_side++;
				BMvTbl.SetLP(9,now_pl_side);

				BMvTbl.SetLP(2,0); //step初期化
				_dpn("step next");
				return;
			}
			else
			{
				_dpn("step end");
				BMvTbl.SetFinalize(0);
				return;
			}
		}
		else
		{
			local target_core = 0;
			if( timeline_type == 0 )//通常
			{
				target_core = (BMvTbl.GetLP(9) == 1 )? BMvCore.GetPlayerCharaData() : BMvCore.GetEnemyCharaData();
				local tmp_core = (BMvTbl.GetLP(9) == 1 )? BMvCore.GetPlayerCharaData() : BMvCore.GetEnemyCharaData();
				
				//TAG指定があるとき
				local tag_target = ( "TAG" in use_timeline[step] )? use_timeline[step].TAG : 0;
				if( tag_target == 1 )//控え指定
				{
					// _dpn("パートナー側の指定あり");
					
					if( tmp_core.push() )
					{
						target_core = BMvCore.GetPertnerCharaData();//パートナー側にする
						
						tmp_core.pop();
					}
				}
			}
			else
			{
				//duet・反転duet
				target_core = (use_timeline[step].PL == 1-( (timeline_type == 2)? 1 : 0 ) )? BMvCore.GetPlayerCharaData() : BMvCore.GetEnemyCharaData();
				local tmp_core = (use_timeline[step].PL == 1-( (timeline_type == 2)? 1 : 0 ) )? BMvCore.GetPlayerCharaData() : BMvCore.GetEnemyCharaData();
				
				//TAG指定があるとき
				local tag_target = ( "TAG" in use_timeline[step] )? use_timeline[step].TAG : 0;
				if( tag_target == 1 )//控え指定
				{
					// _dpn("パートナー側の指定あり");
					if( tmp_core.push() )
					{
						target_core = BMvCore.GetPertnerCharaData();//パートナー側にする
						
						tmp_core.pop();
					}
				}
			}
			
			if( BMvTbl.GetLP(3) == 0 ) // ステップ停止フレーム中でない
			{
				//Init的タイミング
				local delay = ("delay" in use_timeline[step])? use_timeline[step].delay : 0;

				_dpn("↓Init----:"+step+" delay:"+delay );
				foreach( slot, val in use_timeline[step] )
				{
					_dpn(slot+" : "+val);
				}
				_dpn("↑----Init:"+step);
				
				if( target_core.push() )
				{
					if( "PAT" in use_timeline[step] )
					{
						_dpn("PAT指定あり");
						local mvname = BMvTbl.GetMvName();
						if( mvname == "Mv_StandbyCommon1P" || mvname == "Mv_StandbyCommon2P" || mvname == "PatMv_StandbyCommon1P" || mvname == "PatMv_StandbyCommon2P" || ( Def_Dbg_LocalDebugMode && (mvname == "Mv_Neutral" || mvname == "PatMv_Neutral")) )
						{
							_dp("\n"+(now_pl_side+1)+"Pのパターン変更 step:"+step );
							BMvTbl.SetPattern( use_timeline[step].PAT ); // 指定のパターンに変更
						}
						else
						{
							_dp("\n ※もう準備できてるので何もしません");
						}
					}
					else
					{
						_dpn("PAT指定なし");
					}
					if( "SE" in use_timeline[step] )
					{
						_dp("\n"+(now_pl_side+1)+"Pのボイス再生 step:"+step );
						
						local voice_time = ("time" in use_timeline[step])? use_timeline[step].time : delay;
						local camera_time = ("camera_time" in use_timeline[step])? use_timeline[step].camera_time : voice_time;
						//_dpn("camera_time:"+camera_time);
						
						Battle_Std.Play_SubtitleVoice( use_timeline[step].SE, voice_time );
						
						//カメラ呼び出し処理
						local camera = ("camera" in use_timeline[step])? use_timeline[step].camera : 1;
						if( camera )
						{
							local use_voice_time = camera_time;//voice_time;
							local eff = BMvEff.CreateObject( { mvname="Mv_Null_StandbyCamera" } );
							if( eff.push() )
							{
								if( use_voice_time <= 90 ) use_voice_time = 90;//0div回避と保証フレームということに
								BMvTbl.SetLP(0,use_voice_time);
								
								eff.pop();
							}
						}
					}			
					if( "achievement_slot" in use_timeline[step] )
					{
						Battle_Std.CharaAchievement_Increment( use_timeline[step].achievement_slot, "SE" );
					}
					
					//次のPATのhint予約をする
					local next_step = step+1;
					// _dpn(" use_timeline.len():"+(use_timeline.len()) +" step:"+step+" -> "+next_step );
					if( use_timeline.len()-1 >= next_step )
					{
						if( "PAT" in use_timeline[next_step] )
						{
							//XXX:次のステップのcoreをチェックできていないので、相手キャラの予約を入れていることがある…から怖いのでコメントアウト
							// _dpn("-> hint予約:"+use_timeline[next_step].PAT+" "+delay+"F後");
							// BMvCore.CallEntryBCCachePreTransfer( { pat=use_timeline[next_step].PAT, frame=0, rest=delay } );
						}
					}
					
					target_core.pop();
				}
				
				// ディレイを設定
				if( delay > 0 ) // 停止時間の定義があった
				{
					BMvTbl.SetLP(3, delay ); // ステップを進ませない時間をセット
				}
				else // 定義がないので進める
				{
					step++;
					_dp(" -> ステップ進める");
				}
			}
			else // 停止フレームの定義があったあと
			{
				//Update的タイミング
				local stopframe = BMvTbl.AddLP(3,-1); // 残り時間を減らす
				if( stopframe <= 0 )
				{
					BMvTbl.SetLP(3, 0 );
					step++;
					_dp(" -> ステップ進める");
				}
			}
		}
		BMvTbl.SetLP(2,step); // 進めた分を記憶
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		_dp("\n 最後にフェードつきで戦闘開始可能状態へ移行");
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			BMvTbl.SetRoundStartType(1); // フェードタイプにする
			BMvTbl.SetRoundStart(); //戦闘開始可能状態にする
			player.pop();
		}
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			BMvTbl.SetRoundStartType(1); // フェードタイプにする
			BMvTbl.SetRoundStart(); //戦闘開始可能状態にする
			enemy.pop();
		}
	}
}

// どんな勝利なのかを取得
// ２回取得するからもしかしたらズレることもあるかもしれない
local get_wintype = function()
{
	local ret_wintype="ラウンド勝利";

	local rs = BMvTbl.GetMvRoundStatus();
	
	local is_ko = Battle_Std.GS_CheckFlag( def_PP_GS_KoAtk ); // 何かしらでKOした？

	if( !is_ko && rs.isWinRound )
	{
		// 決着タイムアップ勝利
		ret_wintype = "決着勝利_タイムアップ"; // タイムアップ決着
	}
	else if( rs.isWinRound )
	{
		// 決着勝利
		ret_wintype = "決着勝利"; // 決着
	}
	else if( !is_ko )
	{
		// タイムアップラウンド勝利
		ret_wintype = "ラウンド勝利_タイムアップ";
	}
	else
	{
		// ラウンド勝利
		ret_wintype = "ラウンド勝利";
	}
	// _dpn("ret_wintype:"+ret_wintype+" is_ko:"+is_ko);
	
	return ret_wintype;
}

local pic_winlife = function()
{
	local ret_winlife = "通常";
	
	local hp_ratio = BCMDTbl.GetHPRatio();
	local rand = BMvEff.Random_Limit(100);
	
	//HPが100%なら圧勝ボイス、0%（1%）なら辛勝ボイスに必ずなる
	//HPが70%以上なら圧勝ボイス、30%以下なら辛勝ボイスにするが、ランダムで通常ボイスにもなる
	
	if( hp_ratio>=100 )
	{
		ret_winlife = "圧勝";
	}
	else if( hp_ratio<=0 )
	{
		ret_winlife = "辛勝";
	}
	else if( hp_ratio>=70 && rand>=50 )
	{
		ret_winlife = "圧勝";
	}
	else if( hp_ratio<=30 && rand>=50 )
	{
		ret_winlife = "辛勝";
	}
	else
	{
		ret_winlife = "通常";
	}	
	
	// _dpn("hp_ratio:"+hp_ratio+" rand:"+rand+" -> "+ret_winlife );
	return ret_winlife;
}

Std_MoveTable.Mv_Win <- //勝利分岐
{
	function Init_Std() : (get_wintype)
	{
		Battle_Std.InitVector();
		BMvTbl.SetMuki(_Direction_Auto);
		
		BMvEff.CreateObject( { x=0, y=0, mvname="Mv_WinCamera" } ); //演出開始

		local wintype = get_wintype(); // 勝利情報取得
		
		switch( wintype )
		{
		case "決着勝利_タイムアップ":
			BMvTbl.SetFinalize(100);
			Battle_Std.Achievement_Unlock(29);//【トロフィー】タイムアップで勝利した
			break;
		case "決着勝利":
			BMvTbl.SetFinalize(200);
			break;
		case "ラウンド勝利":
			BMvTbl.SetFinalize(100);
			break;
		case "ラウンド勝利_タイムアップ":
			BMvTbl.SetFinalize(100);
			Battle_Std.Achievement_Unlock(29);//【トロフィー】タイムアップで勝利した
			break;
		}
		
		//ゲージ満タンで勝利したらトロフィー開放
		{
			local is_gauge_full = ( BMvEff.Liberate_Get() == _SpGaugeMode_Normal && BMvEff.SpGauge_GetAwakens()==1 && BCMDTbl.GetComboGauge() >= def_SC_SpGauge_MaxEx );
			local is_moon_full = (tDDC.Moon_GetType() == 0 && tDDC.Moon_GetValue() >= Def_MoonGaugeMax);

			if( is_moon_full && is_gauge_full )
			{
				Battle_Std.Achievement_Unlock(28);//【トロフィー】ムーンアイコンMAX、マジックサーキットを400%残して勝利した
			}
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_WinPattern", [100,"Mv_RoundWinPattern"], [200,"Mv_WinPattern"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.PatMv_Win <- //勝利分岐
{
	function Init_Std() : (get_wintype)
	{
		Battle_Std.InitVector();
		BMvTbl.SetMuki(_Direction_Auto);
		
		local wintype = get_wintype(); // 勝利情報取得
		
		switch( wintype )
		{
		case "決着勝利_タイムアップ":
			BMvTbl.SetFinalize(100);
			break;
		case "決着勝利":
			BMvTbl.SetFinalize(200);
			break;
		case "ラウンド勝利":
		case "ラウンド勝利_タイムアップ":
			BMvTbl.SetFinalize(100);
			break;
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("PatMv_WinPattern", [100,"PatMv_RoundWinPattern"], [200,"PatMv_WinPattern"] ); //デフォ,[code,mv]...
	}
}

//勝利時のカメラ注目
Std_MoveTable.Mv_WinCamera <-
{
	function Init_Std()
	{
		//開始位置は画面中央？
		local pos = BMvEff.GetCameraPosition( { x=0, y=0, flags=_GetPos_DispCamera } );
		BMvTbl.SetPosition(pos);
		
		//このオブジェクトに注目する
		BMvEff.SetCamera_Focus( { charapos=1, zoom=1.0, time=[45,999,60], type_in=3 } );
		
		
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_NoRender } ); //_ObjFlags_NoRender
		BMvEff.SetExist( { level = _Exist_NoHantei } );
	}
	function FrameUpdate_Std()
	{
		BMvEff.SetCamera_FocusKeep( 999 ); // チュートリアルで長いこと放置されるので無限ループにする
		
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		local maxlen = def_POS_GamenHajiX - (512*128);

		//操作親をホーミングしてカメラの目標にする
		local p = BMvCore.GetPlayerCharaData(); // 情報を得る
		
		if( p.IsDone ) // 有効かどうか一応チェック
		{
			BMvCore.PushCharaData( p ); // 
				local pos = BMvTbl.GetPosition( 0 );
			BMvCore.PopCharaData();

			local posst;
			local tpos = BMvTbl.CCharaPosition(); // 位置情報型の生成
			tpos.y = 0;
			if( pos.x <= -maxlen )
			{
				tpos.x = -maxlen;
				posst = BMvEff.GetPointStatus( { position=tpos } ); // 位置情報取得
				Battle_Std.SetMuki_CCharaPosition( tpos );
			}
			else if(pos.x >= maxlen)
			{
				tpos.x = maxlen;				
				posst = BMvEff.GetPointStatus( { position=tpos } ); // 位置情報取得
				Battle_Std.SetMuki_CCharaPosition( tpos );
			}
			else
			{
				posst = BMvEff.GetPointStatus( { target=p } ); // 位置情報取得
				//常に親の方を向き続ける
				Battle_Std.SetMuki_PlayerPosition();				
			}
			
			if( posst.distance_x>=512 )
			{
				BMvTbl.SetVector( { x=posst.distance_x/20,} );

			}
			else
			{
				Battle_Std.InitVector();
			}
		}
		else
		{
			Battle_Std.InitVector();		
			//print("x");
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.InitVector();
		BMvTbl.SetNextMoveTable( "..." );
	}
} 


Std_MoveTable.Mv_WinPattern <- //決着勝利アニメ
{
	function Init_Std() : (pic_winlife)
	{
		Battle_Std.InitVector();
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Win);
		
		local win_life = pic_winlife();
		
		BMvTbl.SetPP(def_PP_TMP0,0); // どの音声を再生したか 0:通常 1:圧勝　2:辛勝
	
		if( Def_Dbg_RoundStatus ) _dp1p("\nけっちゃこ勝利");
		if( Battle_Std.TypeSE_Play({ type="決着勝利", flags=(1<<1) }) == 0 ) //何も再生されなかった
		{
			//残り体力を見て分岐
			switch( win_life )
			{
			case "圧勝":
				Battle_Std.TypeSE_Play({ type="決着勝利_圧勝", flags=(1<<1) });
				BMvTbl.SetPP(def_PP_TMP0,1); // どの音声を再生したか 0:通常 1:圧勝　2:辛勝
				break;
			case "辛勝":
				Battle_Std.TypeSE_Play({ type="決着勝利_辛勝", flags=(1<<1) });
				BMvTbl.SetPP(def_PP_TMP0,2); // どの音声を再生したか 0:通常 1:圧勝　2:辛勝
				break;
			case "通常":
				Battle_Std.TypeSE_Play({ type="決着勝利_通常", flags=(1<<1) });
				BMvTbl.SetPP(def_PP_TMP0,0); // どの音声を再生したか 0:通常 1:圧勝　2:辛勝
				break;
			}
		}		
	}
	function LastUpdate_Std() //
	{
		//念のため
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする
	}	
	function Finalize_Std() // 
	{
		//次のラウンドへの処理？
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする？
		BMvTbl.SetNextMoveTable( "Mv_WinPatternEnd" );
	}
}

Std_MoveTable.Mv_WinPatternEnd <-
{
	function Init_Std() // 
	{
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする
		
		// 存在すればループアニメに移行（適当）
		BMvTbl.JumpFrameID( 999 );
	}
	function Update_Std()
	{
		if( BMvTbl.GetMvStatus().MvCount == 600 )
		{
			BMvEff.Chara_ClearMessageAll();
		}
	}
	function Finalize_Std() // 
	{
		// どこにもいかないでここで留まる		
	}
}

Std_MoveTable.PatMv_WinPattern <- //決着勝利アニメ
{
	function Init_Std()
	{
		Battle_Std.InitVector();
		BMvTbl.SetPosition( { y=0 } ); // 保険処理で地上につける
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Win);
	}
	function LastUpdate_Std() //
	{
		//念のため
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする
	}	
	function Finalize_Std() // 
	{
		//次のラウンドへの処理？
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする？
		BMvTbl.SetNextMoveTable( "PatMv_WinPatternEnd" );
	}
}

Std_MoveTable.PatMv_WinPatternEnd <-
{
	function Init_Std() // 
	{
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする
		
		// 存在すればループアニメに移行（適当）
		BMvTbl.JumpFrameID( 999 );
	}
	function Finalize_Std() // 
	{
		// どこにもいかないでここで留まる		
	}
}


Std_MoveTable.Mv_RoundWinPattern <- //決着勝利アニメ
{
	function Init_Std() : (get_wintype,pic_winlife)
	{
		Battle_Std.InitVector();
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_RoundWin);
		
		local wintype = get_wintype(); // 勝利情報取得
		local win_life = pic_winlife();
		
		if( wintype == "決着勝利_タイムアップ" )
		{
			if( Def_Dbg_RoundStatus ) _dpn("決着勝利_タイムアップ");
			Battle_Std.TypeSE_Play({ type="決着勝利_タイムアップ", flags=(1<<1) });
		}
		else
		{
			if( Def_Dbg_RoundStatus ) _dp1p("\nラウンド取得");
			
			if( wintype == "ラウンド勝利_タイムアップ" && Battle_Std.TypeSE_Play({ type="ラウンド勝利_タイムアップ", flags=(1<<1) }) )
			{
				// _dpn("タイムアップでかつタイムアップの音声が定義されていたので再生");
			}
			else if( Battle_Std.TypeSE_Play({ type="ラウンド勝利", flags=(1<<1) }) )
			{
				// _dpn("タイムアップかどうかはわからないが、ラウンド勝利の音声が定義されていたので再生");
			}
			else
			{
				// _dpn("何も再生されなかったのできっと細かく定義されているはずなので、残り体力を見て分岐して再生");
				switch( win_life )
				{
				case "圧勝":
					Battle_Std.TypeSE_Play({ type="ラウンド勝利_圧勝", flags=(1<<1) });
					break;
				case "辛勝":
					Battle_Std.TypeSE_Play({ type="ラウンド勝利_辛勝", flags=(1<<1) });
					break;
				case "通常":
					Battle_Std.TypeSE_Play({ type="ラウンド勝利_通常", flags=(1<<1) });
					break;
				}
			}
		}		
	}
	function LastUpdate_Std() //
	{
		//念のため
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする
	}	
	function Finalize_Std() // 
	{
		//次のラウンドへの処理？
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする？
		BMvTbl.SetNextMoveTable( "Mv_RoundWinPatternEnd" );
	}
}

Std_MoveTable.Mv_RoundWinPatternEnd <-
{
	function Init_Std() // 
	{
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする
		
		// 存在すればループアニメに移行（適当）
		BMvTbl.JumpFrameID( 999 );
	}
	function Update_Std()
	{
		if( BMvTbl.GetMvStatus().MvCount == 600 )
		{
			BMvEff.Chara_ClearMessageAll();
		}
	}
	function Finalize_Std() // 
	{
		// どこにもいかないでここで留まる
	}
}

Std_MoveTable.PatMv_RoundWinPattern <- //決着勝利アニメ
{
	function Init_Std()
	{
		Battle_Std.InitVector();
		BMvTbl.SetPosition( { y=0 } ); // 保険処理で地上につける
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_RoundWin);
	}
	function LastUpdate_Std() //
	{
		//念のため
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする
	}	
	function Finalize_Std() // 
	{
		//次のラウンドへの処理？
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする？
		BMvTbl.SetNextMoveTable( "PatMv_RoundWinPatternEnd" );
	}
}

Std_MoveTable.PatMv_RoundWinPatternEnd <-
{
	function Init_Std() // 
	{
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする
		
		// 存在すればループアニメに移行（適当）
		BMvTbl.JumpFrameID( 999 );
	}
	function Finalize_Std() // 
	{
		// どこにもいかないでここで留まる
	}
}



Std_MoveTable.Mv_TimeupLose <- //時間切れ負け
{
	function Init_Std() // 
	{
		Battle_Std.InitVector();
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_TimeupLose);
		
		Battle_Std.TypeSE_Play({ type="タイムアップ敗北" });
	}
	function LastUpdate_Std() //
	{
		//念のため
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする
	}	
	function Finalize_Std() // 
	{
		//次のラウンドへの処理？
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする？
		BMvTbl.SetNextMoveTable( "Mv_TimeupLoseEnd" );
	}
}

Std_MoveTable.Mv_TimeupLoseEnd <-
{
	function Init_Std() // 
	{
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする
		
		// 存在すればループアニメに移行（適当）
		BMvTbl.JumpFrameID( 999 );
	}
	function Finalize_Std() // 
	{
		
	}
}


Std_MoveTable.PatMv_TimeupLose <- //時間切れ負け
{
	function Init_Std() // 
	{
		Battle_Std.InitVector();
		BMvTbl.SetPosition( { y=0 } ); // 保険処理で地上につける
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_TimeupLose);
		
		// Battle_Std.TypeSE_Play({ type="タイムアップ敗北" });
	}
	function LastUpdate_Std() //
	{
		//念のため
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする
	}	
	function Finalize_Std() // 
	{
		//次のラウンドへの処理？
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする？
		BMvTbl.SetNextMoveTable( "PatMv_TimeupLoseEnd" );
	}
}

Std_MoveTable.PatMv_TimeupLoseEnd <-
{
	function Init_Std() // 
	{
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする
	}
	function Finalize_Std() // 
	{
		
	}
}

Std_MoveTable.PatMv_Lose <- //パートナー負け
{
	function Init_Std() // 
	{
		Battle_Std.InitVector();
		BMvTbl.SetPosition( { y=0 } ); // 保険処理で地上につける
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_TimeupLose);
	}
	function LastUpdate_Std() //
	{
		//念のため
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする
	}	
	function Finalize_Std() // 
	{
		//次のラウンドへの処理？
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする？
		BMvTbl.SetNextMoveTable( "PatMv_LoseEnd" );
	}
}

Std_MoveTable.PatMv_LoseEnd <-
{
	function Init_Std() // 
	{
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする
	}
	function Finalize_Std() // 
	{
		
	}
}

//キャラのオーラを出す時にオーラの時間分こいつが出てる
//終了時に持続のフラグを消す
Std_MoveTable.Mv_Obj_CharaAura <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } ); //隠すｗ
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
		
		// local PSFlag = BMvTbl.GetLP(0);
	}
	function Update_Std()
	{
		if( BMvTbl.GetLP(0) > 0 )
		{
			BMvTbl.AddLP(0,-1);
		}
		else
		{
			BMvTbl.SetFinalize(0); //オーラの予定されてた持続時間終了
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable(); //ばいばーい
	}
	function LastUpdate_Std()
	{
	}
}

//リバーサル時間を減らすだけのオブジェクト
Std_MoveTable.Mv_Obj_ReversalTime <-
{
	function Init_Std()
	{
		//print("\n開始");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
	}
	function Update_Std() //Updateじゃないと投げ関係で不具合でる
	{
		local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		BMvCore.PushCharaData( p ); //
			local pp = BMvTbl.GetPP( def_PP_ReversalLeftTime );
			if( pp>0 ) pp--;
			BMvTbl.SetPP( def_PP_ReversalLeftTime, pp );
		BMvCore.PopCharaData();
		
		//print("\n残り:"+pp);
		
		if( pp <= 0) BMvTbl.SetFinalize(0);
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//ＳＥを遅らせて再生するオブジェクト
Std_MoveTable.Mv_Obj_DelayPlaySE <-
{
	function Init_Std()
	{
		// _dpn("Mv_Obj_DelayPlaySE:"+BMvTbl.GetLP(0)+" - "+BMvTbl.GetLP(1) );
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
		//LP0 ディレイ
		//LP1 再生する番号
	}
	function Update_Std() //Updateじゃないと投げ関係で不具合でる
	{
		//print(".");
		//LPを減らしていって0になったら再生する
		if( BMvTbl.GetLP(0)>0 )
		{
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				local isUpdate = BMvTbl.GetMvStatus().isUpdate;
				local mvhs = BMvTbl.GetMvHitStatus();
				local isAtkHitStop = (!isUpdate && mvhs.Type&_HitType_Hit && mvhs.Count>0);
				player.pop();
				
				// _dpn("isUpdate:"+isUpdate+" isAtkHitStop:"+isAtkHitStop+" HitStop:"+mvhs.Count );
				
				if( isUpdate || isAtkHitStop )
				{
					//時間停止中じゃないときのみ進める
					//updateしてないときも攻撃があたっててヒットストップがかかってるときは時間停止じゃなくて攻撃ヒット時なので進める
					BMvTbl.AddLP(0,-1);
				}
				// else
				// {
					// _dpn("----------------------------------以前と違う:"+BMvTbl.GetLP(0)+" - "+BMvTbl.GetLP(1) );
				// }
			}
		}
		else //タイミングがきた
		{
			//再生
			local num = BMvTbl.GetLP(1);
			_vdm(format("PlaySE [%3d] -- Delay",num));
			Battle_Std.PlayerSE_Play( num ); //_SeType_Playerのnumを再生して記憶
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//ＳＥを遅らせて再生するオブジェクト2 Param0まち
Std_MoveTable.Mv_Obj_DelayParam0PlaySE <-
{
	function Init_Std()
	{
		//print("\n開始");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
		//LP0 まつParam0
		//LP1 再生する番号
	}
	function Update_Std() //Updateじゃないと投げ関係で不具合でる
	{
		local mvs = Battle_Std.GetPlayerMvStatus();
		//print("."+mvs.Param0+"\n");
		//操作親のParam0を監視して一致したら再生
		
		if( mvs.Param0 == BMvTbl.GetLP(0) )
		{
			//再生
			local num = BMvTbl.GetLP(1);
			_vdm(format("PlaySE [%3d] -- DelayParam0",num));
			Battle_Std.PlayerSE_Play( num ); //_SeType_Playerのnumを再生して記憶
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}


//共通アクションここまで	



/*
	ガード関係
*/

local set_Nagemukite_GuardModori = function()
{
	if( Battle_Std.ChangeMoveCodeEx_CheckFlag(1, def_MC1_ShieldFailed ) )
	{
		_dp("\n 前が失敗シールドだったので投げ無敵無し");
		BMvEff.SetPlayerTimer( { muteki_nage=0 } ); //無敵時間は無し
	}
	else if( Def_Sys_ShieldMissGuard_LastNoNageMuteki && Battle_Std.ChangeMoveCodeEx_CheckFlag(5, def_MC5_ShieldMissGuard ) )
	{
		BMvEff.SetPlayerTimer( { muteki_nage=2 } ); //ハメ回避のため少しだけ
	}
	else
	{
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_ModoriGuardNageMuteki } ); //無敵時間を設定
	}
}

//立ちガード戻り
Std_MoveTable.Mv_Modori_GuardS <- 
{
	function Init_Std() : (set_Nagemukite_GuardModori)
	{
		if( Battle_Std.ChangeMoveCodeEx_CheckFlag( 2, def_MC2_ShiledSuccess ) ) // シールド成功
		{
			BMvTbl.SetFinalize(100);
			return;
		}
		else
		{
			BMvTbl.SetMuki(_Direction_Auto);
			BMvTbl.SetPattern(def_PAT_GuardS);
			
			if (BMvTbl.JumpFrameID( 120 ) == -1)
			{
				_dem("【警告】飛び先のフレームIDが無い");
				BMvTbl.SetFinalize(0);
			}
			set_Nagemukite_GuardModori(); // 失敗シールドじゃなけりゃ投げ無敵を設定
			
			Battle_Std.TypeSE_Play({ type="ガード戻り" });
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [100,"Mv_Modori_ShieldS"] ); //デフォ,[code,mv]...	
	}
}

Std_MoveTable.Mv_Modori_ShieldS <- 
{
	function Init_Std()
	{
		BMvTbl.SetPattern(def_PAT_Barrier_Std);
		
		Battle_Std.CallBarrierEndEffect();
		
		if (BMvTbl.JumpFrameID( 20 ) == -1)
		{
			_dem("【警告】飛び先のフレームIDが無い");
			BMvTbl.SetFinalize(0);
		}
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		//MEMO:投げ無敵はない
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

//屈ガード戻り
Std_MoveTable.Mv_Modori_GuardC <- 
{
	function Init_Std() : (set_Nagemukite_GuardModori)
	{
		BMvTbl.SetMuki(_Direction_Auto);
		
		if( Battle_Std.ChangeMoveCodeEx_CheckFlag( 2, def_MC2_ShiledSuccess ) ) // シールド成功
		{
			BMvTbl.SetFinalize(100);
			return;
		}
		else
		{
			BMvTbl.SetPattern(def_PAT_GuardC);
			
			if (BMvTbl.JumpFrameID( 120 ) == -1)
			{
				_dem("【警告】飛び先のフレームIDが無い120");
				BMvTbl.SetFinalize(0);
			}
			
			set_Nagemukite_GuardModori(); // 失敗シールドじゃなけりゃ投げ無敵を設定

			Battle_Std.TypeSE_Play({ type="ガード戻り" });
			BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Crouch_Wait", [100,"Mv_Modori_ShieldC"] ); //デフォ,[code,mv]...	
	}
}

Std_MoveTable.Mv_Modori_ShieldC <- 
{
	function Init_Std()
	{
		BMvTbl.SetPattern(def_PAT_Barrier_Cro);
		
		Battle_Std.CallBarrierEndEffect();
		
		if (BMvTbl.JumpFrameID( 20 ) == -1)
		{
			_dem("【警告】飛び先のフレームIDが無い");
			BMvTbl.SetFinalize(0);
		}
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		//MEMO:投げ無敵はない
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}

//空中ガード戻り　※141129 仕様を変更、ベースデータも落下パターンへの変化でファイナライズするように
Std_MoveTable.Mv_Modori_GuardA <- 
{
	function Init_Std() : (set_Nagemukite_GuardModori)
	{
		//BMvTbl.SetPattern(def_PAT_GuardA); //※
		// 戻りが２パターンある
		if( BMvTbl.CheckPosState( _PosState_Air ) )//空中状態でガード解除
		{
			Battle_Std.MoveCodeEx.AddFlag( 5, def_MC5_EnableAirToLandedShield );
			
			if( Battle_Std.ChangeMoveCodeEx_CheckFlag( 2, def_MC2_ShiledSuccess ) ) // シールド成功
			{
				BMvTbl.SetFinalize(400);
				return;
			}
			else
			{
				if (BMvTbl.JumpFrameID( 120 ) == -1)
				{
					_dem("【警告】飛び先のフレームIDが無い");
					BMvTbl.SetFinalize(0);
				}
			}
		}
		else	//地上状態でガード解除
		{
			if( Battle_Std.ChangeMoveCodeEx_CheckFlag( 2, def_MC2_ShiledSuccess ) ) // シールド成功
			{
				BMvTbl.SetFinalize(300);
				return;
			}
			else
			{
				BMvTbl.SetFinalize(200); // Mv_Modori_GuardS　へ
			}
		}
		
		set_Nagemukite_GuardModori(); // 失敗シールドじゃなけりゃ投げ無敵を設定
		
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		BMvTbl.SetMuki(_Direction_Auto);
		Battle_Std.TypeSE_Play({ type="ガード戻り" });
		
		// ガードフロートからの戻り
		if( BMvTbl.GetLP(8) ==1 ) // 無敵をセットされていた
		{
			BMvEff.SetPlayerTimer( { muteki_dage=254, muteki_dageX=254 } );
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_GenFlag ); // Mv_Modori_GuardA時はガードフロート
		}	
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding )
		{
			BMvTbl.SetFinalize(100);
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Modori_GuardAFall", [100,"Mv_Modori_GuardAFallLand"], [200,"Mv_Modori_GuardS"], [300,"Mv_Modori_ShieldS"], [400,"Mv_Modori_ShieldA"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0 } );
	}	
}

Std_MoveTable.Mv_Modori_ShieldA <- 
{
	function Init_Std()
	{
		Battle_Std.CallBarrierEndEffect();
		
		if (BMvTbl.JumpFrameID( 20 ) == -1)
		{
			_dem("【警告】飛び先のフレームIDが無い");
			BMvTbl.SetFinalize(0);
		}
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		//MEMO:投げ無敵はない
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding )
		{
			BMvTbl.SetFinalize(100);
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Modori_GuardAFall", [100,"Mv_Modori_GuardAFallLand"] ); //デフォ,[code,mv]...
	}
}

//空中ガード戻りからの落下
//キャラによってパターンが違う…
local pat_AirGuardModoriFall = chrparam.Get( { type="空中ガードからの戻りパターン", chrnum=_ChrNo } );

Std_MoveTable.Mv_Modori_GuardAFall <- 
{
	function Init_Std() : (pat_AirGuardModoriFall)
	{
		BMvTbl.SetPattern( pat_AirGuardModoriFall ); // 空中ガードからの戻りパターンを設定
		//Mv中行動可能
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		
		// ガードフロートからの戻り
		if( BMvTbl.GetLP(8) ==1 ) // 無敵をセットされていた
		{
			BMvEff.SetPlayerTimer( { muteki_dage=254, muteki_dageX=254 } );
			Battle_Std.MoveCodeEx.AddFlag( 5, def_MC5_EnableAirToLandedShield );
		}
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding )
		{
			BMvTbl.SetFinalize(100);
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [100,"Mv_Modori_GuardAFallLand"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0 } );
	}
}

Std_MoveTable.Mv_Modori_GuardAFallLand <- 
{
	function Init_Std() : (pat_AirGuardModoriFall)
	{
		//※パターンは多分指定してあるだろう
		Battle_Std.InitCharaVector();
		//Mv中行動可能
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする				
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );	//ファイナライズはどのみち着地してからっす
	}
}



//地上やられからの戻り
Std_MoveTable.Mv_Modori_YarareS <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_ModoriYarareNageMuteki } ); //無敵時間を設定
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

//地上やられからの戻り・しゃがみ
Std_MoveTable.Mv_Modori_YarareC <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_ModoriYarareNageMuteki } ); //無敵時間を設定
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}

//投げ抜け攻撃からの戻り
Std_MoveTable.Mv_Modori_Nagenuke <- 
{
	function Init_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_ModoriGuardNageMuteki, muteki_nageX=def_FL_ModoriGuardNageMuteki } ); //無敵時間を設定
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

//投げ抜けられからの戻り
Std_MoveTable.Mv_Modori_Nagenukerare <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_GuardS);
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_ModoriGuardNageMuteki, muteki_nageX=def_FL_ModoriGuardNageMuteki } ); //無敵時間を設定
		
		if (BMvTbl.JumpFrameID( 120 ) == -1)
		{
			_dem("【警告】飛び先のフレームIDが無い");
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

//地上やられからの戻り
Std_MoveTable.Mv_Modori_KirimomiYarareS <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		// ガードモーションから、きりもみやられの後半パターンを使うように変更
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_ModoriYarareNageMuteki } ); //無敵時間を設定
		
		if (BMvTbl.JumpFrameID( 256 ) == -1)
		{
			_dem("【警告】飛び先のフレームIDが無い");
			BMvTbl.SetFinalize(0);
		}			
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする				
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}



//空中投げ抜け攻撃からの戻り
Std_MoveTable.Mv_Modori_NagenukeAir <- 
{
	function Init_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_ModoriGuardNageMuteki, muteki_nageX=def_FL_ModoriGuardNageMuteki } ); //無敵時間を設定
		BMvTbl.SetVector( { x=0, addx=0, y=1000, addy=250 } );
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Modori_NagenukeAir_Fall" );
	}
}

Std_MoveTable.Mv_Modori_NagenukeAir_Fall <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetPattern(20);
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

//空中投げ抜けられからの戻り
Std_MoveTable.Mv_Modori_NagenukerareAir <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_GuardA);
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_ModoriGuardNageMuteki, muteki_nageX=def_FL_ModoriGuardNageMuteki } ); //無敵時間を設定
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		
		if (BMvTbl.JumpFrameID( 120 ) == -1)
		{
			_dem("【警告】飛び先のフレームIDが無い");
			BMvTbl.SetFinalize(0);
		}	
		BMvTbl.SetVector( { x=0, addx=0, y=0, addy=200 } );
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Modori_NagenukerareAir_Fall" );
	}
}

Std_MoveTable.Mv_Modori_NagenukerareAir_Fall <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetPattern(20);
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}


//復帰やられからの戻り
Std_MoveTable.Mv_Modori_FukkiYarare <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_ModoriYarareNageMuteki } ); //無敵時間を設定
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		// BMvTbl.SetFinalize(0);
		BMvTbl.SetPattern(21); // 着地の絵に？
		//リバサ猶予のばしてみる
		Battle_Std.Reversal.SetTime(); //リバーサル受付＋判定オブジェクト生成
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

//ここでＫＯチェックで大丈夫か？
//ここから先はbound属性が解除されているので無敵時間とかをつけないとまずそう
Std_MoveTable.Mv_Modori_Down <- // ダウンからの起き上がり待機
{
	function Init_Std() // 
	{
		//_dm("起き上がり1");
		//ここまできたらダウン追い討ちされなかったのでダウン時間をリセット	
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dageX=254, muteki_nageX=254 } ); //無敵時間を設定
	
		//まず起き上がり先のパターンへ進む
		//パターンに応じて分岐
		local mvs = BMvTbl.GetMvStatus();
		local now_pat = mvs.DataPattern;
		
		// _dpn("起き上がり処理:"+now_pat );
		
		local oki_pat = def_PAT_Oki_Aomuke;//起き上がりのパターンを決める
		switch( now_pat )
		{
		case def_PAT_Down_Aomuke://590
			oki_pat = def_PAT_Oki_Aomuke;//593
			break;
		case def_PAT_Down_Utubuse://591
			oki_pat = def_PAT_Oki_Utubuse;//594
			break;
		default:
			oki_pat = def_PAT_Oki_Aomuke;//590
			break;
		}
		BMvTbl.SetPattern(oki_pat);

		local rs = BMvTbl.GetMvRoundStatus(); //ラウンドステータス取得		
		if (rs.isMyKo) //KO状態なら寝たきり
		{
			BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0 } ); //起き上がり無敵時間を消去

			//・別のMvに状態移行
			//ラウンドとられただけか敗北かに飛ぶ
			if( rs.isLoseRound )
			{
				BMvTbl.SetFinalize(def_FC_Lose);
			}
			else if( rs.WinType == -1) //自分が勝っているかどうか（KO後のみ）、0-負け 1-勝ち -1-引き分け
			{
				//引き分け（勝敗ポイントが両者に入る時）は敗北Mvにして起き上がらないようにする
				//TODO:Ｍｖ見て何かしているものがあるとちょっと都合が悪いかも
				BMvTbl.SetFinalize(def_FC_Lose);			
			}
			else
			{
				BMvTbl.SetFinalize(def_FC_RoundLose);
			}
		}
		else //KOされてないので起き上がる
		{
		}
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		// print("\n mvcount:"+mvs.MvCount );
		
		// FrameID1024で無限ループしているところ
		{
			// ＣＳから起き上がりボイスは2F目に再生するように変更
			if( mvs.MvCount == 2 )
			{
				if( Battle_Std.EnemyisKO() )
				{
					//相手がKOしてたら再生しない
				}
				else
				{
					//瀕死かどうかで分岐
					if( Battle_Std.CheckEnemyIsSPActionProduction() )
					{
						//相手が超技演出中はボイスなし
						//被弾してる場合はここにくることはないが、パートナーがここに入ることがある
					}
					else
					{
						if( mvs.flags&_MvStFlag_DangerHPDef )
						{
							Battle_Std.TypeSE_Play({ type="起き上がり瀕死" });
						}
						else
						{
							Battle_Std.TypeSE_Play({ type="起き上がり" });
						}
					}
				}
			}
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Modori_Okiagari", [def_FC_RoundLose,"Mv_RoundLose"], [def_FC_Lose,"Mv_Lose"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dageX=0, muteki_nageX=0 } ); //この２つは怖いので消しておく
		Battle_Std.Reversal.SetTime(); //リバーサル受付＋判定オブジェクト生成
	}
}


//決着敗北で寝たきり
//このMvの名前を見て勝利ポーズは分岐してるよ
//引き分けの時は両者このmvになるよ
Std_MoveTable.Mv_Lose <-
{
	function Init_Std() // 
	{
		// if( Def_Dbg_RoundStatus ) _dp(" -> Mv_Lose");
		if( BMvTbl.JumpFrameID( 1024 ) == -1 )
		{
			_dm("【警告】飛び先のフレームIDが無い 1024");
		}
		BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Add } ); //重なり判定無し
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
		
		BMvTbl.SetLP(0,0); // RoundEndを呼んだら1
		local tagStatus = BMvCore.GetTagStatus();//-1:通常 1:タッグのメイン 0:タッグのパートナー
		if( tagStatus != 1 )
		{
			BMvTbl.SetRoundEnd(); //ラウンド終了命令を入れる
			BMvTbl.SetLP(0,1); // RoundEndを呼んだら1
		}
	}
	function FrameUpdate_Std()
	{
		if( BMvTbl.GetLP(0)==0 ) // TagStatusが1(タッグのメイン)で、かつRoundEndを呼んでいない 
		{
			local tagStatus = BMvCore.GetTagStatus();//-1:通常 1:タッグのメイン 0:タッグのパートナー
			if( tagStatus == 1 )
			{
				//パートナーが地上で行動可能になるか、240F経つまで待つ
				if( BtlPt.PartnerIsMoveableAndAboutGround() || BMvTbl.GetMvStatus().MvCount>240 )
				{
					BMvTbl.SetRoundEnd(); //ラウンド終了命令を入れる
					BMvTbl.SetLP(0,1); // RoundEndを呼んだら1
				}
			}
		}
	}
	function Finalize_Std() // 
	{
		_dem("【警告】へんなファイナライズ");
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );	//発生しないはず
	}
	function LastUpdate_Std()
	{
		BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Erase } ); //重なり判定消去戻し
	}
}

//ラウンド敗北で起き上がる
//引き分けの時はここにこないよ
Std_MoveTable.Mv_RoundLose <-
{
	function Init_Std() // 
	{
		if( BMvTbl.JumpFrameID( 1024 ) == -1 )
		{
			_dm("【警告】飛び先のフレームIDが無い 1024");
		}
		BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Add } ); //重なり判定無し
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
		
		BMvTbl.SetLP(0,0); // RoundEndを呼んだら1
		local tagStatus = BMvCore.GetTagStatus();//-1:通常 1:タッグのメイン 0:タッグのパートナー
		if( tagStatus != 1 )
		{
			BMvTbl.SetRoundEnd(); //ラウンド終了命令を入れる
			BMvTbl.SetLP(0,1); // RoundEndを呼んだら1
		}
	}
	function FrameUpdate_Std()
	{
		if( BMvTbl.GetLP(0)==0 ) // TagStatusが1(タッグのメイン)で、かつRoundEndを呼んでいない 
		{
			local tagStatus = BMvCore.GetTagStatus();//-1:通常 1:タッグのメイン 0:タッグのパートナー
			if( tagStatus == 1 )
			{
				//パートナーが地上で行動可能になるか、240F経つまで待つ
				if( BtlPt.PartnerIsMoveableAndAboutGround() || BMvTbl.GetMvStatus().MvCount>240 )
				{
					BMvTbl.SetRoundEnd(); //ラウンド終了命令を入れる
					BMvTbl.SetLP(0,1); // RoundEndを呼んだら1
				}
			}
		}
	}
	function Finalize_Std() // 
	{
	}
	function LastUpdate_Std()
	{
		BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Erase } ); //重なり判定消去戻し
	}	
}


local pat_OkiagariFreeMotionAr = chrparam.Get( { type="起き上がりのフリーモーションパターン", chrnum=_ChrNo } );
local pat_OkiagariFreeMotionFinalizeMv = chrparam.Get( { type="起き上がりのフリーモーションFinalize先", chrnum=_ChrNo } );

Std_MoveTable.Mv_Modori_Okiagari <- // 起き上がりのフリーモーション
{
	function Init_Std() : (pat_OkiagariFreeMotionAr, _ChrNo )
	{
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_OkiagariNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_OkiagariNageMuteki } ); //起き上がり無敵時間を設定
		
		if( _ChrNo == Def_ChrNo_Chr018 )
		{
			BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動不能にする
		}
		else
		{
			BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		}
		
		//起き上がりのフリーモーション
		local mvs = BMvTbl.GetMvStatus();
		switch(mvs.DataPattern)
		{
		case 593:
			if( pat_OkiagariFreeMotionAr[0] )
			{
				BMvTbl.SetPattern(pat_OkiagariFreeMotionAr[0]);
			}
			else
			{
				BMvTbl.SetFinalize(0);
			}
			break;
		case 594:
			if( pat_OkiagariFreeMotionAr[1] )
			{
				BMvTbl.SetPattern(pat_OkiagariFreeMotionAr[1]);
			}
			else
			{
				BMvTbl.SetFinalize(0);
			}
		default:
			BMvTbl.SetFinalize(0);//エラー
			break;		
		}
	}
	function Finalize_Std() : (pat_OkiagariFreeMotionFinalizeMv)
	{
		BMvTbl.SetNextMoveTable( pat_OkiagariFreeMotionFinalizeMv );
	}
}
	


	
	



//登場タイミングで呼ばれる関数
/*
function Std_MoveTable::Startup()
{
	//
	print("\nStartup");
}
*/

//「勝利キャラの」終了タイミングと、タイムアップ時に両者で呼ばれて、
// 行動文字列を返す、行動が存在しないまたは""が返されるとなにもしない
Std_MoveTable.GetResultMvName <- function()
//function Std_MoveTable::GetResultMvName()
{
	//デバッグ処理
	if( 0 )
	{
		local pside = BMvTbl.GetPlayerSide();//0:1Pサイド 1:2Pサイド
		local tagStatus = BMvCore.GetTagStatus();//-1:通常 1:タッグのメイン 0:タッグのパートナー
		local roundst = BMvTbl.GetMvRoundStatus(); // これで判別
		local tag_str = { [-1]="通常キャラ", [1]="メイン", [0]="パートナー" };
	
		_dpn("★GetResultMvName Round:"+roundst.Round+" "+(pside+1)+"Pサイド "+tag_str[tagStatus] );
	}
	
	//_dem("終了:GetResultMvName");

	local p = BMvTbl.GetMvRoundStatus(); // これで判別
	//print("\n::GetResultMvName" + p.Round + "," + p.isMyKo + "," + p.WinType + " : " + p.isWinRound );

	//if( p.Round < 0 ) return ""; // トレーニング
	if( p.isMyKo )
	{
		// KOされたら倒れているのでポーズを取らない
		//ここにはいってくることはないのではないか？だぶるＫＯでも入ってこない
		//_dem("敗北")
		return "";
	}
	else
	{
		// 起きている、勝ち以外はほぼタイムアップ
		local is_partner = (BMvCore.GetTagStatus() == 0);
		
		if( p.WinType == 1 ) // 勝ち
		{
			if( Def_Dbg_RoundStatus ) _dm("勝利orタイムアップ勝利");
			return (is_partner)? "PatMv_Win" : "Mv_Win";
		}
		else
		if( p.WinType == 0 ) // 負け
		{
			if( is_partner )
			{
				//パートナー側のときは親が死んでるかどうかでタイムアップかどうか検知
				return ( BtlPt.CheckPartnerIsKo() )? "PatMv_Lose" : "PatMv_TimeupLose";
			}
			else
			{
				//タイムアップ
				if( Def_Dbg_RoundStatus ) _dm("タイムアップ敗北");
				return "Mv_TimeupLose";
			}
		}
		else
		{
			// ドロー
			if( is_partner )
			{
				//パートナー側のときは親が死んでるかどうかでタイムアップかどうか検知
				return ( BtlPt.CheckPartnerIsKo() )? "PatMv_Lose" : "PatMv_TimeupLose";
			}
			else
			{
				//タイムアップ
				if( Def_Dbg_RoundStatus ) _dm("タイムアップドロー");
				return (is_partner)? "PatMv_TimeupLose" : "Mv_TimeupLose";
			}
		}
	}
	return "";
}

//攻撃がヒットするとよばれる
//相手のDamageImpactと同時
Std_MoveTable.AttackImpact <- function( info )
{
	// info は BMvTbl::MvHitImpactInfo クラス
	Battle_Std.AttackImpact_StdFunc(info);
}

//攻撃を受けるとよばれる
//相手のAttackImpactと同時
Std_MoveTable.DamageImpact <- function( info )
{
	// info は BMvTbl::MvHitImpactInfo クラス
	Battle_Std.DamageImpact_StdFunc(info);
}

//攻撃判定同士の接触で呼ばれる
//return 0 すると相殺しない
//最初は1P>2Pと順に呼ばれるが、1Pで成功したら2Pは結果として呼ばれない
//描画のprioが手前なほうが先に呼ばれる（＝最後に殴ったほうが先）
Std_MoveTable.CheckSousai <- function()
{
	// _dm("CheckSousai");
	if( Def_Sys_BackAttackSousai )
	{
		return 1;//相殺
	}
	else
	{
		// 背面からの攻撃では相殺しないようにする処理

		local pmuki = BMvTbl.GetMuki();
		local ppos = BMvTbl.GetPosition();
		local p_nomals = Battle_Std.MoveCode.CheckFlag( def_MC_Atk );//通常技
		local p_shieldcounter = Battle_Std.MoveCodeEx.CheckFlag( 4, def_MC4_ShieldCounter ); // シールドカウンターの行動
		local p_checkmv = (p_nomals && !p_shieldcounter);
		
		//相殺親同士の相殺しかおきない仕様なので、厳密に誰同士か取得しないでOK
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			local emuki = BMvTbl.GetMuki();
			local epos = BMvTbl.GetPosition();
			local e_nomals = Battle_Std.MoveCode.CheckFlag( def_MC_Atk );//通常技
			local e_shieldcounter = Battle_Std.MoveCodeEx.CheckFlag( 4, def_MC4_ShieldCounter ); // シールドカウンターの行動
			local e_checkmv = (e_nomals && !e_shieldcounter);
			enemy.pop();
			
			//相殺の条件
			//・自分と相手が向き合っているor背向け同士のとき
			//　向き合う＝向きが不一致、かつ向いてる方向に相手がいる
			//　背向け同士は基本的にはおかしいが、ワルク6Cなどのすり抜け過ぎながら系に対応＆相殺ムービー向け
			//　あくまで背面から殴られたときだけ弾くようにする
			//　→向きが一緒のときだけ弾けば良い
			
			//今回は通常技のみ弱くするということで、対象は通常技のみにする
			//ジャンプ攻撃だけにしても良いかもだが、一旦は通常技のみにした
			//シールドカウンターは通常技属性が付いてるので例外的に除外している
			
			// _dpn(pmuki+":"+emuki);
			
			//向きが一致で通常技が含まれてるときチェック
			if( pmuki == emuki )
			{
				//弱い通常技が背後から攻撃されているときは失敗にする
				//攻撃判定同士なので、相手側視点でも弾く必要がある
				if( p_checkmv && epos.x*emuki < ppos.x*pmuki )
				{
					_dpn("自分が通常技で相手が背後にいるから相殺しない　e> p>");
					return 0;
				}
				if( e_checkmv && ppos.x*pmuki < epos.x*emuki )
				{
					_dpn("相手が通常技で自分が背後にいるから相殺しない　p> e>");
					return 0;
				}
			}
			
			/*
			// このチェックで相殺しないようにするとすり抜け攻撃同士の相殺などがおきなくて寂しいし
			// BCシルカンの性能的にもこのチェックがない方が自然なので廃止
			if( pmuki != emuki )
			{
				//向きが不一致のときは座標もチェック
				if( pmuki == 1 && ppos.x > epos.x )
				{
					_dp(" -> <e p>");
					return 0;
				}
				if( pmuki == -1 && ppos.x < epos.x )
				{
					_dp(" -> <p e>");
					return 0;
				}
			}
			*/
		}
	}
	return 1;
}

//相殺判定を使った受け止めや、当て身判定での受け止めで呼ばれる
//return 0 すると当て身に失敗する
//受け止める側から呼ばれる
// BMvCore.GetParamCharaData(0) すると当て身でとったオブジェクトを取得できる
Std_MoveTable.CheckAttackCatch <- function()
{
	if( Def_Sys_CatchClashType == 0 )
	{
		return 1;
	}
	
	// _dm("CheckAttackCatch");
	local pmuki = BMvTbl.GetMuki();
	local ppos = BMvTbl.GetPosition();
	local p_nomals = Battle_Std.MoveCode.CheckFlag( def_MC_Atk );//通常技
	local p_spskills = Battle_Std.MoveCode.CheckFlag( def_MC_Skill ) &&  Battle_Std.MoveCode.CheckFlag( def_MC_SPAction );//超技
	local p_mvcode = BMvTbl.GetMoveCode();
	local p_cansousai_sp = Battle_Std.MoveCodeEx.CheckFlag( 5, def_MC5_CanSousaiEvenSpAction ); // SP技も当身可能
	
	
	local enemy = BMvCore.GetParamCharaData(0);//当身で取ったオブジェクト
	if( enemy.push() )
	{
		// _dm("？");
		//つよい技は弱い攻撃で相殺されないようにしたい
		//ある程度は技同士の相殺の発生しない条件と同じにしておきたい（技レベルも含め）
		
		// １．AD・LAは相殺されない
		// ２．通常技の相殺は弱く、MS、EX、無敵必殺に相殺されない

		local emuki = BMvTbl.GetMuki();
		local epos = BMvTbl.GetPosition();
		local e_nomals = Battle_Std.MoveCode.CheckFlag( def_MC_Atk );//通常技
		
		local dageki_muteki = Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_Muteki );
		local e_mvcode = BMvTbl.GetMoveCode();
		
		enemy.pop();
		
		if( p_nomals ) // 受け止める側が通常技
		{
			// 受け止める側が通常技の場合は、いくつか失敗条件がある
			// 
			
			if( e_mvcode&def_MC_Skill && dageki_muteki )
			{
				_dpn("無敵必殺技なので相殺しない");//切り返したいので反応しない
				return 0;
			}
			
			// 必殺技のタメ系にある当て身相殺が弱くなるのはあんまりよくないかもしれないので、通常技のみ
			if( e_mvcode&def_MC_Skill && ( e_mvcode&def_MC_BCAction || e_mvcode&def_MC_EXAction || e_mvcode&def_MC_SPAction ) )
			{
				_dpn("MS・EX・SPは相殺しない");//コストを払ってるから強いという感じ
				return 0;
			}
			
			if( pmuki == emuki )
			{
				//弱い通常技が背後から攻撃されているときは失敗にする
				if( p_nomals && epos.x*emuki < ppos.x*pmuki )
				{
					_dpn("受け止め側が通常技で背後からなら相殺しない　e> p>");
					return 0;
				}
			}
		}
		else if( p_spskills )
		{
			_dpn("SP技の当身は強いレベルなのでなんでも取れる");
			//アヴァロンやマシュのADのBE
			return 1;
		}
		else if( p_cansousai_sp )
		{
			_dpn("普通の当身だけどSP技も取れる特別なもの");
			//マーリオゥの22攻（当身エフェクトが異なる）
			return 1;
		}
		else // 受け止める側が必殺技以上・超技未満
		{
			// もっと細かく指定してもいいけど、わかりにくいと思われる
			if( e_mvcode&def_MC_Skill && e_mvcode&def_MC_SPAction )
			{
				_dpn("SPは相殺しない");//巨大なコストを払ってるから強いという感じ
				return 0;
			}
			return 1;
		}
		
		return 1;
	}
	
	return 1;
}

//ＫＯされた瞬間呼ばれて少しすると消滅するＭｖ
//ＫＯボイスの再生に使っている
//キャラ別に書き換えたければこれをいじろう
Std_MoveTable.Mv_KOImpact_Object <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		//LP0 : ＫＯ音声を再生したかどうか
		BMvTbl.SetLP(0,0); // 初期化
	}
	function FrameUpdate_Std()
	{
		//1F後に操作親のパターンを見て分岐
		local s = BMvTbl.GetMvStatus();
		if( BMvTbl.GetLP(0)==0 && s.MvCount>2  )
		{
			BMvTbl.SetLP(0,1);

			local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			if( p.push() )
			{
				local rs = BMvTbl.GetMvRoundStatus();
				// _dp("\n ラウンド:"+rs.Round );
				if( rs.Round != -2 ) // チュートリアル以外
				{
					local oya_s = BMvTbl.GetMvStatus();

					local bs_power = 0;
					local bs = BtlMvStd.GetBoundStatus();
					//_dpn("bs.isBound:"+bs.isBound+" bs.VecCount:"+bs.VecCount+" bs.Power:"+bs.Power)
					if( bs.isBound )
					{
						bs_power = bs.Power;
					}
					local isHizakuzure = (bs_power&def_BS_Pow_Hizakuzure);
					if( rs.isLoseRound )
					{
						local seplay = 0; // 定義してあって再生されたら1
						if( isHizakuzure )
						{
							seplay = Battle_Std.TypeSE_Play({ type="決着ＫＯ_膝崩れ" });
						}
						else
						{
							seplay = Battle_Std.TypeSE_Play({ type="決着ＫＯ_通常" });
						}
						if( seplay==0 ) Battle_Std.TypeSE_Play({ type="決着ＫＯ" });
					}
					else
					{
						local seplay = 0; // 定義してあって再生されたら1
						if( isHizakuzure )
						{
							seplay = Battle_Std.TypeSE_Play({ type="ラウンドＫＯ_膝崩れ" });
						}
						else
						{
							seplay = Battle_Std.TypeSE_Play({ type="ラウンドＫＯ_通常" });			
						}
						if( seplay==0 ) Battle_Std.TypeSE_Play({ type="ラウンドＫＯ" });
					}
				}
				p.pop();
			}
		}
		if( s.MvCount>60 ) BMvTbl.SetFinalize(0);
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_KOCamera_Object <-
{
	function IsLoseRound()
	{
		local player = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
		if( player.push() )
		{
			local rs = BMvTbl.GetMvRoundStatus();
			
			player.pop();
			
			if( rs.isLoseRound ) return 1;
		}
		return 0;
	}
	function GetParams()
	{
		local retParams = {
			actTime = 60,
			zoomPar = 1.1,
		}

		if( IsLoseRound() )
		{
			retParams.actTime = 90;
			retParams.zoomPar = 1.25;
		}
		return retParams;
	}
	function StartCamera()
	{
		local params = GetParams();
		BMvTbl.SetLP(2,0);
	}
	function StartTimeStop()
	{
		local params = GetParams();
		BMvEff.SetStopTimeAll( { time=params.actTime } );
	}
	function Init_Std()
	{
		BMvTbl.SetPattern(0);
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		
		StartCamera();
	}
	function Update_Std()
	{
		
		local mvs = BMvTbl.GetMvStatus();
		
		local frame = BMvTbl.AddLP(2,1);
		
		//時間停止は少し遅らせて、やられ音声は再生させる（ちょっと実装がいびつかも）
		if( frame==6 )
		{
			// _dpn("とまれ");
			StartTimeStop();
		}
		if( frame==7 )
		{
			// _dpn("おわり");
			BMvEff.Slowmotion_Set( { type=1, time=120, power=6666, power_minus=50 } ); //KOスローを他の登録を全消去して追加
			BMvTbl.SetFinalize(0);
			return;
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}




//skill


Std_MoveTable.Mv_DebugPause <- 
{
	function Init_Std()
	{
		/*
		//字幕と音声の違いをチェックする処理
		BMvTbl.SetPattern( 1 ); //立ちポーズに戻る
		local pos = BMvTbl.GetLP(9);
		_dpn("test");
		for( local se=pos; se<200; se++ )
		{
			// se = 133;
			_dpn("se:"+se);
			local frame = BSound.SE_GetUserParam( { type=_SeType_Player, num=se, } );//音声のフレーム数を取得
			local use_frame = ( frame != 0 )? frame : 120;

			local tag = format("battlevoice_chr%03d_%03d",BMvTbl.GetMvStatus().CharaNo,se );
			local string = sqfunc.GetExStringText( tag );
			_dp(" : "+tag );
			if( string != "*" )
			{
				Battle_Std.Play_SubtitleVoice( se, use_frame+10 );//10Fマージン
				se ++;
				BMvTbl.SetLP(9,se);
				break;
			}
		}
		return;
		*/
		
		switch( Def_Dbg_DebugButtonMode )
		{
			case 1: //ゲージ増加
			case 3: //トレモ向け
			{
				btl_debPrint2("【デバッグ】ゲージ増加");
				local exs = BCMDTbl.GetComboGauge();
				BMvEff.SetSpGauge( { value=5000, correct=0 } );
				BMvEff.Liberate_End(); //ヴェールオフ状態だったら終了する
				
				//満タンっぽかったら空にする
				if( exs==20000 || exs==40000 )
				{
					BMvEff.SetSpGauge( { value=-40000, correct=0 } );
				}
				
				BMvTbl.SetPattern( 0 ); //立ちポーズに戻る
				Battle_Std.InitVector();
				BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } );
				break;
			}
			case 2: //相手のみ時間停止
			{
				btl_debPrint2("【デバッグ】相手だけ時間停止");
				BMvEff.SetStopTime( { time=999, stopme=0 } );			
				BMvTbl.SetPattern( 0 ); //立ちポーズに戻る
				Battle_Std.InitVector();
				BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } );
				//BMvTbl.SetFinalize(0);
				break;
			}
			case 7: // ステージ確認
			{
				Battle_Std.InitVector();
				BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } );
				local pos = BMvTbl.GetPosition();
				local enemy = BMvCore.GetEnemyCharaData();
				if( enemy.push() )
				{
					BMvTbl.SetPosition( { x=pos.x, y=pos.y } );
					
					enemy.pop();
				}
				BMvTbl.SetFinalize(0);
			}
			case 8: //登場
			{
				local code = (BMvTbl.GetPlayerSide()!=0)? 101 : 100;
				BMvTbl.SetFinalize(code); // 登場
				local is_partner = (BMvCore.GetTagStatus() == 0); // パートナー側のとき
				if( is_partner )
				{
					BMvTbl.SetFinalize(1100); // 登場
				}
				break;
			}
			case 9:
			{
				//やられを確認するぞい
				BMvTbl.SetPattern(0);
				Battle_Std.InitVector();
				BMvTbl.SetMoveableFlag( { move=0, time=255, flag=_ClearFlag_ChangeMv } );
				break;
			}
			case 10:
			{
				//LAを確認する
				BMvTbl.SetPattern(1);
				BMvTbl.SetFinalize(10000); // LA
				break;
			}
			case 11: //挑発
			{
				BMvTbl.SetFinalize(115); // 挑発
				local is_partner = (BMvCore.GetTagStatus() == 0); // パートナー側のとき
				if( is_partner )
				{
					// BMvTbl.SetFinalize(1100); // 登場
				}
				break;
			}
		}
	}
	function FrameUpdate_Std()
	{
		// Eを押している間継続
		if( BMvTbl.CheckButtonHold( (1<<4) ) == 0 )
		{
			BMvTbl.SetFinalize(0);
			return;
		}
		// 押している間の処理
		if( BMvTbl.CheckStickHold( (1<<2) ) )
		{
			// EXSを空にする
			BMvEff.SetSpGauge( { value=-40000, correct=0 } );
		}
	}
	function Update_Std()
	{
		if( Def_Dbg_DebugButtonMode )
		{
		}
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [100,"Mv_StandbyCommon2P"], [101,"Mv_StandbyCommon1P"], [115,"Mv_Neutral_Appeal"], [1100,"PatMv_Neutral"], [10000,"Mv_LastArc"] ); //デフォ,[code,mv]...
	}	
}

Std_MoveTable.Mv_DebugButton_4 <-
{
	function Init_Std()
	{
		switch( Def_Dbg_DebugButtonMode )
		{
			case 1: //
			{
			
				BMvTbl.SetFinalize(0);
				break;
			}
			case 2: // 
			{
				local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
				if( enemy.push() )
				{
					BMvEff.SetSpGauge( { value=2500, correct=0 } );

					enemy.pop();
				}			
				BMvTbl.SetFinalize(0);
				break;
			}
			case 3: //
			{
				local muki = BMvTbl.GetMuki();
				BMvTbl.SetPosition( { x=-def_POS_GamenHajiX*muki, y=0 } );
				local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
				if( enemy.IsDone )
				{
					if( BMvCore.PushCharaData( enemy ) )
					{
						BMvTbl.SetPosition( { x=-def_POS_GamenHajiX*muki, y=0 } );
						BMvEff.SetSpGauge( { value=-50000, correct=0 } );
					}
					BMvCore.PopCharaData(); //
				}
				BMvTbl.SetPattern(def_PAT_AirRecovery);
				Battle_Std.InitVector();
				BMvTbl.SetVector( { y=-1000, addy=190, flags=_Vector_Normal } );
				BMvTbl.SetFinalizeCode(0);
				break;
			}
			case 6:
			{
				BMvTbl.SetFinalize(0);
				break;			
			}
			case 7:
			{
				BMvTbl.SetPosition( { x=-500, flags=_Position_ChangeMuki|_Position_Add|_Position_CaptureShift } );
				BMvTbl.SetFinalize(0);
				break;			
			}
			case 8:
			{
				BMvTbl.SetFinalize(100); // 勝利
				local is_partner = (BMvCore.GetTagStatus() == 0); // パートナー側のとき
				if( is_partner )
				{
					BMvTbl.SetFinalize(1100); // 勝利
				}
				break;
			}
		}
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [100,"Mv_RoundWinPattern"], [1100,"PatMv_RoundWinPattern"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_DebugButton_6 <-
{
	function Init_Std()
	{
		switch( Def_Dbg_DebugButtonMode )
		{
			case 1: //
			{
				BMvTbl.SetFinalize(0);
				break;
			}
			case 2: // 
			{
				{
					BMvEff.SetSpGauge( { value=2500, correct=0 } );
				}			
				BMvTbl.SetFinalize(0);
				break;
			}			case 3: //
			{
				local muki = BMvTbl.GetMuki();
				BMvTbl.SetPosition( { x=def_POS_GamenHajiX*muki, y=0 } );
				local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
				if( enemy.IsDone )
				{
					if( BMvCore.PushCharaData( enemy ) )
					{
						BMvTbl.SetPosition( { x=def_POS_GamenHajiX*muki, y=0 } );
						BMvEff.SetSpGauge( { value=-50000, correct=0 } );
					}
					BMvCore.PopCharaData(); //
				}
				BMvTbl.SetPattern(def_PAT_AirRecovery);
				Battle_Std.InitVector();
				BMvTbl.SetVector( { y=-1000, addy=190, flags=_Vector_Normal } );				
				BMvTbl.SetFinalizeCode(0);
				break;
			}
			case 6:
			{
				BMvTbl.SetFinalize(0);
				break;			
			}
			case 7:
			{
				BMvTbl.SetPosition( { x=500, flags=_Position_ChangeMuki|_Position_Add|_Position_CaptureShift } );
				BMvTbl.SetFinalize(0);
				break;			
			}
			case 8://勝利
			{
				BMvTbl.SetFinalize(100); // 勝利
				local is_partner = (BMvCore.GetTagStatus() == 0); // パートナー側のとき
				if( is_partner )
				{
					BMvTbl.SetFinalize(1100); // 勝利
				}
				break;
			}			
		}
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [100,"Mv_WinPattern"], [1100,"PatMv_WinPattern"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_DebugButton_2 <-
{
	function Init_Std()
	{
		//BMvTbl.ClearCommand();
		switch( Def_Dbg_DebugButtonMode )
		{
			case 1: //
			case 2: //
			{
				BMvTbl.SetFinalize(0);
				break;
			}
			case 2: // 
			{
				local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
				if( enemy.push() )
				{
					BMvEff.SetSpGauge( { value=-5000, correct=0 } );

					enemy.pop();
				}			
				BMvTbl.SetFinalize(0);
				break;
			}
			case 3: //
			{
				btl_debPrint2("【デバッグ】相手のゲージ増加");
				local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
				if( enemy.IsDone )
				{
					if( BMvCore.PushCharaData( enemy ) )
					{
						local exs = BCMDTbl.GetComboGauge();
						BMvEff.SetSpGauge( { value=5000, correct=0 } );
						BMvEff.Liberate_End(); //ヴェールオフ状態だったら終了する
						
						//満タンっぽかったら空にする
						if( exs==20000 || exs==40000 )
						{
							BMvEff.SetSpGauge( { value=-50000, correct=0 } );
						}
					}
					BMvCore.PopCharaData(); //
				}
				BMvTbl.SetPattern(def_PAT_AirRecovery);
				Battle_Std.InitVector();
				BMvTbl.SetVector( { y=-1000, addy=190, flags=_Vector_Normal } );				
				BMvTbl.SetFinalizeCode(0);
				break;
			}
			case 6:
			{
				BMvTbl.SetFinalize(0);
				break;			
			}
			case 8://敗北
			{
				BMvTbl.SetFinalize(512); // 敗北
				local is_partner = (BMvCore.GetTagStatus() == 0); // パートナー側のとき
				if( is_partner )
				{
					BMvTbl.SetFinalize(1512); // 敗北
				}
				break;
			}				
			case 9:
			{
				BMvTbl.SetFinalize(256); // イグジスト
				break;
			}				
		}
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_SpecialIWEXIST"], [512,"Mv_TimeupLose"], [1512,"PatMv_TimeupLose"] ); //デフォ,[code,mv]...
	}
}

	
//投げ抜け猶予＆投げ抜け失敗フレーム管理
Std_MoveTable.Mv_Obj_TechHit_FrameManager <- 
{
	function Init_Std()
	{
		//_dm("FM:投げ抜けチェックきたよ");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		//BMvTbl.SetPP( def_PP_TechHit_FrameManager, 0 ); //投げ抜けチェック
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
	}
	function Update()
	{
		local end_manage = 0;//管理終了する？
		local techman_frame = BMvTbl.GetPP( def_PP_TechHit_FrameManager );
		// 0 : 投げor投げ抜けをそもそも入れていないか、入力してからかなり経過した
		// 1〜40 : 投げ抜けを入力して何フレーム経過したか
		//def_FL_Tech					= 11;	//つかまれてからの投げ抜け猶予フレーム
		//def_FL_TechAir XXX:これもあるよ
		//def_FL_TechSenkou			= 5;		//投げコマンド入力してからの投げ抜け猶予フレーム　このフレームまでは投げ抜け		
		//def_FL_TechMiss				= 30;	//投げを入れてからの投げ抜け失敗フレーム　このフレームまでは投げ抜けミス
		local tech_move = 0;
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			//XXX:仮で投げ抜け猶予の減らない行動を定義
			if( BMvTbl.GetMvName()=="Mv_Throw_F_Dash" )
			{
				tech_move = 1;
				techman_frame = 1;//固定 0だと投げ抜け扱いにもならないので1にする(XXX:1F減るなぁ？)
			}
			player.pop();
		}
		
		// 投げ抜け失敗フレームを0にすると、ダッシュ中に投げ抜け属性がつく処理がなくなってしまう
		// MEMO:やや処理が怪しい感じもするが目立つバグはないので大きくは変えないことにする
		local wait_frame = ( def_FL_TechMiss > def_FL_TechSenkou )? def_FL_TechMiss : def_FL_TechSenkou; // 大きい方を採用
		if (techman_frame<wait_frame)
		{
			if( !tech_move )
			{
				techman_frame++;
			}
			BMvTbl.SetPP( def_PP_TechHit_FrameManager, techman_frame ); //失敗フレームになるまでは時間をしまっておこう
		}
		else
		{
			end_manage = 1; // 終了
		}
		
		if( end_manage )
		{
			BMvTbl.SetPP( def_PP_TechHit_FrameManager, 0 ); //終了
			BMvTbl.SetFinalize(0);
		}		
		// _dp1p(format("\n投げ抜け：%d",BMvTbl.GetPP( def_PP_TechHit_FrameManager ) ))
	}
	function Finalize()
	{
		//_dm("FM:ばいばい");
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		BMvTbl.SetPP( def_PP_TechHit_FrameManager, 0 ); //念の為初期化
		Battle_Std.GS_DelFlag( def_PP_GS_TechManager );
	}
}

// Std_MoveTableに特殊技関係をガーッと追加する関数
local Add_EXAtks = function( stdmv ) : (set_AirAtkLandStatus, set_AirAtk_LandMoveableFrame)
{
	//関数内関数
	local makemv_GroundEXAtk = function( param={} )
	{
		local retmv = {};
		
		local limit = param.ComboLimit;
		local pat = param.Pattern;
		local nextmv = param.NextMv;
		local movecode = param.MoveCode;
		local skilllv = param.SkillLv;
		
		retmv.Init_Std <- function() : ( limit, pat, movecode, skilllv )
		{
			Battle_Std.InitGroundAtk(); //通常攻撃共通Init
			
			if( movecode )
			{
				// 行動コード追加
				// _dp("\n 追加:"+movecode);
				Battle_Std.MoveCode.AddFlag( movecode );
			}
			Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_UniqAttack ); // 特殊技
		
			BMvTbl.SetComboLimit( limit );
			BMvTbl.SetPattern( pat );
			
			if( skilllv )
			{
				BMvTbl.SetSkillLv( skilllv );
			}
		}
		
		retmv.Start_Std <- function()
		{
			Battle_Std.StartGroundAtk();
		}

		local fu_voice = param.FUVoice;

		retmv.FrameUpdate_Std <- function() : (fu_voice)
		{
			Battle_Std.TypeSE_Play({ type=fu_voice });
			Battle_Std.Sousai.FrameUpdate();
		}
		
		retmv.HitInterrupt_Std <- function()
		{
			Battle_Std.MvRule_Atk_HitInterrupt();
			Battle_Std.Sousai.HitInterrupt( { weak=2 } );
		}	

		retmv.Finalize_Std <- function() : (nextmv)
		{
			BMvTbl.SetNextMoveTable( nextmv );
		}
		return retmv;
	}


	local makemv_AirEXAtk = function( param={} ) : (set_AirAtkLandStatus)
	{
		local retmv = {};
		
		local limit = param.ComboLimit;
		local pat = param.Pattern;
		local movecode = param.MoveCode;
		local skilllv = param.SkillLv;
		
		local airBorC = 0;
		if( "AtkLv" in param && (param.AtkLv == "B" || param.AtkLv == "C") )
		{
			airBorC = 1;
		}
		
		retmv.Init_Std <- function() : ( limit, pat, movecode, skilllv, airBorC )
		{
			Battle_Std.InitAirAtk(); //通常攻撃共通Init
			
			if( movecode )
			{
				// 行動コード追加
				// _dp("\n 追加:"+movecode);
				Battle_Std.MoveCode.AddFlag( movecode );
			}
			Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_UniqAttack ); // 特殊技

			Battle_Std.SetStatus_AirAtkStatus(); //ジャンプ攻撃の各種フラグをリセット＋立てる
		
			BMvTbl.SetComboLimit( limit );
			BMvTbl.SetPattern( pat );
			
			if( skilllv )
			{
				BMvTbl.SetSkillLv( skilllv );
			}
			
			if( Def_Sys_NoMoveAirBandCFall && airBorC )
			{
				BMvTbl.SetMoveableFlag( { move=0, time=1000, flag=_ClearFlag_ChangeMv } ); // Mv中行動不能にする
			}
		}

		retmv.Start_Std <- function()
		{
			Battle_Std.StartAirAtk();
		}		

		local fu_voice = param.FUVoice;

		retmv.FrameUpdate_Std <- function() : (set_AirAtkLandStatus, fu_voice)
		{
			Battle_Std.TypeSE_Play({ type=fu_voice });
			Battle_Std.Sousai.FrameUpdate();
			local s = BMvTbl.GetMvStatus();
			if( s.isLanding )
			{
				set_AirAtkLandStatus(); // def_PP_AirAtkStatus に着地情報を入れる
				BMvTbl.SetFinalize(9999); //着地したらLandへ
			}
		}
		
		retmv.HitInterrupt_Std <- function()
		{
			Battle_Std.MvRule_Atk_HitInterrupt();
			Battle_Std.MvRule_AirAtk_HitInterrupt();
			Battle_Std.Sousai.HitInterrupt( { weak=2, isAirAtk=1 } );
		}	

		local landmv = param.LandMv;
		retmv.Finalize_Std <- function() : ( landmv )
		{
			Battle_Std.SwitchNextMoveTable("Mv_Neutral", [9999,landmv] ); //デフォ,[code,mv]...
		}

		return retmv;
	}

	local makemv_AirEXAtkLand = function( param={} ) : (set_AirAtk_LandMoveableFrame)
	{
		local retmv = {};
		
		switch( param.AtkLv )
		{
		case "A":
			retmv.Init_Std <- function() : (set_AirAtk_LandMoveableFrame)
			{
				Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
				Battle_Std.PassBeforeMoveCodeEx( 1, def_MC1_ExtendAction ); // タメ版フラグを引き継ぐ
				
				set_AirAtk_LandMoveableFrame(			//着地硬直を設定
				def_FL_AtkAirA_LandRecovery,			//空振りした
				def_FL_AtkAirA_LandRecovery_Shielded,	//シールドされた
				def_FL_AtkAirA_LandRecovery_Damage,		//ダメージを与えた
				def_FL_AtkAirA_LandRecovery_Guard,		//ガードされた
				def_FL_AtkAirA_LandRecovery_Assault		//アサルトから出して空振りした
				def_FL_AtkAirA_LandRecovery_AssaultShielded,	//アサルトから出してシールドされた
				def_FL_AtkAirA_LandRecovery_AssaultDamage,		//アサルトから出してダメージを与えた
				def_FL_AtkAirA_LandRecovery_AssaultGuard		//アサルトから出してガードされた
				);
			}
			break;
		case "B":
			retmv.Init_Std <- function() : (set_AirAtk_LandMoveableFrame)
			{
				Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
				Battle_Std.PassBeforeMoveCodeEx( 1, def_MC1_ExtendAction ); // タメ版フラグを引き継ぐ
				
				set_AirAtk_LandMoveableFrame(			//着地硬直を設定
				def_FL_AtkAirB_LandRecovery,			//空振りした
				def_FL_AtkAirB_LandRecovery_Shielded,	//シールドされた
				def_FL_AtkAirB_LandRecovery_Damage,		//ダメージを与えた
				def_FL_AtkAirB_LandRecovery_Guard,		//ガードされた
				def_FL_AtkAirB_LandRecovery_Assault		//アサルトから出して空振りした
				def_FL_AtkAirB_LandRecovery_AssaultShielded,	//アサルトから出してシールドされた
				def_FL_AtkAirB_LandRecovery_AssaultDamage,		//アサルトから出してダメージを与えた
				def_FL_AtkAirB_LandRecovery_AssaultGuard		//アサルトから出してガードされた
				);
			}
			break;
		case "C":
			retmv.Init_Std <- function() : (set_AirAtk_LandMoveableFrame)
			{
				Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
				Battle_Std.PassBeforeMoveCodeEx( 1, def_MC1_ExtendAction ); // タメ版フラグを引き継ぐ
				
				set_AirAtk_LandMoveableFrame(			//着地硬直を設定
				def_FL_AtkAirC_LandRecovery,			//空振りした
				def_FL_AtkAirC_LandRecovery_Shielded,	//シールドされた
				def_FL_AtkAirC_LandRecovery_Damage,		//ダメージを与えた
				def_FL_AtkAirC_LandRecovery_Guard,		//ガードされた
				def_FL_AtkAirC_LandRecovery_Assault		//アサルトから出して空振りした
				def_FL_AtkAirC_LandRecovery_AssaultShielded,	//アサルトから出してシールドされた
				def_FL_AtkAirC_LandRecovery_AssaultDamage,		//アサルトから出してダメージを与えた
				def_FL_AtkAirC_LandRecovery_AssaultGuard		//アサルトから出してガードされた
				);
			}
			break;
		}
		
		retmv.Finalize_Std <- function()
		{
			BMvTbl.SetNextMoveTable( "Mv_Neutral" );
		}
		
		return retmv;
	}



	//MEMO:連打コンボは数も違うだろうしでキャラごとに定義できないとキツい
	local std_atk_list = [
		["Mv_Atk_Std6A", "6A", DEF_BS_CL_ATK6A, "Mv_Atk_Std6A_FU", "Mv_Neutral", def_MC_GRDLowBreak, def_MVSL_AtkStdExA ],
		["Mv_Atk_Std6B", "6B", DEF_BS_CL_ATK6B, "Mv_Atk_Std6B_FU", "Mv_Neutral", 0, def_MVSL_AtkStdExB ],
		["Mv_Atk_Std6C", "6C", DEF_BS_CL_ATK6C, "Mv_Atk_Std6C_FU", "Mv_Neutral", 0, def_MVSL_AtkStdExC ],
		["Mv_Atk_Std4A", "4A", DEF_BS_CL_ATK4A, "Mv_Atk_Std4A_FU", "Mv_Neutral", def_MC_GRDLowBreak, def_MVSL_AtkStdExA ],
		["Mv_Atk_Std4B", "4B", DEF_BS_CL_ATK4B, "Mv_Atk_Std4B_FU", "Mv_Neutral", 0, def_MVSL_AtkStdExB ],
		["Mv_Atk_Std4C", "4C", DEF_BS_CL_ATK4C, "Mv_Atk_Std4C_FU", "Mv_Neutral", 0, def_MVSL_AtkStdExC ],
		["Mv_Atk_Std3A", "3A", DEF_BS_CL_ATK3A, "Mv_Atk_Std3A_FU", "Mv_Neutral", def_MC_GRDLowBreak, def_MVSL_AtkStdExA ],
		["Mv_Atk_Std3B", "3B", DEF_BS_CL_ATK3B, "Mv_Atk_Std3B_FU", "Mv_Neutral", 0, def_MVSL_AtkStdExB ],
		["Mv_Atk_Std3C", "3C", DEF_BS_CL_ATK3C, "Mv_Atk_Std3C_FU", "Mv_Neutral", 0, def_MVSL_AtkStdExC ],
		["Mv_Atk_Std1A", "1A", DEF_BS_CL_ATK1A, "Mv_Atk_Std1A_FU", "Mv_Neutral", def_MC_GRDLowBreak, def_MVSL_AtkStdExA ],
		["Mv_Atk_Std1B", "1B", DEF_BS_CL_ATK1B, "Mv_Atk_Std1B_FU", "Mv_Neutral", 0, def_MVSL_AtkStdExB ],
		["Mv_Atk_Std1C", "1C", DEF_BS_CL_ATK1C, "Mv_Atk_Std1C_FU", "Mv_Neutral", 0, def_MVSL_AtkStdExC ],
		["Mv_Atk_6B_6B", "6B_6B", DEF_BS_CL_ATK6B_6B, "Mv_Atk_6B_6B_FU", "Mv_Neutral", 0, def_MVSL_AtkStdExB ],
		["Mv_Atk_A_A", "A_A", DEF_BS_CL_ATKA_A, "Mv_Atk_A_A_FU", "Mv_Neutral", def_MC_GRDLowBreak, def_MVSL_AtkStdExA ],
		["Mv_Atk_B_B", "B_B", DEF_BS_CL_ATKB_B, "Mv_Atk_B_B_FU", "Mv_Neutral", 0, def_MVSL_AtkStdExB ],
		["Mv_Atk_C_C", "C_C", DEF_BS_CL_ATKC_C, "Mv_Atk_C_C_FU", "Mv_Neutral", 0, def_MVSL_AtkStdExC ],
		
		["Mv_Atk_Cro3A", "3A", DEF_BS_CL_ATK3A, "Mv_Atk_Cro3A_FU", "Mv_Crouch_Wait", def_MC_GRDLowBreak, def_MVSL_AtkCroExA ],
		["Mv_Atk_Cro3B", "3B", DEF_BS_CL_ATK3B, "Mv_Atk_Cro3B_FU", "Mv_Crouch_Wait", 0, def_MVSL_AtkCroExB ],
		["Mv_Atk_Cro3C", "3C", DEF_BS_CL_ATK3C, "Mv_Atk_Cro3C_FU", "Mv_Crouch_Wait", 0, def_MVSL_AtkStdExC ],
		["Mv_Atk_Cro1A", "1A", DEF_BS_CL_ATK1A, "Mv_Atk_Cro1A_FU", "Mv_Crouch_Wait", def_MC_GRDLowBreak, def_MVSL_AtkCroExA ],
		["Mv_Atk_Cro1B", "1B", DEF_BS_CL_ATK1B, "Mv_Atk_Cro1B_FU", "Mv_Crouch_Wait", 0, def_MVSL_AtkCroExB ],
		["Mv_Atk_Cro1C", "1C", DEF_BS_CL_ATK1C, "Mv_Atk_Cro1C_FU", "Mv_Crouch_Wait", 0, def_MVSL_AtkStdExC ],
		["Mv_Atk_2A_2A", "2A_2A", DEF_BS_CL_ATK2A_2A, "Mv_Atk_2A_2A_FU", "Mv_Crouch_Wait", def_MC_GRDLowBreak, def_MVSL_AtkCroExA ],
		["Mv_Atk_2B_2B", "2B_2B", DEF_BS_CL_ATK2B_2B, "Mv_Atk_2B_2B_FU", "Mv_Crouch_Wait", 0, def_MVSL_AtkCroExB ],
		["Mv_Atk_2C_2C", "2C_2C", DEF_BS_CL_ATK2C_2C, "Mv_Atk_2C_2C_FU", "Mv_Neutral", 0, def_MVSL_AtkStdExC ],
	];
	
	for( local i=0; i<std_atk_list.len(); i++ )
	{
		local param = std_atk_list[i];
		local mv = param[0];
		local pat = param[1];
		local limit = param[2];
		local fu_se = param[3];
		local nextmv = param[4];
		local movecode = param[5];
		local skilllv = param[6];
		
		stdmv[mv] <- makemv_GroundEXAtk( { ComboLimit=limit, Pattern=pat, FUVoice=fu_se, NextMv=nextmv, MoveCode=movecode, SkillLv=skilllv } );
	}
	
	/*
	local cro_atk_list = [
		["Mv_Atk_Cro6A", "6A", DEF_BS_CL_ATK6A, "Mv_Atk_Std6A_FU" ],
		
	];

	for( local i=0; i<cro_atk_list.len(); i++ )
	{
		local param = cro_atk_list[i];
		local mv = param[0];
		local pat = param[1];
		local limit = param[2];
		local fu_se = param[3];
		
		stdmv[mv] <- makemv_CroEXAtk( { ComboLimit=limit, Pattern=pat, FUVoice=fu_se } );
	}
	*/

	local air_atk_list = [
		["Mv_Atk_Air2A", "J2A", DEF_BS_CL_ATKJ2A, "Mv_Atk_Air2A_FU", "A", "Mv_Atk_Air2A_Land", def_MC_GRDLowBreak, def_MVSL_AtkAirExA ],
		["Mv_Atk_Air2B", "J2B", DEF_BS_CL_ATKJ2B, "Mv_Atk_Air2B_FU", "B", "Mv_Atk_Air2B_Land", 0, def_MVSL_AtkAirExB ],
		["Mv_Atk_Air2C", "J2C", DEF_BS_CL_ATKJ2C, "Mv_Atk_Air2C_FU", "C", "Mv_Atk_Air2C_Land", 0, def_MVSL_AtkAirExC ],
		["Mv_Atk_Air4A", "J4A", DEF_BS_CL_ATKJ4A, "Mv_Atk_Air4A_FU", "A", "Mv_Atk_Air4A_Land", def_MC_GRDLowBreak, def_MVSL_AtkAirExA ],
		["Mv_Atk_Air4B", "J4B", DEF_BS_CL_ATKJ4B, "Mv_Atk_Air4B_FU", "B", "Mv_Atk_Air4B_Land", 0, def_MVSL_AtkAirExB ],
		["Mv_Atk_Air4C", "J4C", DEF_BS_CL_ATKJ4C, "Mv_Atk_Air4C_FU", "C", "Mv_Atk_Air4C_Land", 0, def_MVSL_AtkAirExC ],
		["Mv_Atk_Air6A", "J6A", DEF_BS_CL_ATKJ6A, "Mv_Atk_Air6A_FU", "A", "Mv_Atk_Air6A_Land", def_MC_GRDLowBreak, def_MVSL_AtkAirExA ],
		["Mv_Atk_Air6B", "J6B", DEF_BS_CL_ATKJ6B, "Mv_Atk_Air6B_FU", "B", "Mv_Atk_Air6B_Land", 0, def_MVSL_AtkAirExB ],
		["Mv_Atk_Air6C", "J6C", DEF_BS_CL_ATKJ6C, "Mv_Atk_Air6C_FU", "C", "Mv_Atk_Air6C_Land", 0, def_MVSL_AtkAirExC ],
		["Mv_Atk_JA_JA", "JA_JA", DEF_BS_CL_ATKJA_JA, "Mv_Atk_JA_JA_FU", "A", "Mv_Atk_JA_JA_Land", def_MC_GRDLowBreak, def_MVSL_AtkAirExA ],
		["Mv_Atk_JB_JB", "JB_JB", DEF_BS_CL_ATKJB_JB, "Mv_Atk_JB_JB_FU", "B", "Mv_Atk_JB_JB_Land", 0, def_MVSL_AtkAirExB ],
		["Mv_Atk_JC_JC", "JC_JC", DEF_BS_CL_ATKJC_JC, "Mv_Atk_JC_JC_FU", "C", "Mv_Atk_JC_JC_Land", 0, def_MVSL_AtkAirExC ],
	];

	
	for( local i=0; i<air_atk_list.len(); i++ )
	{
		local param = air_atk_list[i];
		local mv = param[0];
		local pat = param[1];
		local limit = param[2];
		local fu_se = param[3];
		local land_lv = param[4];
		local land_mv = param[5];
		local movecode = param[6];
		local skilllv = param[7];//2022/1/25設定ミス修正
		
		stdmv[mv] <- makemv_AirEXAtk( { ComboLimit=limit, Pattern=pat, FUVoice=fu_se, LandMv=land_mv, MoveCode=movecode, SkillLv=skilllv } );
		if( land_mv in stdmv )
		{
			// 既にあるのでスキップ
		}
		else
		{
			stdmv[land_mv] <- makemv_AirEXAtkLand( { AtkLv=land_lv } );
		}
	}
}

Add_EXAtks( Std_MoveTable );

// Std_MoveTable.Mv_Null_AddTimingChecker <- makemv_AddAtkTimingChecker();


Std_MoveTable.Mv_Null_AirRapidThrowCheck <-
{
	function Init_Std()
	{
		// _dpn("Mv_Null_AirRapidThrowCheck Init");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		
		// BMvTbl.SetLP(0,0); // 何フレーム後に消えるか（生成時に指定）
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount > 30 || mvs.MvCount > BMvTbl.GetLP(0) )
		{
			// _dpn("消滅");
			BMvTbl.SetFinalize();
			return;
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		// _dpn("Mv_Null_AirRapidThrowCheck End");
		Battle_Std.GS_DelFlag( def_PP_GS_AirRapidThrowCheck );
	}
}

//空中投げ
Std_MoveTable.Mv_Throw_A <- 
{
	function Init_Std()
	{
		BMvTbl.SetPattern( def_PAT_Throw_A );
		BMvTbl.ClearHitStatus();
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_EnableTech );//投げ抜け可能な行動
		Battle_Std.MoveCode.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		Battle_Std.InitAtkSkillMv(); // 通常技や必殺技の共通初期化
		BMvTbl.SetCounterHitFlag( { val=1, time=254, flag=_ClearFlag_ChangeMv } );//カウンター
		
		Battle_Std.SetNoMovableMove(); // 動けないMV
		Battle_Std.MoveCode.AddFlag( def_MC_GRDBreak_FatalDmgHosei ); // 行動コード(GRDブレイクで攻撃力アップ)を設定
		
		// コンボレート加算
		// 地上版にはない。地上版につけると連キャンの当て投げが安くなる
		// if( !Def_Sys_ComboRateSetStartTiming ) BMvTbl.AddComboRate(); // コンボレート加算　※発生が早すぎるのでダメ。ズラし押しもないしこのまま
		BMvTbl.AddComboRate(); // コンボレート加算
		
		// 空中浮遊しないようにベクトル設定
		local vec = BMvTbl.GetVector( { flags=_Vector_Normal } );
		if( vec.addy < 190 )
		{
			BMvTbl.SetVector( { addy=190, flags=_Vector_Normal } );
		}
		
		BMvTbl.SetLP(1,0); //投げ音声再生済み
		
		//分岐先をキャッシュに乗せる
		BMvCore.CallEntryBCCachePreTransfer( { pat=BMvEff.GetPatternNum( { datatype=0, pat=def_PAT_Throw_A_TechWait } ), frame=0, rest=2 } ); // 投げつかみ分岐先予約		
		BMvCore.CallEntryBCCachePreTransfer( { pat=BMvEff.GetPatternNum( { datatype=0, pat=def_PAT_Throw_A_Hit } ), frame=0, rest=6 } ); // 投げ成立先予約
		
		//救済措置:落下ベクトルが無いということが想定されていない技
		//同時押し関係の処理の見直し（空中必殺技から空中投げが出ていること自体がおかしい）
		local vec = BMvTbl.GetVector( { flags=_Vector_Normal } );
		if( vec.addy < 200 )
		{
			BMvTbl.SetVector( { addy=200, flags=_Vector_Normal } ); // 最低重力
		}
		
		Battle_Std.CharaBattleActivity_Increment(125,"空中投げ使用");
		
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_TechCheck );//投げ抜けされる技
		Battle_Std.GS_DelFlag( def_PP_GS_AtkToNoAddDamageMoon ); // 被弾で月が増えない行動への攻撃かどうかの記憶を初期化
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			BMvTbl.SetFinalize(500); //着地したらLandへ
		}
		
		if( s.MvCount>=3 && (BMvTbl.GetLP(1)==0) ) //投げ失敗確定後＆フラグがたっていない
		{
			BMvTbl.SetLP(1,1); //再生済み
			Battle_Std.TypeSE_Play({ type="投げスカり" });
			Battle_Std.MoveCodeEx.DelFlag( 7, def_MC7_EnableTech );
			
			BMvTbl.SetCounterHitFlag( { val=0, time=254, flag=_ClearFlag_ChangeMv } );//カウンターなし
		}
	}
	function HitInterrupt_Std()
	{
		local isComboNage = 0;
		local isNoAddDamageMoonMv = 0;
		local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
		if( enemy.push() )
		{
			local bs = BtlMvStd.GetBoundStatus();
			isComboNage = ( bs.isBound && bs.isBound != 2 );
			isNoAddDamageMoonMv = Battle_Std.MoveCodeEx.CheckFlag( 4, def_MC4_NoAddDamageMoon );
			
			enemy.pop();
		}
		
		local tukami_success = 0;
		if( isComboNage ) //BM掴みかどうか
		{
			tukami_success = Battle_Std.SetThrowHitFinalize(200); // ヒット分岐ファイナライズ		
		}
		else
		{
			tukami_success = Battle_Std.SetThrowHitFinalize(100); // ヒット分岐ファイナライズ
		}
		
		if( tukami_success )
		{
			if( isNoAddDamageMoonMv )
			{
				Battle_Std.GS_AddFlag( def_PP_GS_AtkToNoAddDamageMoon );
			}
		}
	}	
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [100,"Mv_Throw_A_TechWait"], [200,"Mv_Throw_A_ComboWait"], [500,"Mv_Throw_A_Land"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
	}
}

Std_MoveTable.Mv_Throw_A_Land <-
{
	function Init_Std()
	{
		Battle_Std.InitCharaVector();

		//着地硬直
		BMvTbl.SetMoveableFlagEx( { move=0, timeA=12, timeB=64, flag=_ClearFlag_ChangeMv } );
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
	}
	function Finalize()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

Std_MoveTable.Mv_Throw_A_TechWait <- //つかんでから投げ抜けを待つまで〜分岐
{	
	function Init_Std()
	{	
		Battle_Std.InitVector(); // ベクトル初期化
		Battle_Std.MoveCode.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		Battle_Std.ThrowTech.SetMuteki(); //つかみ中は自分も相手も無敵にする	
		Battle_Std.PlayerSE_StopLastPlaySound( 1 ); //直前に再生した音声を停止
		
		//前の行動のつかみ時の状況をチェック
		Battle_Std.PassBeforeMoveCodeEx( 7, def_MC7_EnemyTechImpossible )
		if( Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_EnemyTechImpossible ) )
		{
			BMvTbl.SetFinalize(512); //投げ抜けできないフレーム中なので終わろう
		}
		else //投げぬけ失敗フレームではない投げ
		{
			Battle_Std.EnemyCharaBattleActivity_Increment(136,"空中投げでつかまれた回数");

			//掴んだ相手側に投げられ回数を加算
			local enemy = BMvCore.GetCaptureCharaData();
			if( enemy.push() )
			{
				BMvEff.AddSkillCount( _SkillCount_Throw ); // 履歴カウンタを加算
				
				enemy.pop();
			}
			BMvEff.ThrowChara_SetCamera( 1 ); //投げているキャラをカメラ処理に含める
		}
		
		Battle_Std.ThrowTech.SetPos(); //つかむ前の自分と相手の座標を記憶する
		
		BMvTbl.SetPattern(def_PAT_Throw_A_TechWait); //投げ抜け待機パターンに変更(ここで相手はのけぞる)
		
		Battle_Std.ThrowTech.SetThrowParam(); //エフェクト座標に相手をやられ絵でセット
		
		//相手のけぞってからの処理
		Battle_Std.ThrowTech.ShiftOverGamenHajiX(); //相手が画面外にいたら自分の座標ごと補正をかける	
		Battle_Std.ThrowTech.DrawThrowEffect(0); //ヒット座標につかみエフェクト表示
		
		Battle_Std.PassHitMoveCodes(); // ヒット分岐でのMvCode引継ぎ
		Battle_Std.SetNoMovableMove(); // 動けないMV
	}
	function Update_Std() //投げぬけ猶予中
	{

		local s = BMvTbl.GetMvStatus(); // ステータス取得
		//print("\nTh1:Frame:"+s.FrameID);
		if( s.MvCount>def_FL_TechAir )
		{
			BMvTbl.SetFinalize(0); //投げ抜け猶予が終わったので終わる
			return;
		}
		
		if ( Battle_Std.ThrowTech.CheckTechCommand() ) //相手が投げ抜けコマンドを入れた
		{
			Battle_Std.ThrowTech.DrawTechEffect(); //投げ抜け演出を表示
			Battle_Std.ThrowTech.TechRelease(1); //投げ抜けされた時の開放処理
			BMvTbl.SetFinalize(256);
		}
	}
	function Finalize_Std() // 
	{
		local fin_code = BMvTbl.GetFinalizeCode();
		if( fin_code != 256 )
		{
			Battle_Std.CharaBattleActivity_Increment(126,"空中投げ成功");
			//投げ成功回数/(投げ成功回数+投げ失敗回数)
			Battle_Std.CharaBattleActivity_Calc( {
				title="空中投げ成功確率", 
				molecule=Battle_Std.CharaBattleActivity_Count("空中投げ成功"), denominator=(Battle_Std.CharaBattleActivity_Count("空中投げ成功")+Battle_Std.CharaBattleActivity_Count("空中投げ失敗"))
			} );
		}
		Battle_Std.SwitchNextMoveTable("Mv_Throw_A_Hit", [256,"Mv_Teched_Air"],[512,"Mv_Throw_A_TechMissWait"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );	
		BMvEff.ThrowChara_SetCamera( 0 ); //投げているキャラをカメラ処理に含めない
	}
}

// 投げ抜け不能フレームの時　と　行動不能を単純に掴んだ時 がある
Std_MoveTable.Mv_Throw_A_TechMissWait <- //投げ抜けされないつかみの時
{	
	function Init_Std()
	{
		Battle_Std.TypeSE_Play({ type="投げ抜けされないつかみ成功" });
		
		Battle_Std.MoveCode.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定

		local enemy = BMvCore.GetNearEnemyCharaData();
		if( enemy.push() )
		{
			Battle_Std.TypeSE_Play({ type="ガード失敗" });
			Battle_Std.SoundStatus_AddFlag( def_PP_SS_NoBoundVoiceOnce ); // 次のやられ音声を再生しない

			enemy.pop();
		}
		
		Battle_Std.ThrowTech.SetMuteki(); //つかみ中は自分も相手も無敵にする	
		
		Battle_Std.PassHitMoveCodes(); // ヒット分岐でのMvCode引継ぎ
		Battle_Std.SetNoMovableMove(); // 動けないMV
	}
	function Update_Std() //投げぬけ猶予中
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		//すぐ投げるとわかりにくいのでdef_FL_BoundTech分まつ
		if( s.MvCount>def_FL_BoundTech ) BMvTbl.SetFinalize(0); //投げ抜け猶予が終わったので終わる
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Throw_A_Hit", [256,"Mv_Teched_Air"] ); //デフォ,[code,mv]...
	}	
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
	}	
}

Std_MoveTable.Mv_Throw_A_ComboWait <- //つかんでからヒットにいくまで
{	
	function Init_Std()
	{	
		Battle_Std.InitVector(); // ベクトル初期化
		Battle_Std.MoveCode.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		Battle_Std.ThrowTech.SetMuteki(); //つかみ中は自分も相手も無敵にする	
		Battle_Std.PlayerSE_StopLastPlaySound( 1 ); //直前に再生した音声を停止
		
		Battle_Std.ThrowTech.SetPos(); //つかむ前の自分と相手の座標を記憶する
		
		BMvTbl.SetPattern(def_PAT_Throw_A_TechWait); //投げ抜け待機パターンに変更(ここで相手はのけぞる)
		
		Battle_Std.ThrowTech.SetThrowParam(); //エフェクト座標に相手をやられ絵でセット
		
		//相手のけぞってからの処理
		Battle_Std.ThrowTech.ShiftOverGamenHajiX(); //相手が画面外にいたら自分の座標ごと補正をかける	
		Battle_Std.ThrowTech.DrawThrowEffect(0); //ヒット座標につかみエフェクト表示
		
		Battle_Std.PassHitMoveCodes(); // ヒット分岐でのMvCode引継ぎ
		Battle_Std.SetNoMovableMove(); // 動けないMV
	}
	function Update_Std() //投げぬけ猶予中
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( s.MvCount>4 ) BMvTbl.SetFinalize(0); //投げ抜け猶予（10F程度）とかは見ないですぐに進む
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Throw_A_Hit"); //デフォ,[code,mv]...
	}
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );	
		BMvEff.ThrowChara_SetCamera( 0 ); //投げているキャラをカメラ処理に含めない
	}
}

Std_MoveTable.Mv_Throw_A_Hit <- 
{
	function Init_Std() // 
	{
		//逆投げだったらここで反転
		if( BMvTbl.GetPP(def_PP_TechReverse) == 1 ) BMvTbl.SetMuki(_Direction_Reverse);	//逆投げなんで反転		
		Battle_Std.InitVector(); //慣性削除		

		//反転後にパターン設定
		BMvTbl.SetPattern( def_PAT_Throw_A_Hit );
		
		Battle_Std.PassHitMoveCodes(); // ヒット分岐でのMvCode引継ぎ
		// Battle_Std.SetNoMovableMove(); // 動けないMV
		
		local isSidou = Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_SidouHitSkill );
		local isFatal = Battle_Std.EnemyDamageFlag_Check( def_DF_FatalCounter );
		local noAddDamageMoon = Battle_Std.GS_CheckFlag( def_PP_GS_AtkToNoAddDamageMoon );
		Battle_Std.GS_DelFlag( def_PP_GS_AtkToNoAddDamageMoon );//使ったので初期化
		local enemy = BMvCore.GetCaptureCharaData();
		if( enemy.push() )
		{
			BMvTbl.SetCaptureHitFlag( { val=_CaptureHitFlag_Parent, time=255, flag=_ClearFlag_ChangeMv } );
			
			if( isSidou && !isFatal && !noAddDamageMoon )
			{
				Battle_Std.Moon_AddValue(Def_DamageInitMoonAdd);//やられ初段でのボーナス
			}
			enemy.pop();
		}
		if( isSidou )
		{
			Battle_Std.Moon_AddValue(Def_AttackDamageInitMoonAdd,1);//攻撃初段でのボーナス（パートナー側からの呼び出しも有効）
			if( isFatal )
			{
				Battle_Std.Moon_AddValue(Def_FatalAttackDamageInitMoonAdd,1);//フェイタルのボーナス（パートナー側からの呼び出しも有効）
				
				if( Def_Sys_FatalHoseiBonus )
				{
					BMvEff.ComboView_Set( { val=def_HOSEI_FatalCounterThrow, type=1 } ); // 乗算
				}
			}
		}
		
		BMvEff.SetPlayerTimer( { muteki_nage=1000, muteki_dage=1000, muteki_dageX=1000, muteki_nageX=1000 } );
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="空中投げ成功" });
	}
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable("Mv_Neutral");
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0 } );

		//TODO:エラー回避、もうちょい色々なところに入れたほうがいい気はする
		BMvEff.ThrowRelease( { type=12 } );//エラー回避
		
		if( !Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_GenFlag ) )//LastUpdateの追撃不能を消す
		{
			//そもそも基本的に追撃不能にする
			//MEMO:追撃不能にしたくなかったらなんかする？
			//MEMO:ムーンドライブでのみ追撃可能とか？
			Battle_Std.NoCansel_NoAttackHit();
		}
	}
}

// 同時押しダッシュで生成される
// 
Std_MoveTable.Mv_DoujiDash_F_HoldCheckObject <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround|_ObjFlags_ParentMove } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } ); //隠す
		
		BMvTbl.SetLP(0,0); // ボタンを離したかどうか
		BMvTbl.SetLP(1,0); // ボタンを離したあと何フレーム経過したか。これが2になるとオブジェクトが消滅する。（lastdelay対策）
		// 6+A+B → 1Fでニュートラル →　とすると、このオブジェクトが消えて技制限が消えるが、6+A+Bのキーは残っているのでlastdelayで受け付けているものがあると出てた
	}
	function Update_Std()
	{
		if( BMvTbl.GetLP(0) == 1 ) // ボタンを離した
		{
			local frame = BMvTbl.AddLP(1,1); // 経過したフレームを記憶
			//_dp("\n frame:"+frame);
			if( frame >= 2+2 ) // lastdelayが2F増えたので対応
			{
				BMvTbl.SetFinalize(0);
			}
		}
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();
		
		local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		if( player.push() )
		{
			local button_release = (BMvTbl.CheckButtonHold( (1<<0)|(1<<1) ) == 0)? 1 : 0;
			player.pop();

			if( s.MvCount>6+2 ) // lastdelayが2F増えたので対応
			{
				BMvTbl.SetFinalize(0); //長すぎ
			}
			if( button_release )
			{
				BMvTbl.SetLP(0,1); // ボタンを離したことを記憶
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		BMvTbl.SetPP(def_PP_CmdStatus, BMvTbl.GetPP(def_PP_CmdStatus)&~def_PP_CS_DoujiDash_F ); //フラグを消す
	}
}


//受け身開始で共通やること
local recover_init = function()
{
	if( Battle_Std.RoundisEnd() == false ) // 決着ついた後はボイスを無くす
	{
		Battle_Std.TypeSE_Play({ type="受け身" });
		
		//自分の残り体力とコンボダメージのバランスを見て重症か軽症かのボイスを判断する？
		//体力が少ない＝重症
		//高いダメージを受ける＝重症
		//MEMO:それ用の関数を作成して、起き上がり及び受け身のボイス分岐に使うのがよさそう

		/*
		local combo_damage = 0;
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			combo_damage = BMvTbl.GetComboInfo(1); // ダメージ
			enemy.pop();
			_dpn("★コンボダメージ:"+combo_damage );
		}
		if( combo_damage <= 2000 )
		{
			if( Battle_Std.TypeSE_Play({ type="受け身_軽" })==1 )
			{
			}
			else
			{
				_dpn("軽未定義");
				Battle_Std.TypeSE_Play({ type="受け身" })
			}
		}
		else 
		{
			Battle_Std.TypeSE_Play({ type="受け身" })
		}
		*/
	}
	BMvEff.CreateObject( { mvname="Mv_RecoverInitObject_Mask" } ); //121015追加
	
	Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定
	
	if( _isDebugModeExe )
	{
		local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る

		if( BMvCore.PushCharaData( p ) )
		{
			BMvEff.CreateObject( { mvname="Mv_Obj_RecoverLateCombo", datatype=1, start_pat=999 } );	
		}
		BMvCore.PopCharaData(); //
	}
	
	BMvEff.AttackInfoString_Set({ word=def_AISW_Recover,} );
}

//Mv_RecoverInitObjectの将来的にはこっちに統一したい版
//全てのボタンをチェックする、各ボタンごとにクールタイムがある
Std_MoveTable.Mv_RecoverInitObject_Mask <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround|_ObjFlags_ParentMove } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } ); //隠す
		
		//入ってきたときに押しっぱなしにしていたボタンをチェックして
		//ボタン開放したらクールタイムセットして
		//なくなったら消滅
		//バティスタのボタンおしっぱなし離しの技が受け身のボタンで出ないようにするための処理
		
		BMvTbl.SetPP(def_PP_RecoverHoldMask,0);
		
		local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る

		local button = 0;
		if( player.push() )
		{
			for( local i=0; i<=3; i++ )
			{
				if( BMvTbl.CheckButtonHold( (1<<i) ) )
				{
					button = button|(1<<i);
				}
			}
			player.pop();
		}
		
		BMvTbl.SetPP(def_PP_RecoverHoldMask,button);
		
		// 入ってきたときに押しっぱなしのボタンをPPに記憶
		// 離されたらPPを更新
		
		BMvTbl.SetLP(0,0); //Aボタンのクールタイムとか LP>1:クールタイム中
		BMvTbl.SetLP(1,0); //Bボタンのクールタイムとか LP>1:クールタイム中
		BMvTbl.SetLP(2,0); //Cボタンのクールタイムとか LP>1:クールタイム中
		BMvTbl.SetLP(3,0); //Dボタンのクールタイムとか LP>1:クールタイム中

		BMvTbl.SetLP(9,-1); //受身行動終了時のMvCount
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();
		
		local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		local is_recover_mv = 0;
		//local button = BMvTbl.GetLP(0);
		local checkbutton = 0;
		for( local i=0; i<=3; i++ )
		{
			if( (BMvTbl.GetPP(def_PP_RecoverHoldMask)&(1<<i)) !=0 ) //最初に押してたやつかどうか
			{
				if( player.push() )
				{
					is_recover_mv = Battle_Std.MoveCode.CheckFlag( def_MC_Recovery );
					checkbutton = BMvTbl.CheckButtonHold( (1<<i) );
					
					player.pop();
				}
				
				if( checkbutton==0 && BMvTbl.GetLP(i)==0 ) //ボタン離してた
				{
					BMvTbl.SetLP(i,16); // 離したら10を入れる
					//print("\n 離した:"+i)
				}
				if( BMvTbl.GetLP(i)>0 ) //無条件でLPに値があったら減らしていく
				{
					if( BMvTbl.GetLP(i)<=1 ) //減りきったら
					{
						BMvTbl.SetPP(def_PP_RecoverHoldMask,( BMvTbl.GetPP(def_PP_RecoverHoldMask)&~(1<<i)) );	 //フラグを消す
						//print("\n 終了:"+i);
					}
					else
					{
						//print("\n 減らす:"+i);
						BMvTbl.AddLP(i,-1); //減らしていく					
					}
				}
			}
		}
		
		//print("\nret:"+ret+" button:"+button);
		if( BMvTbl.GetPP(def_PP_RecoverHoldMask)==0 )
		{
			//print("\n全部離した");
			BMvTbl.SetFinalize(0); //消える
		}
		
		// _dpn("is_recover_mv:"+is_recover_mv);
		local recover_st = BMvTbl.GetLP(9);//-1:受身行動中 0〜:別の行動に入ったときのMvCount
		if( !is_recover_mv )
		{
			if( recover_st == -1 )
			{
				BMvTbl.SetLP(9,s.MvCount); //受身行動終了時のMvCountを記憶
			}
		}
		if( recover_st != -1 )
		{
			local after_recover_f = s.MvCount - recover_st;
			// _dpn("after_recover_f:"+after_recover_f);
			if( after_recover_f > 20 )
			{
				BMvTbl.SetFinalize(0);
			}
		}

		if( s.MvCount>120 ) BMvTbl.SetFinalize(0); //長すぎ(120Fに変更)
	}
	function Finalize_Std()
	{
		//_dm("さよなら");
		BMvTbl.SetPP(def_PP_RecoverHoldMask,0);		
		BMvTbl.SetDeleteMoveTable();
	}
}

//あと何フレはやければ追撃されそうだったのか測定するだけ
//最大10F
Std_MoveTable.Mv_Obj_RecoverLateCombo <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=0, flags=_Position_CaptureShift } );

	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();

		//これいじょう長く測定しても調整には影響しねぇべ
		if( s.MvCount>10 )
		{
			BMvTbl.SetFinalize(0);
			return;
		}
		
		local e = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
		if( e.IsDone )
		{
			BMvCore.PushCharaData( e ); //	
				local e_pc = BMvEff.CheckHantei( { src=[ _Hantei_Attack, 0, -1 ], dst=[ _Hantei_Kurai, 0, -1 ], flags=_HC_FavourPc   } );
				local e_obj = BMvEff.CheckHantei( { src=[ _Hantei_Attack, 0, -1 ], dst=[ _Hantei_Kurai, 0, -1 ], flags=_HC_FavourObj   } );
			BMvCore.PopCharaData(); //
			
			if( e_pc.IsDone || e_obj.IsDone )
			{
				local frame = s.MvCount + 1;
				if( Def_Dbg_ComboChanceLog )
				{
					if( e.push() )
					{
						_dp1p(format("\nあと%dF早ければ追撃可かも",frame));
						
						e.pop();
					}
				}
				BMvTbl.SetFinalize(0);
				return;			
			}
			
		}
		else
		{
			BMvTbl.SetFinalize(0);
			return;			
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

local pat_num_Eff_Ukemi = BMvEff.GetPatternNum( { datatype=1, pat="Eff_Ukemi" } );

// 空中受け身分岐
// 空中受身
Std_MoveTable.Mv_Recover <- 
{
	//RecoverMv = 1, //受け身のMvである
	function Init() : (recover_init, pat_num_Eff_Ukemi) // 
	{
		local rst = BMvTbl.GetRecoverStatus(); // 受け身ステータスの取得
		BMvTbl.SetMuki( _Direction_Auto ); //見た目を変更（ベクトル入れる前に変更してもＯＫになった）
		
		local check_rst = rst.Type; //判定に使う受身ステータス
		//rst.Type 受け身入力時のレバー方向　※相手依存になった
		//0:ニュートラル
		//1:前
		//2:後ろ
		//3:下
		
		if( check_rst == 3 ) check_rst = 0; //下受け身を廃止・ニュートラル受け身に書き換える
		BMvTbl.SetPattern( def_PAT_AirRecovery ); //行動不能にする
		
		local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
		if( rc.sx != _Hantei_Error ) // 存在するか
		{
			local eff = BMvEff.CreateObject( { x=rc.sx, y=rc.sy, mvname="", datatype=1, start_pat=pat_num_Eff_Ukemi, flags=_Position_ToolShift } );
			if( eff.push() )
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
				eff.pop();
			}
		}			
		//btl_debPrint( format( "\nMv_Recover::Init :%d", rst.Type ) );
		
		if( Def_Rule_AirRecover_ClearAirJumpCount ) // 受け身時に二段ジャンプの回数をリセットする
		{
			BMvTbl.AddAirJumpCount( -10 ); // 0回以下にはならないので多めに引く
		}
		if( Def_Rule_AirRecover_ClearAirDashCount ) // 空中受け身時に空中ダッシュの回数をリセットする
		{
			BMvTbl.AddAirCount( def_ACS_AirDash, -10 );
			BMvTbl.AddAirCount( def_ACS_AirBackDash, -10 );
			BMvTbl.AddAirCount( def_ACS_AllAirDash, -10 );
		}
		
		recover_init(); //受け身処理
		Battle_Std.SetCharaFlash_Ukemi(); //受身で光る		
		
		BMvTbl.SetFinalize(check_rst);
	}
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Recover_N",[1,"Mv_Recover_F"], [2,"Mv_Recover_B"] ); //デフォ,[code,mv]...
	}
}// 

Std_MoveTable.Mv_RecoverBarrier <- 
{
	function Init()
	{
		BMvTbl.SetLP(0,0); // 消える命令入ったかどうか
	}
	function FrameUpdate()
	{
		if( BMvTbl.GetLP(0) == 0 )
		{
			// オブジェクト側から呼び出し
			if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) != 0 )
			{
				// プレイヤーが自分自身発生させた行動中
			}
			else
			{
				// プレイヤーが自分自身発生させた行動中でない
				BMvTbl.SetLP(0,1);
				BMvTbl.JumpFrameID(900); // 消えるアニメへ
			}
		}
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

local pat_num_RecoverBarrier = BMvEff.GetPatternNum( { datatype=1, pat="RecoverBarrier" } ); // パターン文字列のパターン番号を事前取得
local pat_num_Eff_GroundUkemi = BMvEff.GetPatternNum( { datatype=1, pat="Eff_GroundUkemi" } ); // パターン文字列のパターン番号を事前取得

//空中受け身Ｍｖ作成
local makemv_recover = function( type=0 /* 0:ニュートラル 1:前 2:後ろ */, landmv="Mv_RecoverLand_N") : (pat_num_RecoverBarrier, pat_num_Eff_Ukemi, pat_num_Eff_GroundUkemi)
{
	local ret_tmpl = {};
	
	local param = 
	{
		vec = { x=-500, y=-3500, addx=0, addy=200 },
		muteki = 254,
		type = 0, //0:空中 1:地上
		kasanari_modosi = 0, // 何フレーム目から重なりを戻すか
	}
	
	switch( type ) /* 0:ニュートラル 1:前 2:後ろ */
	{
		case 0: //ニュートラル
			param.vec.x = -500;
			param.vec.y = -2000;//少し低く
			param.muteki = (Def_Sys_AirRecoverLimitMuteki)? 24 : def_FL_N_RecoverMuteki;
			break;
		case 1: //前
			param.vec.x = 1800;
			param.muteki = (Def_Sys_AirRecoverLimitMuteki)? 24 : def_FL_F_RecoverMuteki;
			break;
		case 2: //後ろ
			param.vec.x = -1800;
			param.muteki = (Def_Sys_AirRecoverLimitMuteki)? 24 : def_FL_B_RecoverMuteki;
			break;
		case 10: //地上（ニュートラル） 21F
			param.vec.x = -500;
			param.vec.y = -2000;
			param.muteki = 999;
			param.type = 1;
			param.kasanari_modosi = 17;
			break;
		case 11: //地上（前） 26F
			param.vec.x = 2500;
			param.vec.y = -2500;
			param.muteki = 999;
			param.type = 1;
			param.kasanari_modosi = 22;
			break;
		case 12: //地上（後ろ） 26F
			param.vec.x = -2500;
			param.vec.y = -2500;
			param.muteki = 999;
			param.type = 1;
			param.kasanari_modosi = 22;
			break;
	}
	
	ret_tmpl.Init <- function() : (param, pat_num_RecoverBarrier, pat_num_Eff_Ukemi, pat_num_Eff_GroundUkemi)
	{
		BMvTbl.SetVector( { x=param.vec.x, y=param.vec.y, addx=param.vec.addx, addy=param.vec.addy } );
		BMvTbl.SetVector_MaxX( 0 ); //XMAXを初期化
		
		if( param.type == 0 )
		{
			//空中受け身
			// _dpn("空中受け身");
			BMvEff.SetPlayerTimer( { muteki_nage=Def_Rule_AirRecover_NoMoveFrame+1, muteki_dage=param.muteki, muteki_dageX=param.muteki, muteki_nageX=Def_Rule_AirRecover_NoMoveFrame+1 } );
			Battle_Std.TypeSE_Play({ type="空中受け身" });
			BMvTbl.SetMoveableFlag( { move=0, time=Def_Rule_AirRecover_NoMoveFrame, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
			Battle_Std.MoveCodeEx.AddFlag( 5, def_MC5_EnableAirToLandedShield );
			
			local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
			if( rc.sx != _Hantei_Error ) // 存在するか
			{
				local eff = BMvEff.CreateObject( { x=rc.sx, y=rc.sy, mvname="", datatype=1, start_pat=pat_num_Eff_Ukemi, flags=_Position_ToolShift } );
				if( eff.push() )
				{
					BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
					eff.pop();
				}
			}
		}
		else
		{
			//地上受け身
			// _dpn("地上受け身");
			BMvEff.SetPlayerTimer( { muteki_nage=1000, muteki_dage=1000, muteki_dageX=1000, muteki_nageX=1000 } );
			Battle_Std.TypeSE_Play({ type="地上受け身" });
			BMvTbl.SetMoveableFlag( { move=0, time=1000, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
			
			Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_WaitCap_ThrowFDash );//地上投げのダッシュでつかみにいかない行動
			
			BMvEff.SetExist( { level = _Exist_NoKasanariHantei, mode=_ExistMode_Add } ); // 重なり判定無効
			
			local eff = BMvEff.CreateObject( { datatype=1, start_pat=pat_num_Eff_GroundUkemi } );
			if( eff.push() )
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
				eff.pop();
			}
			local eff = BMvEff.CreateObject( { datatype=1, start_pat=pat_num_Eff_Ukemi } );
			if( eff.push() )
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
				eff.pop();
			}
		}
		
		BMvTbl.SetLP(0,0); // 着地まで進んだかどうか
		BMvTbl.SetLP(1,0); // 行動可能まで進んだかどうか
		BMvTbl.SetLP(2,0); // 重なりを戻したかどうか
		
		Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定
		
		
	}
	
	ret_tmpl.FrameUpdate <- function() : (param)
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding )
		{
			BMvTbl.SetLP(0,1); // 着地まで進んだ
			BMvTbl.SetFinalize(256); // 着地によるファイナライズ
		}
		
		//空中受け身の場合は途中から動ける
		if( param.type==0 && mvs.MvCount >= Def_Rule_AirRecover_NoMoveFrame && BMvTbl.GetLP(1)==0 )
		{
			BMvTbl.SetLP(1,1); // 行動可能まで進んだ
			BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動可能に
			Battle_Std.Reversal.SetTime(); //リバーサル受付＋判定オブジェクト生成
		}
		
		if( param.type==1 && mvs.MvCount >= param.kasanari_modosi && BMvTbl.GetLP(2)==0 )
		{
			BMvTbl.SetLP(2,1); // 重なりを戻した
			BMvEff.SetExist( { level = _Exist_NoKasanariHantei, mode=_ExistMode_Erase } ); // 重なり判定無効
			
			Battle_Std.MoveCodeEx.DelFlag( 3, def_MC3_WaitCap_ThrowFDash );//地上投げのダッシュでつかみにいかない行動
		}
	}
	
	ret_tmpl.Finalize <- function() : (landmv)
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,landmv]); //デフォ,[code,mv]...
	}
	
	ret_tmpl.LastUpdate <- function() : (param)
	{
		//param.type != 0のときだけでいいけど、念の為常に無効を消す
		BMvEff.SetExist( { level = _Exist_NoKasanariHantei, mode=_ExistMode_Erase } ); // 重なり判定無効
		
		if( param.type==1 ) //地上受身
		{
			//着地経由せずに万が一抜けるような時は無敵を消しておく（ないはずだけど）
			if( BMvTbl.GetLP(0)==0 )
			{
				BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0 } );
			}
			//地上受け身
			Battle_Std.Reversal.SetTime(); //リバーサル受付＋判定オブジェクト生成
		}
		
		//無敵時間は継続しないで消去する（シビアにはなる）
		if( Def_Sys_AirRecoverKeepMutekiType )
		{
			BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0 } );
		}
	}
	
	
	return ret_tmpl;

}

//空中受け身の着地ｍｖ作成　受け身状態ではない
local makemv_recoverland = function( type=0 /* 0:ニュートラル 1:前 2:後ろ */ )
{
	local ret_tmpl = {};
	
	ret_tmpl.Init <- function() : (type)
	{
		//着地したら時間の無敵は解除
		Battle_Std.InitVector(); // ベクトル初期化
		
		if( Def_Sys_AddPunishFrame_GroundRecoverF && type == 11 )//地上前受身
		{
			BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0 } ); //起き上がり投げ無敵はなし

			BMvTbl.SetMoveableFlagEx( { move=0, timeA=Def_Sys_AddPunishFrame_GroundRecoverF, timeB=64, flag=_ClearFlag_ChangeMv } );//硬直のあと行動可能に
			Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
		}
		else
		{
			BMvEff.SetPlayerTimer( { muteki_nage=def_FL_OkiagariNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_OkiagariNageMuteki } ); //起き上がり投げ無敵

			BMvTbl.SetMoveableFlag( { move=1, time=64, flag=_ClearFlag_ChangeMv } ); //着地後は行動可能に
		}
		BMvTbl.SetLP(0,1); //着地まで進んだ
	}
	
	ret_tmpl.Finalize <- function()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" ); //共通落下をはさむので地上でいい
	}
	
	return ret_tmpl;

}

//空中前受け身
Std_MoveTable.Mv_Recover_N <- makemv_recover(0,"Mv_RecoverLand_N");
Std_MoveTable.Mv_Recover_F <- makemv_recover(1,"Mv_RecoverLand_F");
Std_MoveTable.Mv_Recover_B <- makemv_recover(2,"Mv_RecoverLand_B");
Std_MoveTable.Mv_GroundRecover_N <- makemv_recover(10,"Mv_GroundRecoverLand_N");
Std_MoveTable.Mv_GroundRecover_F <- makemv_recover(11,"Mv_GroundRecoverLand_F");
Std_MoveTable.Mv_GroundRecover_B <- makemv_recover(12,"Mv_GroundRecoverLand_B");

Std_MoveTable.Mv_RecoverLand_N <- makemv_recoverland(0);
Std_MoveTable.Mv_RecoverLand_F <- makemv_recoverland(1);
Std_MoveTable.Mv_RecoverLand_B <- makemv_recoverland(2);
Std_MoveTable.Mv_GroundRecoverLand_N <- makemv_recoverland(10);
Std_MoveTable.Mv_GroundRecoverLand_F <- makemv_recoverland(11);
Std_MoveTable.Mv_GroundRecoverLand_B <- makemv_recoverland(12);

// 地上受け身
Std_MoveTable.Mv_GroundRecover <- 
{
	function Init() : (recover_init) // 
	{
		local rst = BMvTbl.GetRecoverStatus(); // 受け身ステータスの取得
		// rst.Type
		// 1:垂直
		// 2:伏せ
		// 3:すべり
		// レバーとかではなくて、やられベクトル依存
		
		// _dpn("rst Type:"+rst.Type+" Stick:"+rst.Stick+" COM:"+BMvTbl.IsCpu() );
		
		local stick_side = { front=(1<<6), back=(1<<4) };//前・後
		if( BMvTbl.CheckFurimuki() ) stick_side = { front=(1<<4), back=(1<<6) };//前・後
		local stick_is_front = BMvTbl.CheckStickHold( stick_side.front ); // 振り向く前に処理
		local stick_is_back = BMvTbl.CheckStickHold( stick_side.back ); // 振り向く前に処理

		BMvTbl.SetMuki( _Direction_Auto );
		BMvTbl.SetPattern( def_PAT_AirRecovery );

		// Battle_Std.TypeSE_Play({ type="地上受け身" });
		
		recover_init(); //受け身処理
		// Battle_Std.SetCharaFlash_Ukemi(); //受身で光る　地上と空中で差をつけるために呼ばない
		
		// StickはCOMの地上受け身の設定
		if( BMvTbl.IsCpu() )
		{
			//変えるのがちょっと怖いのでスティック操作も一応見るようにする
			if( stick_is_back || ( rst.Stick == 4 ) ) 
			{
				//ごちゃったときはとりあえず後ろ優先にしておく
				BMvTbl.SetFinalize(200);//後
			}
			else if( stick_is_front || ( rst.Stick == 6 ) ) 
			{
				BMvTbl.SetFinalize(100);//前
			}
			else
			{
				BMvTbl.SetFinalize(0);
			}
		}
		else
		{
			//プレイヤー操作
			if( stick_is_back ) 
			{
				BMvTbl.SetFinalize(200);//後
			}
			else if( stick_is_front ) 
			{
				BMvTbl.SetFinalize(100);//前
			}
			else
			{
				BMvTbl.SetFinalize(0);
			}
		}
	}
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_GroundRecover_N", [100,"Mv_GroundRecover_F"], [200,"Mv_GroundRecover_B"] ); //デフォ,[code,mv]...
		// BMvTbl.SetNextMoveTable( "Mv_GroundRecover_N" );
	}
}// 


//無敵状態の移行だけを行う
Std_MoveTable.Mv_GroundRecover_Modori <-
{
	function Init() // 
	{
		//print("\nはいった");
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_GroundRecoverModoriNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_GroundRecoverModoriNageMuteki } );
		BMvTbl.SetMoveableFlag({ move=1, time=30, flag=_ClearFlag_ChangeMv }); //Mv内行動可能
		
		//Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定　ここは戻りなので設定しない
	}
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

// 壁受け身
Std_MoveTable.Mv_WallRecover <- 
{
	function Init() : (recover_init) // 
	{	
		BMvTbl.SetMuki( _Direction_Auto );
		BMvTbl.SetPattern( def_PAT_AirRecovery );
		Battle_Std.TypeSE_Play({ type="壁受け身" });

		//壁受身エフェクトを表示
		BMvEff.CreateObject( { x=0, y=-200, mvname="", datatype=1, start_pat=23, flags=_Position_ToolShift } ); //受身エフェクト		
		
		recover_init(); //受け身処理
		Battle_Std.SetCharaFlash_Ukemi(); //受身で光る

		//はりつき中は無敵
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_WallRecoverMuteki, muteki_dage=def_FL_WallRecoverMuteki, muteki_dageX=def_FL_WallRecoverMuteki, muteki_nageX=def_FL_WallRecoverMuteki  } );		
	}
	function FrameUpdate()
	{
		local s = BMvTbl.GetMvStatus();
		
		if( s.MvCount>=def_FL_WallRecoverWaitMax )
		{
			_dm("壁受身から自動で復帰");
			if( BMvTbl.CheckStickHold( (1<<1) | (1<<2) | (1<<3) )==1)
			{
				BMvTbl.SetFinalize(def_FC_WallRecover_Sita); //下受身
			}
			else
			{
				BMvTbl.SetFinalize(0); //普通受身			
			}
		}
	}
	function LastUpdate()
	{
		//無敵解除
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0  } );		
	}
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_WallRecover_Jump", [def_FC_WallRecover_Sita,"Mv_WallRecover_Jump_Sita"] ); //デフォ,[code,mv]...
	}
}// 

//とりあえずこれでバグらんようにしとこ
Std_MoveTable.Mv_WallRecover_Jump <- 
{
	function Init()
	{
		BMvTbl.SetMuki( _Direction_Auto );
		BMvTbl.SetPattern( def_PAT_AirRecovery );
		BMvTbl.SetVector( { x=1600, y=-3500, addx=0, addy=250 } );
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_F_RecoverMuteki, muteki_dage=def_FL_F_RecoverMuteki, muteki_dageX=def_FL_F_RecoverMuteki, muteki_nageX=def_FL_F_RecoverMuteki  } );

		Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定		
	}
	function FrameUpdate()
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			//着地したら時間の無敵は解除
			Battle_Std.InitVector(); // ベクトル初期化
			BMvEff.SetPlayerTimer( { muteki_nage=def_FL_OkiagariNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_OkiagariNageMuteki } );		
		}	
	}	
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" ); //共通落下をはさむので地上でいい
	}
}

//とりあえずこれでバグらんようにしとこ
Std_MoveTable.Mv_WallRecover_Jump_Sita <- 
{
	function Init()
	{
		BMvTbl.SetMuki( _Direction_Auto );
		BMvTbl.SetPattern( def_PAT_AirRecovery );
		BMvTbl.SetVector( { x=0, y=1000, addx=0, addy=250 } );
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_F_RecoverMuteki, muteki_dage=def_FL_F_RecoverMuteki, muteki_dageX=def_FL_F_RecoverMuteki, muteki_nageX=def_FL_F_RecoverMuteki  } );

		Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定		
	}
	function FrameUpdate()
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			//着地したら時間の無敵は解除
			BMvTbl.SetPattern( def_PAT_AirRecovery ); //できる？
			Battle_Std.InitVector(); // ベクトル初期化
			
			//下受け身は強いので無敵がない
			//というか行動不能なので硬直がある
			BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0  } );		
			
			//着地エフェクトを表示
			BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=20, flags=_Position_ToolShift } ); //着地
		}
	}
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" ); //共通落下をはさむので地上でいい
	}
}

Std_MoveTable.Mv_DelaySpCutinObj <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
	}
	function FrameUpdate_Std() : (pat_num_Eff_SpSpark)
	{
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			local vanish = 0;
			local stopframe = def_FL_EXCutinStopTime;
			// 特殊判定１を監視して、見つかったらカットイン処理へ
			local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
			
			if( rc.sx != _Hantei_Error ) // 存在するか
			{
				BMvEff.SetPlayerTimer( {
					muteki_nage=def_FL_SPCutinStopTime+def_FL_WorthSkill_NageMutekiFrame,
					muteki_dage=def_FL_SPCutinStopTime,
					muteki_nageX=def_FL_SPCutinStopTime+def_FL_WorthSkill_NageMutekiFrame,
					muteki_dageX=def_FL_SPCutinStopTime } );

				BMvEff.SetStopTime( { time=def_FL_SPCutinStopTime } ); //時間停止
				
				// これ画像固定なんす
				BMvEff.CutInProc_Set({ time=[10,999,10], cutin_mv="Mv_CutinGrp",erasetype=1 }); //カットイングラフィックとか呼び
				Battle_Std.CharaAchievement_Increment( 191, "AD" ); // ADを使ってカットインを見た
				
				BMvEff.CreateObject( { x=rc.sx, y=rc.sy, mvname="", datatype=1, start_pat=pat_num_Eff_SpSpark, flags=_Position_ToolShift } );
				BMvEff.SetCamera_Focus( { charapos=1, zoom=1.00, time=[30,def_FL_SPCutinStopTime-40,10], type_in=3, type_out=1 } ); //カメラ集中テスト

			
				// Battle_Std.SetEXCutinCameraFocus( stopframe );
				// Battle_Std.SetEXCutinGrp();
				vanish = 1;
			}
			player.pop();
			
			if( vanish ) BMvTbl.SetFinalize( 0 ); // 終わり
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}


// Battle_Std.CSAntenGaesi_DamageHosei から呼ばれる
// CSでのキャンセルならうんたん、それ以外ならキツいダメージ補正をかける
// 要するにCSでないと追撃不能、という処理だと弱体化が激しいので
// CSでないとダメージ低い、という調整をするためのもの
Std_MoveTable.Mv_Null_CSHoseiChecker <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		
		// BMvTbl.SetLP(0,0); // 上書き補正
		// BMvTbl.SetLP(0,0); // 乗算補正
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount > 60 )
		{
			BMvTbl.SetFinalize( 0 );
			// lastupdateからmv変更まで60fもかかることはないと思うのでここで抜ける
		}
		
		// Mv名を監視する
		if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) == 0 )
		{
			// 別のMvに変わったようだよ
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				local mvname = BMvTbl.GetMvName();

				player.pop();
				
				if( mvname=="Mv_Convert" )
				{
					// CSで抜けた
					_dp("\n CSキャンセルだったね");
					BMvTbl.SetFinalize( 100 );
					return;
				}
			}
			
			BMvTbl.SetFinalize( 200 );
			local uwagaki = BMvTbl.GetLP(0);
			local zyozan = BMvTbl.GetLP(1);
			if( uwagaki ) BMvEff.ComboView_Set( { val=uwagaki, type=0 } ); // 上書き補正
			if( zyozan ) BMvEff.ComboView_Set( { val=zyozan, type=1 } ); // 乗算補正
			_dp("\n ★補正適用 上書き:"+uwagaki+" 乗算:"+zyozan );
			return;
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}


//暗転される生成されて、自分が暗転後動けるようになると消えるオブジェクト
//相手から生成を呼ばれるので注意
Std_MoveTable.Mv_Null_AntenStopObject <-
{
	function Init_Std()
	{
		// _dpn("Init");
		
		//下の処理がないと相殺で呼ばれるときにうまく動かない
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_EnemyAntenStop );
			Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_OnceEnemyAntenStop );//こっちは消さないしFrameUpdateでも追加しない
			player.pop();
		}
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_Anten );
			enemy.pop();
		}		
	}
	function FrameUpdate_Std()
	{
		local anten_stop = 1;
		
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 2 )
		{
			anten_stop = 0; // このフレームまできたらもう暗転終わってる
		}
		// _dpn("Mv_Null_AntenStopObject:"+mvs.MvCount+" anten_stop:"+anten_stop);
		
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			if( anten_stop )
			{
				Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_EnemyAntenStop );
				// Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_OnceEnemyAntenStop );//ここで追加すると余計な技まで被暗転になる
			}
			else
			{
				Battle_Std.MoveCodeEx.DelFlag( 2, def_MC2_EnemyAntenStop );
				
			}
			player.pop();
		}
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			if( anten_stop )
			{
				Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_Anten );
			}
			else
			{
				Battle_Std.MoveCodeEx.DelFlag( 3, def_MC3_Anten );
				
			}
			enemy.pop();
		}
		if( anten_stop != 1 )
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		
	}
}

_dp1p("\n btl_UkemiFunc.....OK");
//Battle_Std.SetVector <- ukemi_tbl.SetVector;



local pat_num_BlastWait = BMvEff.GetPatternNum( { datatype=0, pat="BlastWait" } ); // パターン文字列のパターン番号を事前取得
local pat_num_BlastLoop = BMvEff.GetPatternNum( { datatype=0, pat="BlastLoop" } ); // パターン文字列のパターン番号を事前取得
local pat_num_BlastFall = BMvEff.GetPatternNum( { datatype=0, pat="BlastFall" } ); // パターン文字列のパターン番号を事前取得
local pat_num_BlastLand = BMvEff.GetPatternNum( { datatype=0, pat="BlastLand" } ); // パターン文字列のパターン番号を事前取得

// ----------------------------------------------------------------------------
// コンセントレーション
// ----------------------------------------------------------------------------

local pat_num_moon_charge = BMvEff.GetPatternNum( { datatype=1, pat="moon_charge" } );

//ムーンチャージ
//コンセントレーション
//ムーンチャージをしたあと、一定時間ムーンアイコンが増えやすい状態になる
//そこから攻め込んでしっかり回収しましょう的な感じ
//FrameID 44:琥珀で予約

//わかりにくいのでこういうことはせずシンプルに修正
//local hold_button_mask = (_ChrNo == Def_ChrNo_Chr015)? [ "@H,A@", "@H,B@", "@H,C@" ] : [ "@H,A@", "@H,B@" ];

Std_MoveTable.Mv_ConvertCharge <-
{
	function Init_Std()
	{
		//共通処理
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.ClearHitStatus(); //ヒット情報のクリア（空振りキャンセル可能フラグをたててるため必要）

		BMvTbl.SetPattern(def_PAT_ChargeMotion);

		Battle_Std.InitVector(); // ベクトル初期化
		
		Battle_Std.TypeSE_Play({ type="ゲージ溜め" });
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
		
		BMvTbl.SetLP(0,0); // 月をためるのに成功したか 1〜:ためた月の数
	}
	function Start_Std() : (pat_num_moon_charge)
	{
		BMvEff.CreateObject( { datatype=1, mvname="Mv_ConvertEffect", start_pat=pat_num_moon_charge } );
	}
	function FrameUpdate_Std()
	{
		Battle_Std.CallSamePatLoopEndCache_FrameID( 100 ); // 定期的にループ抜け先のFrameIDを予約
		
		local mvs = BMvTbl.GetMvStatus(); // ステータス取得
		// 1Fに１回の処理
		if( mvs.CallCount == 0 )
		{
			local enemy_is_bound = Battle_Std.CheckEnemyisBound(); // ガードややられのとき
			
			local addval = { sp = 0, moon = 0 };
			
			// 月ゲージ溜め
			// _dpn("mvs.MvCount%60:"+mvs.MvCount%60+" MC:"+BMvTbl.GetPP(def_PP_MoonChargeTmp) );
			local moon_is_max = Battle_Std.MoonIcon_CheckCost( 10000 );
			if( !moon_is_max )	//満タンのときにチャージで予約できたら変なので除外
			{
				BMvTbl.AddPP(def_PP_MoonChargeTmp,1);
			}
			
			local long_charge = (mvs.MvCount > 20)? 1 : 0;
			
			local moon_upcnt = 60;//どれだけためたら1ブロック増えるか
			if( long_charge )
			{
				moon_upcnt = (enemy_is_bound)? 80 : 45;
			}
			else
			{
				moon_upcnt = (enemy_is_bound)? 90 : 60;
			}
			// _dpn("moon_upcnt:"+moon_upcnt);
			
			if( BMvTbl.GetPP(def_PP_MoonChargeTmp)>=moon_upcnt )
			{
				BMvTbl.SetPP(def_PP_MoonChargeTmp,0);
				local now_moon_val = tDDC.Moon_GetValue( 0 );
				local set_moon_val = Battle_Std.Moon_AddValue(Def_MoonChargeMoonAdd);//ムーンチャージで増加
				
				BMvTbl.AddLP(0,1); // 月をためるのに成功したか 1〜:ためた月の数

				//増加したら
				local moon_sa = set_moon_val - now_moon_val;
				if( moon_sa > 0 )
				{
					addval.moon = moon_sa;
				}
			}
			
			// ゲージ溜め
			local kakusei = BMvEff.SpGauge_GetAwakens();
			local gauge = BCMDTbl.GetComboGauge();
			local max_gauge = ( kakusei )? 40000 : 30000;
			if( gauge < max_gauge )
			{
				local val = 0;//増加量
				if( long_charge )
				{
					val = (enemy_is_bound)? 15 : 30;
				}
				else
				{
					val = (enemy_is_bound)? 10 : 20;
				}
				
				BMvEff.SetSpGauge( { value=val } ); // 
				addval.sp = val;
			}
			
			//体力が少し減っていく
			if( addval.sp > 0 || !moon_is_max )
			{
				local val = ( long_charge )? -2 : -4;//ちょいため連打だと少し効率悪い
				// _dpn("mvs.MvCount:"+mvs.MvCount+" val:"+val);
				BMvEff.SetHpGauge( { value=val, valuetype=1 } );
			}

			//相手がムーンドライブ中のときは、相手のムーンドライブの時間を減らす
			if( Def_Sys_MoonCharge_EnemyMoonDriveMinus )
			{
				local enemy = BMvCore.GetEnemyCharaData();
				if( enemy.push() )
				{
					local is_moon_drive = Battle_Std.MoonDrive_IsActive();
					
					if( is_moon_drive )
					{
						tDDC.Moon_AddValue( -Def_MoonChargeEnemyMoonDriveMoonMinus );
					}
					enemy.pop();
					
				}
			}
		}
		
		local hold_button = BMvTbl.CheckCommandString( [ "@H,A@", "@H,B@" ] );//ホールドキャラもいるのでCは"@H,C@"は廃止
		local input_stick = BMvTbl.CheckCommandString( [ "<","^",">","v" ] );
		local input_button = BMvTbl.CheckCommandString( [ "A","B","C","D" ] );
		if( mvs.MvCount>def_FL_ConvertMinTime )
		{
			if( hold_button )
			{
				if( input_button )
				{
					BMvTbl.SetFinalize(256);
				}
			}
			else
			{
				if( input_stick || input_button )
				{
					BMvTbl.SetFinalize(256);
				}
				
				if( mvs.MvCount>def_FL_ConvertMinTime && !input_stick )
				{
					BMvTbl.SetFinalize(256);
				}
			}
		}
		
		if( mvs.MvCount>def_FL_ConvertMaxTime )
		{
			BMvTbl.SetFinalize(256);		
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_ConvertCharge_Modori"]); //デフォ,[code,mv]...	
	}
	function LastUpdate_Std()
	{
		//ゲージ溜めの音声をフェードアウト
		Battle_Std.TypeSE_AllStop( { type="ゲージ溜め", fadetime=5 } );
	}
}

Std_MoveTable.Mv_ConvertEffect <-
{
	function CallSE( play=1 )
	{
		if( play )
		{
			// _dpn("再生");
			BSound.SE_Play( { type=_SeType_Normal, num=227 } );//チャージSE
		}
		else
		{
			// _dpn("停止");
			BSound.SE_Stop( { type=_SeType_Normal, num=227, fadetime=30 } );
		}
	}
	function Init_Std()
	{
		BMvTbl.SetLP(0,0);//消滅に進んだか
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove } );//追尾にしないと押されてズレる
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();

		//行動変化でフェードアウトでよき
		if( BMvTbl.GetLP(0)==0 && BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) == 0 )
		{
			BMvEff.EraseObjectFlags( { flags=_ObjFlags_ParentMove } );
			BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
			BMvTbl.JumpFrameID(900);
			BMvTbl.SetLP(0,1);//消滅に進んだか
			CallSE(0);
		}
		if( mvs.MvCount%80==0 && mvs.CallCount==0 && BMvTbl.GetLP(0)==0 )
		{
			CallSE(1);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//ムーンチャージの戻り
Std_MoveTable.Mv_ConvertCharge_Modori <-
{
	function Init_Std() // 
	{
		// BMvTbl.SetLP(0,0); // 月をためるのに成功したか 1〜:ためた月の数
		Battle_Std.JumpFrameIDEX(100, 149, 0); //設定FrameID, 上書きPattern, 失敗時FinalizeCode
		if( BMvTbl.GetLP(0) > 0 )
		{
			_dpn("行動可能");
			BMvTbl.SetCommandFailTime( { command=[def_CN_ConvertCharge], time=4 } ); // 3F以上ないとムーンチャージが漏れる
			BMvTbl.SetMoveableFlag({ move=1, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv }); //行動可能
		}
		else
		{
			BMvTbl.SetMoveableFlagEx( { move=0, timeA=2, timeB=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );//2Fの硬直のあと行動可能に（硬直を減らすと漏れる）
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}


local pat_num_moon_drive = BMvEff.GetPatternNum( { datatype=1, pat="moon_drive" } );
local pat_num_Eff_Charge3 = BMvEff.GetPatternNum( { datatype=1, pat="Eff_Charge3" } );

local makemv_MoonDrive = function( param={} ) : (pat_num_moon_drive, pat_num_Eff_Charge3)
{
	local ret_mv = {};
	
	local mvParam = {
		activeF = 0,//発動時の硬直(0の場合はStartタイミング。1とか2は使わないこと。)　100%消費のときは硬直は0になる
		endMv = "Mv_MoonDrive_Modori",
		counter = 0,
		useF = 3,
		cutinMv = "Mv_MoonCutin",
		cutinMvEnemy = "Mv_MoonCutinEnemy",
		enableDoujiCancel = 1,
	}
	
	//activeFとuseFが同一でないと、useF〜activeFの間に相手の暗転が挟まった時、相手の暗転終了後に相手が演出なして時間停止で固まるのがおかしいのでダメ
	//MEMO:activeF=useF固定でちょっと作り直す必要がありそう
	
	//生　発生8F、暗転30F、硬直3F（硬直差-3F）
	//暗転まで少しかかるし、少し硬直があって暗転後微不利

	//コンボ　発生3F、暗転30F
	//暗転は同時押し猶予が終わったらすぐ。硬直はない
	
	//カウンター　発生1F、暗転30F、硬直3F
	//暗転は1F、相手の暗転中にできることは何もないので即。発動すると相手のMvもまとめて操作し、硬直差を調整する。
	
	switch( param.type )
	{
	case "Normal":
		mvParam.activeF = 3;
		mvParam.endMv = "Mv_MoonDrive_Modori";
		break;
	case "Combo":
		mvParam.activeF = 0;
		mvParam.enableDoujiCancel = 0;
		mvParam.endMv = "Mv_MoonDrive_Modori";
		break;
	case "Counter":
		mvParam.activeF = 0;
		mvParam.endMv = "Mv_MoonDrive_Modori";
		mvParam.counter = 1;
		mvParam.enableDoujiCancel = 0;
		mvParam.cutinMv = "Mv_MoonCounterCutin";
		mvParam.cutinMvEnemy = "Mv_MoonCounterCutinEnemy";
		break;
	}

	ret_mv.MoonDriveUse <- function( effect = 1 ) : (mvParam, pat_num_moon_drive, pat_num_Eff_Charge3)
	{
		if( effect )
		{
			//ムーンドライブの演出関係
			BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254, muteki_dageX=254, muteki_nageX=254 } );

			//相手に、暗転後動けるようになると消えるオブジェクトを呼ぶ
			Battle_Std.CallAntenStopObject();
			
			// if( mvParam.counter || is_fast_counter )
			if( mvParam.counter )
			{
				BMvTbl.SetLP(0,-1);//カウンター受付残り時間 -1:受け付けない 0:受付開始後何フレーム経過したか
				
				//2Pがカウンターすると、2Pの方が硬直が1F長い　10F目,60
				//1Pがカウンターすると、硬直差は五分
				local player_side = BMvTbl.GetPlayerSide();//微妙に処理的に硬直差が揃わないので暗転時間で帳尻を合わせる
				
				//同時暗転にして硬直差を五分にする
				BMvEff.SetStopTime( { time=def_FL_ConvertStopTime+player_side, bounderase=1 } ); //チェインシフトの時間停止
				local enemy = BMvCore.GetEnemyCharaData();
				if( enemy.push() )
				{
					BMvEff.SetStopTime( { time=def_FL_ConvertStopTime, bounderase=1 } ); //チェインシフトの時間停止
					
					enemy.pop();
				}
			}
			else
			{
				BMvEff.SetStopTime( { time=def_FL_ConvertStopTime, bounderase=1 } ); //チェインシフトの時間停止
				BMvTbl.SetLP(0,0);//カウンター受付残り時間 -1:受け付けない 0:受付開始後何フレーム経過したか
			}
			
			BMvEff.CutInProc_Set({ time=[3,def_FL_ConvertStopTime-3,10], cutin_mv="",erasetype=0, bgtype=1 });
			Battle_Std.SetInstantCameraFocus( def_FL_ConvertStopTime-10 );//ちょっとカメラ集中
		}
		
		
		// コスト消費ここから
		Battle_Std.CharaBattleActivity_Increment(95,"ムーンドライブ使用");

		if( effect )
		{
			//カットイン呼び出し
			//KO後はどっちかが死んでいるので顔があると違和感があるので出さない
			if( !Battle_Std.RoundisEnd() )
			{
				local enemy_md_cutin_muki = (BMvTbl.GetMuki()==1)? _Direction_Right : _Direction_Left;//反対の向き
				BMvEff.CreateObject( { mvname=mvParam.cutinMv } ); // カットイン処理
				local enemy = BMvCore.GetEnemyCharaData();
				if( enemy.push() )
				{
					local eff = BMvEff.CreateObject( { mvname=mvParam.cutinMvEnemy } ); // カットイン処理
					if( eff.push() )
					{
						BMvTbl.SetMuki(enemy_md_cutin_muki);
						eff.pop();
					}
					enemy.pop();
				}
			}
		}

		//わっかとか着地砂煙はいつでも出す
		local eff_pos = { x=BMvTbl.GetLP(1), y=BMvTbl.GetLP(2) };
		local eff = BMvEff.CreateObject( { x=eff_pos.x, y=eff_pos.y, datatype=1, start_pat=pat_num_moon_drive, flags=_Position_ToolShift } );
		if( eff.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
			eff.pop();
		}
		
		local pos = BMvTbl.GetPosition(0);
		if( pos.y >= -64 ) //地上付近だったら出す
		{
			local eff = BMvEff.CreateObject( { x=0, y=0, datatype=1, start_pat=pat_num_Eff_Charge3, flags=_Position_ToolShift } );
			if( eff.push() )
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
				eff.pop();
			}
		
		}
		
		local isMaxDrive = ( tDDC.Moon_GetValue() == 10000 )? 1 : 0;
		// local moon_type = ( isMaxDrive )? 0 : 1;
		local moon_type = ( isMaxDrive )? 1 : 2;
		local calc_moon_time = (isMaxDrive)? Def_MoonDriveTimeMax : Def_MoonDriveTime;//ムーンドライブの時間
		//SEはいつでも出したほうがわかりやすい
		BSound.SE_Play( { type=_SeType_Normal, num=30 } );//発動SE
		
		Battle_Std.ChangeMoonDriveMode( { type=moon_type, time=calc_moon_time } );//月ゲージをムーンドライブ状態に
		tDDC.Moon_ChangeMoonDriveTimeSpeed( 0 );//演出中は減少を止める
		
		if( effect )
		{
			Battle_Std.TypeSE_Play({ type="本気を出す", flags=(1<<2) });
		}
		
		//メッセージの表示
		BMvEff.AttackInfoString_Set({ word=def_AISW_MoonDrive,} );
	}
	
	ret_mv.CheckCounterDriveCommand <- function()
	{
		if( BMvTbl.CheckCommandString( { command="0+B+C", lastdelay=1 } ) && Battle_Std.CheckCounterDriveCommandStatus() )
		{
			return 1;//出せる
		}
		return 0;
	}
	
	ret_mv.Init_Std <- function() : (mvParam)
	{
		// _dpn("Init_Std");
		
		//今のベクトルを記憶
		local vec = BMvTbl.GetVector(0);
		BMvTbl.SetVector( { x=vec.x, y=vec.y, addx=vec.addx, addy=vec.addy, flags=_Vector_Keep } ); //保存ベクトルに与える
		
		local use_pat = 148;//空中版
		
		//次のフレームで着地しそうだった場合着地したことにする
		local pos = BMvTbl.GetPosition();
		if( pos.y < 0 && (pos.y + vec.y + vec.addy) >= 0 )
		{
			BMvTbl.SetPosition( { y=0 } );
			Battle_Std.InitVector();//着地してベクトル初期化
			BMvEff.CreateObject( { datatype=1, start_pat=20 } );//着地煙
			use_pat = 147;//地上版
		}
		else if( pos.y >= 0 )
		{
			use_pat = 147; // 地上版
		}
		else
		{
			//空中版
			
			if( Def_Sys_AirMoonDriveSetJumpFlag )
			{
				//以下の処理は保険。ModoriのMvで大体処理されてる
				Battle_Std.SetPP_JumpStartHeight(); // ジャンプしたときの高さを記憶
				Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_Jump );//ジャンプ扱い（のぼりMDからの崩し対策）
				Battle_Std.MoveCodeEx.AddFlag( 5, def_MC5_EnableAirToLandedShield );
			}
		}
		
		//行動不能にする
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		
		if( Def_Sys_MoonDriveNageMuteki )
		{
			//でかかりを無敵にする
			BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254, muteki_dageX=254, muteki_nageX=254 } );
		}
		else
		{
			//でかかり打撃無敵のみ。投げ無敵があったら消す
			BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=254, muteki_dageX=254, muteki_nageX=0 } );
		}
		
		BMvTbl.SetMuki(_Direction_Auto); //振り向く
		BMvTbl.SetPattern(use_pat); //パターンセット
		BMvTbl.SetPrio( _CharaPrio_Near ); //目立たせるように手前にする
		
		BMvTbl.SetVector( { x=0, y=0, addx=0, addy=0, flags=_Vector_Normal|_Vector_Div|_Vector_Bound|_Vector_DivKeep } ); //Keep以外を初期化
		BMvTbl.SetVector_MaxX( 0 ); //XMAXを初期化
		BMvTbl.ClearTriVector( { x=0, y=0 } ); //Triを初期化
		
		Battle_Std.Reversal.CheckTime_DrawInfo(); // リバーサルなら文字表示
		
		// 戻りのモーションをキャッシュにのせておく
		local cache_f = def_FL_ConvertStopTime -3; // 大体40Fぐらいだから余裕っしょ
		if( cache_f < 0 ) cache_f = 3;
		Battle_Std.CallSkillSoonCaches( [100,cache_f] ); // FrameID, rest	
		
		local cmdParam = BMvTbl.GetCmdParam(0);
		if( cmdParam&Def_CMDP_CallMoonDriveCounter )
		{
			//カウンター時は同時押しでの移行を認めない
		}
		else if( mvParam.enableDoujiCancel )
		{
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK );
		}

		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_MoonDrive );
		Battle_Std.GS_DelFlag( def_PP_GS_MoonDriveCounter );
		
		BMvTbl.SetCounterHitFlag( { val=1, time=254, flag=_ClearFlag_ChangeMv } );//ハイカウンター
		
		BMvTbl.SetLP(0,-1);//カウンター受付残り時間 -1:受け付けない 0:受付開始後何フレーム経過したか
		BMvTbl.SetLP(1,0);//X 暗転エフェクト座標
		BMvTbl.SetLP(2,-200);//Y
		// BMvTbl.SetLP(3,0);//強化版かどうか
		BMvTbl.SetLP(4,0);//処理をやり終えたかのフラグ (1<<0):コスト払った

		BMvTbl.SetLP(6,mvParam.activeF); // 発生F記憶（カウンター用）
		
		local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
		if( rc.sx != _Hantei_Error )
		{
			BMvTbl.SetLP(1,rc.sx);
			BMvTbl.SetLP(2,rc.sy);
		}
	}

	ret_mv.Update_Std <- function() : (mvParam)
	{
		//フレーム毎の増加
		BMvEff.SetSpGauge( {value=def_SP_Convert_Frame,} );
		
		local mvs = BMvTbl.GetMvStatus();
		
		// コンボ中は早くしても良いのでは、という気はするけど処理が難解でいじらない
		if( mvs.MvCount >= mvParam.activeF )
		{
			if( !Battle_Std.LP_CheckFlag( 4,(1<<0) ) )
			{
				Battle_Std.LP_AddFlag( 4, (1<<0) );

				MoonDriveUse();
			}
		}
		
		if( BMvTbl.GetLP(0) != -1 )//カウンター受付残り時間 -1:受け付けない 0:受付開始後何フレーム経過したか
		{
			local frame = BMvTbl.AddLP(0,1);//1F経過
			// _dpn("frame:"+frame+" def_FL_ConvertStopTime:"+def_FL_ConvertStopTime);
			// def_FL_ConvertStopTime-1 にしてるのは特に意味がないが、万が一暗転終了後に受け付けてしまうと暗転中に動けて終わりなので厳しくやる
			if( frame >= 1 && frame < def_FL_ConvertStopTime-2 )
			{
				local enemy = BMvCore.GetEnemyCharaData();
				if( enemy.push() )
				{
					local isUpdate = BMvTbl.GetMvStatus().isUpdate;//時間停止中は0、時間停止中のみ受付
					
					local input_couterdrive = 0;
			
					if( !Battle_Std.GS_CheckFlag( def_PP_GS_MoonDriveCounter ) )
					{
						//コマンドは入れてないけど、MoonDriveの暗転前なら成功
						local auto_counter = ( Battle_Std.IsMatchMvNameArray( ["Mv_MoonDrive", "Mv_MoonDriveCombo"] ) && !Battle_Std.LP_CheckFlag( 4,(1<<0) ) )? 1 : 0;
						
						if( auto_counter || (CheckCounterDriveCommand() && !isUpdate) )
						{
							input_couterdrive = 1;
							//ムーンドライブ返しを入力したのを検知
							Battle_Std.GS_AddFlag( def_PP_GS_MoonDriveCounter );//発動可能にする（発動はcmd側で行う）
							
							// カウンタームーンドライブを最優先で出させるための処理
							// 二重三重に制限はきつくしてる
							BMvTbl.SetCommandFailTime( { command=[def_CN_Liberate,def_CN_BoundBlast,def_CN_Skill_DyingIWE], time=3 } );
							BMvTbl.SetMoveableFlag( { move=0, time=1, flag=0 } ); // 無理やり行動不能にする
							BMvTbl.SetAsStatusFlag( { normal=_CancelFlag_None, special=_CancelFlag_None, time=1, flag=0 } );
							
							local eff = BMvEff.CreateObject( { mvname="Mv_Null_MoonDirveAnten" } );
							if( eff.push() )
							{
								BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
								BMvEff.SetExist( { level = _Exist_NoHantei } );
								BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
								
								eff.pop();
							}
						}
					}
					enemy.pop();
					
					if( input_couterdrive )
					{
						// _dpn("時間停止終わり");
						BMvEff.SetStopTime( { time=0 } ); //自分のチェインシフトの時間停止を消して、相手を暗転できるようにする
						//暗転中なのに動ける状態になってしまうので、カウンタードライブ以外の行動が出ないようにする必要がある
					}
				}
			}
		}
	}
	
	ret_mv.FrameUpdate_Std <- function() : (mvParam)
	{
		//発動すると一定時間時間停止とともに硬直する
		//相手があとからムーンドライブを出した場合、相手のムーンドライブが終わるまで待機し、硬直差を五分にする
		//お互い、LP5に自分が終われるかどうかを保存していて、
		// 2Pが終了待ちをする場合、1Pの終了に合わせられるので良い
		// 1Pが終了待ちをする場合、2Pのことはわかんないので困るが、2Pが1F早く終了フラグがつけば良い
		
		
		// 常に2P側が待機する側でなくてはいけない
		// そして1Pが終わって2Pが次のFで終わりそうなら両者終わる。
		// 逆に、2Pは先に終わってしまうとFinalizeのタイミング的にまずいので、1F遅らせる
		// ※1P・2Pで見ていたが、タッグキャラの場合3Pvs2PなどになることがあっておかしいのでPlayerNoを見るように変更
		
		local enemy_is_moondrive = 0;
		local enemy_left_frame = 0;
		local playernum = BMvTbl.GetPlayerNo(); // 自キャラのプレイヤーNo
		local enemynum = -1; // 相手キャラのプレイヤーNo
		
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			enemynum = BMvTbl.GetPlayerNo(); // 相手キャラのプレイヤーNo取得
			local emv = BMvTbl.GetMvName();
			if( emv == "Mv_MoonDrive" || emv == "Mv_MoonDriveCombo" || emv == "Mv_MoonDriveCounter" )
			{
				enemy_is_moondrive = 1;
				local mvs = BMvTbl.GetMvStatus();
				
				enemy_left_frame = (def_FL_ConvertStopTime-1+BMvTbl.GetLP(6))- mvs.MvCount;
				if( BMvTbl.GetPlayerSide()==0 )
				{
					enemy_left_frame++;
				}
			}
			enemy.pop();
		}
			
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		local player_left_frame = (def_FL_ConvertStopTime-1+mvParam.activeF)-s.MvCount;
		
		if( Def_Sys_MoonDrive_EnemyBoundQuickEnd )
		{
			local enemy_is_bound = Battle_Std.CheckEnemyisBound();//相手やられ中ははやく終わってコンボ入れやすくする
			if( enemy_is_bound )
			{
				player_left_frame -= 5;
			}
		}
		if( player_left_frame <= 0 || s.FrameID==100 )
		{
			if( enemy_is_moondrive )
			{
				// 211007追記 BMvTbl.GetPlayerSide()の小さい方かどうかで処理をしていたが
				// タッグキャラの場合は処理順が3Pキャラの方が遅くなる場合があるのでプレイヤーNoの小ささ比較する
				if( playernum < enemynum ) // プレイヤーNoが小さい（＝相手より処理が先）
				{
					if( enemy_left_frame <= 1 )
					{
						//2Pが次回Fで終了しようとしているので、1Pが終わって2Pも終わる指示を出す
						//これをやらないと、1Pが終わるけど2Pが終わらない(2Pから見た1Pの残りが1あるため)
						//※なので1F早く終る
						
						BMvTbl.SetFinalize(0);
						
						if( enemy.push() )
						{
							BMvTbl.SetFinalize(0);
							
							enemy.pop();
						}
					}
				}
				else
				{
					// 2P側は、1Pが終わってそうなら終わることでタイミングが合う
					if( enemy_left_frame <= 0 )
					{
						BMvTbl.SetFinalize(0);
					}
				}
			}
			else
			{
				// _dpn("MDじゃない終わり");
				BMvTbl.SetFinalize(0);
			}
			
		}
		
		/*
		if( 1 )
		{
			local pos = { x=BMvTbl.GetPlayerSide()*640+200, y= 200 };
			debugfontL.draw( pos.x, pos.y, format("MD:%3d left:%3d:%3d",BMvTbl.GetMvStatus().MvCount, player_left_frame, enemy_left_frame ));
		}
		*/
	}
	
	ret_mv.Finalize_Std <- function() : (mvParam)
	{
		BMvTbl.SetNextMoveTable( mvParam.endMv );
	}			
	
	ret_mv.LastUpdate_Std <- function()
	{
		if( Def_Sys_MoonDriveActiveDamage_UseCost && Battle_Std.CheckPlayerisDamage() )
		{
			if( !Battle_Std.LP_CheckFlag( 4,(1<<0) ) )
			{
				Battle_Std.LP_AddFlag( 4, (1<<0) );

				MoonDriveUse( 0 );//演出なしでゲージだけ使う
			}
		}
		
		//念のため無敵解除
		//20240311:投げで掴んだ時に相手を無敵にする処理が抜けることがあるので対応
		if( !Battle_Std.MoveCodeEx.CheckFlag( 6, def_MC6_ThrowTechedMuteki ) ) // 投げで掴まれたときの無敵状態ではない
		{
			// _dpn("MDの無敵解除のタイミング");
			BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0 } );	
		}
		BMvEff.SetStopTime( { time=0 } ); //チェインシフトの時間停止
		tDDC.Moon_ChangeMoonDriveTimeSpeed( 100 );
	}
	
	return ret_mv;
}

Std_MoveTable.Mv_MoonDrive <- makemv_MoonDrive( { type="Normal" } ); //ムーンドライブ
Std_MoveTable.Mv_MoonDriveCombo <- makemv_MoonDrive( { type="Combo" } ); //ムーンドライブ　※未使用っぽい
Std_MoveTable.Mv_MoonDriveCounter <- makemv_MoonDrive( { type="Counter" } ); //ムーンドライブ

//敵側から呼ばれる
Std_MoveTable.Mv_Null_MoonDirveAnten <-
{
	function Init_Std()
	{
		_dpn("チェック開始");
		
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 10 )
		{
			BMvTbl.SetFinalize();
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		_dpn("フラグ削除");
		Battle_Std.GS_DelFlag( def_PP_GS_MoonDriveCounter );
	}
}

Std_MoveTable.Mv_MoonDriveLineEffect <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround|_ObjFlags_ParentMove|_ObjFlags_NoRenderOrder } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull } );
		BMvTbl.SetPrio( _CharaPrio_Parent_P1 );
		
		BMvTbl.SetDrawAlpha( { val=255, time=255, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
	}
	function Update_Std()
	{
		if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Parent } ) )
		{
			local oya = BMvCore.GetParentCharaData();
			if( oya.push() )
			{
				local height = BMvTbl.GetLP(0);
				oya.pop();
				
				local par = (height * 100) / (360 * 128);
				// _dpn("height:"+height+" par:"+par);
				
				BMvTbl.SetScale( { x=10000, y=100*par } );
			}
		}
		else
		{
			local alpha = BMvTbl.GetDrawAlpha();
			alpha -= 10;
			if( alpha <= 0 )
			{
				BMvTbl.SetFinalize(0);
			}
			BMvTbl.SetDrawAlpha( { val=alpha, time=32, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

local patnum_moond_line = BMvEff.GetPatternNum( { datatype=1, pat="moond_line" } );
local patnum_moond_par = BMvEff.GetPatternNum( { datatype=1, pat="moond_par" } );
local patnum_moond_smoke_par = BMvEff.GetPatternNum( { datatype=1, pat="moond_smoke_par" } );
local patnum_moond_smoke_smoke = BMvEff.GetPatternNum( { datatype=1, pat="moond_smoke_smoke" } );

// 管理親（描画はしない）
// 軽量化したいが、ヒスコハのタッチで追尾するべき親を変える必要があって処理が重め
// タッチ交代時に再生成すればちょっと軽くなりそうな気はする
// とりあえずヒスコハかどうかで呼び出すMVを変えて、大多数のキャラの負荷を軽減する

if( _TagCharaNo == Def_ChrNo_Chr007 )
{//ヒスコハ用

Std_MoveTable.Mv_MoonDriveAuraEffect <-
{
	function Init_Std() : (patnum_moond_line)
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoRender|_ObjFlags_NoGround } );
		BMvTbl.SetPrio( _CharaPrio_Parent_P1 );
		
		BMvTbl.SetLP(0,360*128);//Y　子が参照している
		
		BMvEff.CreateObject( { datatype=1, mvname="Mv_MoonDriveLineEffect", start_pat=patnum_moond_line, x=0, y=0 } );
	}
	function Update_Std() : (patnum_moond_par, patnum_moond_smoke_par, patnum_moond_smoke_smoke, val_PowerUpEffectScalePar)
	{
		if( !Battle_Std.MoonDrive_IsActive() || Battle_Std.RoundisEnd() )
		{
			BMvTbl.SetFinalize();
			return;
		}
		
		local mvs = BMvTbl.GetMvStatus();
		local mvcount = mvs.MvCount;

		//範囲を決めてそこにパーティクルを出す
		//重なり判定の範囲
		//範囲が1Fで変化すると変なので毎フレーム寄っていくように
		local player = BtlPt.GetPlayerCharaData();
		if( player.push() )
		{
			local pl_pos = BMvTbl.GetPosition();
			local muki = BMvTbl.GetMuki();
			player.pop();
			
			BMvTbl.SetPosition( { x=pl_pos.x, y=pl_pos.y } );
			BMvTbl.SetMuki( ( muki == 1 )? _Direction_Right : _Direction_Left );
			
			if( mvcount%16 == 0 )
			{
				//デフォルト範囲
				local height = 360*128;//180*2=360
				if( player.push() )
				{
					local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kasanari, 0 ], flags=_HanteiFlag_Tool } );
					if( rc.sx != _Hantei_Error ) // 存在するか
					{
						height = abs(rc.sy * 128 * 2);
					}
					player.pop();
					
					height = height * val_PowerUpEffectScalePar/100; // キャラごとに倍率調整
					
					BMvTbl.SetLP(0,height);//子のLINEが参照するので開放中もここは更新する
				}
				
				//軽量化のためにパーティクル処理は開放中飛ばすように変更
				local gauge_status = BtlPt.Liberate_Get();
				// _dpn("gauge_status:"+gauge_status);
				if( !( gauge_status == _SpGaugeMode_Liberate || gauge_status == _SpGaugeMode_OverLiberate ) )
				{
					//範囲
					local pos = BMvEff.Random_PointRect( { sx = -110*128, sy = -height, ex = 110*128, ey = 0 } );
					
					//角度
					local angle = (-20 + BMvEff.Random_Limit(40) )/100.0;
					local vec = BMvEff.GetVector_FromAngle( { angle = angle, speed = 100 } );
					
					//パーティクル生成
					if( mvcount%32 == 0 )
					{
						local prio = ( BMvEff.Random_Limit(100) > 30 )? _CharaPrio_Parent_P1 : _CharaPrio_Far_Layer_5;
						local eff = BMvEff.CreateObject( { datatype=1, start_pat=patnum_moond_par, x=pos.x, y=pos.y } );
						if( eff.push() )
						{
							BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround|_ObjFlags_ParentMove|_ObjFlags_NoRenderOrder } );
							BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull } );
							
							BMvTbl.SetVector( { x=vec.x, y=vec.y, flags=_Vector_Normal } );
							BMvTbl.SetPrio( prio );
							
							eff.pop();
						}
					}
					
					local eff = BMvEff.CreateObject( { datatype=1, start_pat=patnum_moond_smoke_par, x=pos.x, y=pos.y } );
					if( eff.push() )
					{
						BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround|_ObjFlags_ParentMove|_ObjFlags_NoRenderOrder } );
						BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull } );
						
						BMvTbl.SetVector( { x=vec.x, y=vec.y, flags=_Vector_Normal } );
						BMvTbl.SetPrio( _CharaPrio_Parent_P1 );
						
						eff.pop();
					}
					
					local eff = BMvEff.CreateObject( { datatype=1, start_pat=patnum_moond_smoke_smoke, x=pos.x, y=pos.y } );
					if( eff.push() )
					{
						BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround|_ObjFlags_ParentMove|_ObjFlags_NoRenderOrder } );
						BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull } );
						
						BMvTbl.SetVector( { x=vec.x, y=vec.y, flags=_Vector_Normal } );
						BMvTbl.SetPrio( _CharaPrio_Parent_P1 );
						
						eff.pop();
					}
				}
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

}//ヒスコハ用
else
{//通常キャラ用

//通常キャラ用の軽量化バージョン	
Std_MoveTable.Mv_MoonDriveAuraEffect <-
{
	function Init_Std() : (patnum_moond_line)
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoRender|_ObjFlags_NoGround|_ObjFlags_ParentMove|_ObjFlags_ParentMuki } );
		BMvTbl.SetPrio( _CharaPrio_Parent_P1 );
		
		BMvTbl.SetLP(0,360*128);//Y　子が参照している
		
		BMvEff.CreateObject( { datatype=1, mvname="Mv_MoonDriveLineEffect", start_pat=patnum_moond_line, x=0, y=0 } );
	}
	function Update_Std() : (patnum_moond_par, patnum_moond_smoke_par, patnum_moond_smoke_smoke, val_PowerUpEffectScalePar)
	{
		local mvs = BMvTbl.GetMvStatus();
		local mvcount = mvs.MvCount;
		
		if( mvcount%4 == 0 )
		{
			if( !Battle_Std.MoonDrive_IsActive() || Battle_Std.RoundisEnd() )
			{
				BMvTbl.SetFinalize();
				return;
			}
			
			if( mvcount%16 == 0 )
			{
				//デフォルト範囲
				local height = 360*128;//180*2=360
				local player = BtlPt.GetPlayerCharaData();
				if( player.push() )
				{
					local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kasanari, 0 ], flags=_HanteiFlag_Tool } );
					if( rc.sx != _Hantei_Error ) // 存在するか
					{
						height = abs(rc.sy * 128 * 2);
					}
					player.pop();
					
					height = height * val_PowerUpEffectScalePar/100; // キャラごとに倍率調整
					
					BMvTbl.SetLP(0,height);//子のLINEが参照するので開放中もここは更新する
				}
				
				//軽量化のためにパーティクル処理は開放中飛ばすように変更
				local gauge_status = BtlPt.Liberate_Get();
				// _dpn("gauge_status:"+gauge_status);
				if( !( gauge_status == _SpGaugeMode_Liberate || gauge_status == _SpGaugeMode_OverLiberate ) )
				{
					//範囲
					local pos = BMvEff.Random_PointRect( { sx = -110*128, sy = -height, ex = 110*128, ey = 0 } );
					
					//角度
					local angle = (-20 + BMvEff.Random_Limit(40) )/100.0;
					local vec = BMvEff.GetVector_FromAngle( { angle = angle, speed = 100 } );
					
					//パーティクル生成
					if( mvcount%32 == 0 )
					{
						local prio = ( BMvEff.Random_Limit(100) > 30 )? _CharaPrio_Parent_P1 : _CharaPrio_Far_Layer_5;
						local eff = BMvEff.CreateObject( { datatype=1, start_pat=patnum_moond_par, x=pos.x, y=pos.y } );
						if( eff.push() )
						{
							BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround|_ObjFlags_ParentMove|_ObjFlags_NoRenderOrder } );
							BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull } );
							
							BMvTbl.SetVector( { x=vec.x, y=vec.y, flags=_Vector_Normal } );
							BMvTbl.SetPrio( prio );
							
							eff.pop();
						}
					}
					
					local eff = BMvEff.CreateObject( { datatype=1, start_pat=patnum_moond_smoke_par, x=pos.x, y=pos.y } );
					if( eff.push() )
					{
						BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround|_ObjFlags_ParentMove|_ObjFlags_NoRenderOrder } );
						BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull } );
						
						BMvTbl.SetVector( { x=vec.x, y=vec.y, flags=_Vector_Normal } );
						BMvTbl.SetPrio( _CharaPrio_Parent_P1 );
						
						eff.pop();
					}
					
					local eff = BMvEff.CreateObject( { datatype=1, start_pat=patnum_moond_smoke_smoke, x=pos.x, y=pos.y } );
					if( eff.push() )
					{
						BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround|_ObjFlags_ParentMove|_ObjFlags_NoRenderOrder } );
						BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull } );
						
						BMvTbl.SetVector( { x=vec.x, y=vec.y, flags=_Vector_Normal } );
						BMvTbl.SetPrio( _CharaPrio_Parent_P1 );
						
						eff.pop();
					}
				}
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}
	
}//通常キャラ用


//ムーンドライブフリーモーション
Std_MoveTable.Mv_MoonDrive_Modori <-
{
	function SetMoveable()
	{
		//行動可能で動けるようにする
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		BMvTbl.SetCommandLongDelay(1); //受付時間増加（先行入力用）
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0 } ); //無敵解除
	}
	function Init_Std()
	{
		//地上か空中かで分岐
		//超低空だったら地上にした方がいいので属性ではなく座標で分岐する
		local pos = BMvTbl.GetPosition(0);
		if( pos.y> -64 ) //地上
		{
			//211004:低空で出すと浮遊する不具合を修正（ロアで低ダJBJCJ236A>MDなど）
			// BMvTbl.SetPattern(147); //地上版のパターンにする…だと着地砂煙でないで変なので地面に埋めて着地にする
			BMvTbl.JumpFrameID(100);
			local pat_num = BMvTbl.GetMvStatus().DataPattern;
			local y_pos = ( pat_num == 148 )? 1 : 0; // 地面につける高さ。空中版だったら1にして地面に埋める
			BMvTbl.SetPosition( { y=y_pos } );
			Battle_Std.InitVector(); //地上なので保存ベクトルの再生はしないで初期化
		}
		else //空中
		{
			BMvTbl.JumpFrameID(100);
			local vec = BMvTbl.GetVector( { flags=_Vector_Keep } ); //保存ベクトルを呼び出す
			
			//そのままだと空中浮遊とかかっとびすぎるとかあると思うので制限をかける
			if( vec.x> 3000 ) vec.x=3000;
			if( vec.x< -3000 ) vec.x=-3000;

			if( vec.y> 3000 ) vec.y=3000;
			if( vec.y< -3000 ) vec.y=-3000;
			
			//addxは危ない気がするので使わない
			//チェインシフトを使うことでの減速による左右二択とか発生してしまうわけだがしょうがない
			vec.addx = 0;
			
			//addyは190以上、250以下にするする
			if( vec.addy <= 190 ) vec.addy=190;
			if( vec.addy >= 250 ) vec.addy=250;
			
			BMvTbl.SetVector( { x=vec.x, y=vec.y, addx=vec.addx, addy=vec.addy } );
			
			BMvTbl.SetVector( { x=0, y=0, addx=0, addy=0, flags=_Vector_Keep } ); // 保存していたものを破棄
			
			if( Def_Sys_AirMoonDriveSetJumpFlag )
			{
				Battle_Std.SetPP_JumpStartHeight(); // ジャンプしたときの高さを記憶
				Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_Jump );//ジャンプ扱い（のぼりMDからの崩し対策）
				Battle_Std.MoveCodeEx.AddFlag( 5, def_MC5_EnableAirToLandedShield );
			}
		}
		if( Def_Sys_MoonDriveNageMuteki )
		{
			BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254, muteki_dageX=254, muteki_nageX=254 } ); //無敵（すぐに解除はされる）
		}
		else
		{
			BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=254, muteki_dageX=254, muteki_nageX=0 } ); //無敵（すぐに解除はされる）
			Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動（投げを食らうので）
		}
		
		
		BMvTbl.SetLP(0,0); // 行動可能にしたかどうか
		
		if( Battle_Std.CheckEnemyisBound() )
		{
			if( BMvTbl.GetLP(0)==0 )
			{
				BMvTbl.SetLP(0,1); // 行動可能にした
				
				SetMoveable(); // 行動可能にして先行入力ありに
			}
		}
		else if( Def_Sys_MoonDriveModoriMutekiType == 1 )
		{
			/*
			//行動不能で無敵もないけど、ガードのみ可能＆シールドや必殺技でキャンセル可能
			BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
			BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );

			BMvTbl.SetAsStatusFlag( { special=_CancelFlag_Always, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );

			BMvTbl.SetCommandLongDelay(1); //受付時間増加（先行入力用）
			BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0 } ); //無敵解除
			*/
		}
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= Def_Sys_MoonDriveModoriFrame && BMvTbl.GetLP(0)==0 )
		{
			BMvTbl.SetLP(0,1); // 行動可能にした
			SetMoveable(); // 行動可能にして先行入力ありに
		}
		
		if( mvs.isLanding )
		{
			if( BMvTbl.GetLP(0)==0 )
			{
				//行動可能にしてなかったら一応やっておく（いらない気はするけど保険）
				BMvTbl.SetLP(0,1); // 行動可能にした
				
				SetMoveable(); // 行動可能にして先行入力ありに
			}
			BMvTbl.SetFinalize(256); //着地へ
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_MoonDrive_Modori_Land"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		if( !Battle_Std.MoveCodeEx.CheckFlag( 6, def_MC6_ThrowTechedMuteki ) ) // 投げで掴まれたときの無敵状態ではない
		{
			// _dpn("MD戻りの無敵解除のタイミング");
			BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0 } );
		}
	}
}

Std_MoveTable.Mv_MoonDrive_Modori_Land <-
{
	function Init_Std()
	{
		BMvTbl.SetPattern(21); //着地
		Battle_Std.InitVector();
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}	

	

Std_MoveTable.Mv_BlastWait <-	// パワーアップブラスト
{
	function Init_Std() : (val_BlastEffectYpos)
	{
		BMvTbl.SetMuki( _Direction_Auto );
		BMvTbl.SetPattern( def_PAT_BlastWait );
		Battle_Std.InitVector(); // ベクトル全てクリア
		local use_pat = "Eff_PowBlastIn";//
		local eff = BMvEff.CreateObject( { datatype=1, start_pat=use_pat, x=0, y=val_BlastEffectYpos*128 } );
		if( eff.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange|_ObjFlags_EraseParentDamage|_ObjFlags_NoGround } );
			eff.pop();
		}
		
		BMvEff.SetPlayerTimer( { muteki_dage=254, muteki_dageX=254, muteki_nage=254, muteki_nageX=254 } );
		Battle_Std.Reversal.CheckTime_DrawInfo(); // リバーサルなら文字表示
		
		Battle_Std.TypeSE_Play({ type="強制開放", flags=(1<<2) });
		
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_BlastLoop, frame=0, rest=2 } );
		
		Battle_Std.SetInstantCameraFocus( 25 );//ちょっとカメラ集中
		
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK );//LA用
		
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_BanMoonDriveCounter ); // ムーンドライブカウンター不可の行動
		
		BMvTbl.SetCounterHitFlag( { val=1, time=254, flag=_ClearFlag_ChangeMv } );//ハイカウンター
		
		BMvTbl.SetLP(0,0); // リバーサル行動でのタメ版かどうか
		if( BMvTbl.IsCpu() && BMvTbl.GetStickHold()==10 )
		{
			BMvTbl.SetLP(0,1); // リバーサル行動でのタメ版かどうか
		}
	}
	function Start_Std()
	{
		//Initでベクトルを入れてA+B+C+DのLAを出すと空中浮遊してしまうことがある
		BMvTbl.SetVector( { y=-4000, addy=700, flags=_Vector_Div } );
	}
	function FrameUpdate_Std()
	{
		if( Def_Sys_ChargeBlast )
		{
			local button_hold = ( BMvTbl.CheckButtonHold( (1<<0)|(1<<1)|(1<<2) ) >= 100 || BMvTbl.GetLP(0)==1 );
			local mvframe = BMvTbl.GetMvStatus().MvCount;
			local is_end = 0;//+3Fが発生
			//0〜14保証
			//15〜20 タメ可能
			//21〜24 タメ確定
			//25勝手に終了
			if( mvframe >= 25 )
			{
				is_end = 1;
			}
			else if( mvframe == 21 )
			{
				// _dpn("タメ確定");
				Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_GenFlag );//タメを記憶
				BMvEff.CreateObject( { datatype=1, start_pat=26, x=0, y=-200*128 } ); // ブローバックエフェクト呼び出し
				Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ExtendAction ); // タメたＭｖであることを保存
				Battle_Std.ExtendTiming();//空関数だけど一応通しておく
			}
			else if( mvframe >= 10 && mvframe <= 20 && !button_hold ) // タメ時間
			{
				is_end = 1;
			}

			if( is_end )
			{
				BMvTbl.SetFinalize(0);
			}
		}
		else
		{
			local mvs = BMvTbl.GetMvStatus();
			if( mvs.MvCount >= 10)//+3Fが発生
			{
				BMvTbl.SetFinalize(0);
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Blast" );
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0, muteki_nage=0, muteki_nageX=0 } );	
		
		if( !Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_DoujiEndYoyaku ) )
		{
			//同時押し予約以外で抜けた
			Battle_Std.CharaBattleActivity_Increment(90,"強制開放使用");
			
			Battle_Std.Achievement_Unlock(18);//【トロフィー】強制開放
			
			if( Def_BlastMoonAdd )
			{
				Battle_Std.Moon_AddValue(Def_BlastMoonAdd);//開放でムーン増加
			}
		}
	}	
}

Std_MoveTable.Mv_GuardBlastWait <-	// パワーアップブラスト
{
	function Init_Std() : (val_BlastEffectYpos)
	{
		BMvTbl.SetMuki( _Direction_Auto );
		BMvTbl.SetPattern( def_PAT_BlastWait );
		Battle_Std.InitVector(); // ベクトル全てクリア
		local use_pat = "Eff_GuardBlastIn";//
		local eff = BMvEff.CreateObject( { datatype=1, start_pat=use_pat, x=0, y=val_BlastEffectYpos*128 } );
		if( eff.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange|_ObjFlags_EraseParentDamage|_ObjFlags_NoGround } );
			eff.pop();
		}
		
		BMvEff.SetPlayerTimer( { muteki_dage=254, muteki_dageX=254, muteki_nage=254, muteki_nageX=254 } );

		// ガーキャンなのでリバーサル出るのはおかしいので表示しない
		// Battle_Std.Reversal.CheckTime_DrawInfo(); // リバーサルなら文字表示
		
		Battle_Std.TypeSE_Play({ type="強制開放", flags=(1<<2) });
		
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_BlastLoop, frame=0, rest=2 } );
		
		Battle_Std.SetInstantCameraFocus( 25 );//ちょっとカメラ集中
		
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK );//LA用
		
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_BanMoonDriveCounter ); // ムーンドライブカウンター不可の行動
		
		BMvTbl.SetCounterHitFlag( { val=1, time=254, flag=_ClearFlag_ChangeMv } );//ハイカウンター
	}
	function Start_Std()
	{
		//Initでベクトルを入れてA+B+C+DのLAを出すと空中浮遊してしまうことがある
		BMvTbl.SetVector( { y=-4000, addy=700, flags=_Vector_Div } );
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 25)
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Blast" );
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0, muteki_nage=0, muteki_nageX=0 } );	
		
		if( !Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_DoujiEndYoyaku ) )
		{
			//同時押し予約以外で抜けた
			Battle_Std.CharaBattleActivity_Increment(90,"強制開放使用");
			
			Battle_Std.Achievement_Unlock(18);//【トロフィー】強制開放
			
			if( Def_BlastMoonAdd )
			{
				Battle_Std.Moon_AddValue(Def_BlastMoonAdd);//開放でムーン増加
			}
		}
	}	
}

//効果発動中の管理オブジェクト
Std_MoveTable.Mv_MoonDriveGaugeObject <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPosition( { y=1024, flags=_Position_CaptureShift } );
	}
	function Update_Std()
	{
		BMvTbl.SetPattern(0);//消えないように
		
		//発動時間
		if( !Battle_Std.MoonDrive_IsActive() || Battle_Std.RoundisEnd() )
		{
			BMvTbl.SetFinalize();
			return;
		}

		//発動中の効果
		BMvEff.SetSpGauge( { value= Def_MoonDriveSpAdd } );
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

local pat_num_Eff_PowBlast = BMvEff.GetPatternNum( { datatype=1, pat="Eff_PowBlast" } );
local pat_num_Eff_PowBlastBig = BMvEff.GetPatternNum( { datatype=1, pat="Eff_PowBlastBig" } );
local pat_num_Eff_GuardBlast = BMvEff.GetPatternNum( { datatype=1, pat="Eff_GuardBlast" } );

// Mv名をシールドで参照している
Std_MoveTable.Mv_Blast <- 
{
	function Init_Std() : (pat_num_Eff_PowBlast, pat_num_Eff_PowBlastBig, pat_num_Eff_GuardBlast, val_BlastEffectYpos)
	{
		BMvTbl.SetPattern( def_PAT_BlastLoop );
		Battle_Std.InitVector(); // ベクトル全てクリア
		local is_guard_blast = (Def_Sys_GuardCancelSpark && BMvTbl.ChangeMv_GetMvName()=="Mv_GuardBlastWait")? 1 : 0;
		local is_charge_blast = ( BMvTbl.ChangeMv_GetMvName()=="Mv_BlastWait" && Battle_Std.ChangeMoveCodeEx_CheckFlag(1,def_MC1_GenFlag) )? 1 : 0;

		//強制開放の衝撃波のPATのみ変える（判定の大きさや屈シールドの有無だけが異なる）
		local use_atkpat = pat_num_Eff_PowBlast;
		
		if( is_guard_blast )
		{
			use_atkpat = pat_num_Eff_GuardBlast;
		}
		else if( is_charge_blast )
		{
			use_atkpat = pat_num_Eff_PowBlastBig;
		}

		BMvEff.CreateObject( { datatype=1, start_pat=use_atkpat, mvname="Mv_PowBlastShockwave", x=0, y=val_BlastEffectYpos*128 } );
		// BMvEff.SetPlayerTimer( { muteki_dage=254, muteki_dageX=254, muteki_nage=254, muteki_nageX=254 } );
		BMvEff.SetPlayerTimer( { muteki_dage=5, muteki_dageX=5, muteki_nage=5, muteki_nageX=5 } );
		
		//どういう性能にするか
		BMvTbl.SetLP(0,is_guard_blast);
		BMvTbl.SetLP(1,0);//衝撃のヒットで1、1のときは無敵になる
		
		Battle_Std.PassBeforeMoveCodeEx( 1, def_MC1_ExtendAction ); // タメ版フラグを引き継ぐ
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_BanMoonDriveCounter ); // ムーンドライブカウンター不可の行動
	}
	function FrameUpdate_Std()
	{
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_BlastFall, frame=0, rest=4 } );

		local mvs = BMvTbl.GetMvStatus();
		local is_guard_blast = BMvTbl.GetLP(0);
		local end_frame = (is_guard_blast)? 30 : 24;//42 : 36;
		if( mvs.MvCount >= end_frame)
		{
			BMvTbl.SetFinalize(0);
		}
		
		if( BMvTbl.GetLP(1)==1 ) //衝撃波がヒットしてる
		{
			BMvEff.SetPlayerTimer( { muteki_dage=60, muteki_dageX=60, muteki_nage=60, muteki_nageX=60 } );
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_BlastFall" );
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0, muteki_nage=0, muteki_nageX=0 } );	
	}	
}

Std_MoveTable.Mv_BlastFall <- 
{
	function Init_Std()
	{
		BMvTbl.SetPattern( def_PAT_BlastFall );
		Battle_Std.InitVector(); // ベクトル全てクリア
		BMvTbl.SetVector( { addy=250 } );
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0, muteki_nage=0, muteki_nageX=0 } );
		
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_BanMoonDriveCounter ); // ムーンドライブカウンター不可の行動
		
		// BMvTbl.SetLP(1,0);//衝撃のヒットで1、1のときは無敵になる
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding )
		{
			BMvTbl.SetFinalize(0);
		}

		if( BMvTbl.GetLP(1)==1 ) //衝撃波がヒットしてる
		{
			BMvEff.SetPlayerTimer( { muteki_dage=60, muteki_dageX=60, muteki_nage=60, muteki_nageX=60 } );
		}
	}	
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_BlastLand" );
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0, muteki_nage=0, muteki_nageX=0 } );	
	}
}

Std_MoveTable.Mv_BlastLand <- 
{
	function Init_Std()
	{
		Battle_Std.InitVector(); // ベクトル全てクリア
		BMvTbl.SetPattern(def_PAT_BlastLand);//行動不能な着地

		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_BanMoonDriveCounter ); // ムーンドライブカウンター不可の行動
	}
	function FrameUpdate_Std()
	{
		if( BMvTbl.GetLP(1)==1 ) //衝撃波がヒットしてる
		{
			BMvEff.SetPlayerTimer( { muteki_dage=10, muteki_dageX=10, muteki_nage=10, muteki_nageX=10 } );
		}
	}	
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0, muteki_nage=0, muteki_nageX=0 } );	
	}
}


// ブラストの衝撃波
// 被ダメで消えてしまうと相打ちで1Pと2Pに差がうまれる
// 当たるといい開放になる
Std_MoveTable.Mv_PowBlastShockwave <-
{
	function SendHisStatus() : (val_BlastEffectYpos, _TagCharaNo)
	{
		local hit_st = BMvTbl.GetLP(0);//開放衝撃波のヒット情報　1:ヒット 10:ペナヒット -1:空振り 100:伝え終わり
		if( hit_st != 100 ) // 伝え終わり前なら
		{
			BMvTbl.SetLP(0,100); // 伝え終わった
			
			local oya_is_sparkmv = ( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Parent } ) != 0 )? 1 : 0;
			
			local oya = BMvCore.GetParentCharaData();
			if( oya.push() )
			{
				local is_guard_blast = BMvTbl.GetLP(0);//発動時の開放がガード開放なのかどうかを取得
				local is_charge_balst = Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_ExtendAction ); // タメ版
				// _dpn("is_charge_balst:"+is_charge_balst);
				
				BMvEff.Liberate_Set(); // ヒート状態をセット（ヒートorブラッドヒートの見た目は自動で決まる）

				local gauge_status = BMvEff.Liberate_Get();
				local blood_heat = ( gauge_status == _SpGaugeMode_OverLiberate )? 1 : 0;
				_dpn("blood_heat:"+blood_heat);

				BMvEff.CreateObject( { mvname="Mv_Null_HeatMngObj" } );//ヒート状態管理
				
				Battle_Std.SetSpHosyoHosei( { type="VO" } ); //VOスカの保証補正
				
				if( _TagCharaNo == Def_ChrNo_Chr007 )
				{
					//自キャラと控えキャラに演出を入れる
					BtlPt.CallFunction( function(){
						BMvEff.CreateObject( { datatype=1, mvname="Mv_SparkHeal" } );
					});
				}
				else
				{
					BMvEff.CreateObject( { datatype=1, mvname="Mv_SparkHeal" } );
				}

				if( is_guard_blast )
				{
					local use_val = (hit_st==-1)? def_GuardVO_WhiffMinusValue : def_GuardVO_MinusValue;
					if( blood_heat ) use_val = use_val * def_BloodHeat_MinusValuePar / 100;
					BMvEff.Liberate_SetMinusValue( use_val ); // 減少速度
				}
				else
				{
					local use_val = (hit_st==-1)? def_NormalVO_WhiffMinusValue : def_NormalVO_MinusValue;
					if( blood_heat ) use_val = use_val * def_BloodHeat_MinusValuePar / 100;
					if( Def_Sys_ChargeBlast_MinusValuePar && is_charge_balst ) use_val = use_val * Def_Sys_ChargeBlast_MinusValuePar / 100;
					BMvEff.Liberate_SetMinusValue( use_val ); // 減少速度
				}
				
				//無事に移行できていたらゲージを消費する（KO後など移行しないことがある）
				if( BMvEff.Liberate_Get() != _LiberateType_None )
				{
					BMvEff.SetSpGauge( { mode=_SpGauge_UseAll } ); //ＳＰゲージ全消費
				}
				
				// 自分がKOしていたら
				// _SpGauge_UseAll だと1ドットぐらいしか減らないので最大値を引いて０にしている
				// ここにははいってこないだけど保険でいれている（開放の無敵が5Fで解放後に無敵が切れるはずなので）
				if( Battle_Std.PlayerisKO() )
				{
					BMvEff.SetSpGauge( { value=-def_SC_SpGauge_MaxEx, correct=0 } ); //ＳＰゲージ全消費
				}

				//ヒートorブラッドヒートを取得して演出調整
				local usePat = ( blood_heat )? "ExSparkClearFlash" : "SparkClearFlash";
				
				local eff = BMvEff.CreateObject( { datatype=1, start_pat=usePat, x=0, y=val_BlastEffectYpos*128 } );
				if( eff.push() )
				{
					BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround } );
					eff.pop();
				}
				
				//強制開放発動時のカットインを表示
				BMvEff.CreateObject( { mvname="Mv_BloodCutin" } );
				
				//親のMVが開放のままでヒットしてたら、親に伝えて無敵にする
				if( oya_is_sparkmv && hit_st != -1 )
				{
					BMvTbl.SetLP(1,1);//ヒットを伝えて無敵にする
					Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_GenFlag ); // 衝撃派ヒットを記憶
				}
				
				//ペナヒットは除外
				if( hit_st == 1 )
				{
					//ヒットでムーンを増やす
					if( Def_BlastHitMoonAdd )
					{
						Battle_Std.Moon_AddValue(Def_BlastHitMoonAdd);//開放ヒットでムーン増加
					}
				}
				
				oya.pop();
			}
		}
		else
		{
			//伝え済み
		}
	}
	function Init_Std()
	{
		BMvTbl.SetLP(0,0);//ヒット情報 1:ヒット -1:空振り 100:伝え終わり
		BMvTbl.SetLP(1,0);//相手の開放を終わらせる用
	}
	function HitInterrupt_Std()
	{
		if( Battle_Std.CheckDamageTiming( 1 ) )
		{
			local hit_st = 1;
			
			//ダウン追い打ちやコンボでのヒット、連続ガード中のヒットはヒットだけどデメリットあり
			if( BMvTbl.GetMvHitStatus().IsDown() ||
			!Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_SidouHitSkill ) ||
			Battle_Std.MoveCodeEx.CheckFlag( 3, def_MC3_BreakGuardAtk )
			)
			{
				hit_st = 10;
			}
			// _dpn("hit_st:"+hit_st);
			
			BMvTbl.SetLP(0,hit_st);//ヒット情報 1:ヒット 10:ペナルティヒット -1:空振り 100:伝え終わり
			SendHisStatus();
		}
	}
	function FrameUpdate_Std()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 900:
			if( BMvTbl.GetLP(0)==0 ) // ヒット情報を持ってない
			{
				//空振りが確定
				_dpn("空振り");
				BMvTbl.SetLP(0,-1);//ヒット情報 1:ヒット -1:空振り 100:伝え終わり
				SendHisStatus();
			}
			break;
		}
		if( BMvTbl.GetLP(0)==0 ) // ヒット情報を持っていない＝発生まで
		{
			if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) != 0 )
			{
				// プレイヤーが自分自身発生させた行動中
				local player = BMvCore.GetPlayerCharaData();
				if( player.push() )
				{
					local ppos = BMvTbl.GetPosition();
					player.pop();
					
					BMvTbl.SetPosition( { x=ppos.x } ); //Xのみキャラにくっつける
				}
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		SendHisStatus();
	}
}


//ヒート中は持続する
//ヒートが終わったらゲージ増加に制限をかける
//ブラッドヒート時は背景の色を変えるが、相手をKOすると演出およびこの処理は終わる
Std_MoveTable.Mv_Null_HeatMngObj <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
	}
	function Update_Std()
	{
		//プレイヤーの開放状態を見るときはパートナーを考慮しないとバグる
		local gauge_status = BtlPt.Liberate_Get();
		if( gauge_status == 0 || Battle_Std.RoundisEnd() )
		{
			BMvTbl.SetFinalize();
		}
		
		if( gauge_status == _SpGaugeMode_OverLiberate )
		{
			//ブラッドヒート中のBG色指定
			//ステージによって色を変えよう
			//BMvEff.SetBgSpeculer PAniに影響がない
			if( Def_Sys_BloodHeatAlignStageRedColor )
			{
				// _dpn("ステージ:"+BMvEff.BG_GetNum() );
				switch( BMvEff.BG_GetNum() )
				{
				case 7:
				case 12:
					//赤いステージなので抑えめにする
					BMvEff.SetBgColor( { color=0xFFCC8080 } );
					break;
				case 1:
				case 11:
					//ちょっと赤いステージなので抑えめにする
					BMvEff.SetBgColor( { color=0xFFEE8080 } );
					break;
				case 5:
				case 6:
				case 14:
					//赤みのほぼないステージなので赤要素を追加する
					BMvEff.SetBgSpeculer( { color=0xFF660000 } );
					BMvEff.SetBgColor( { color=0xFFFF8080 } );
					break;
				case 9:
				// case 16://PAniにSpeculerが乗らないので一旦除外
				// case 17://PAniにSpeculerが乗らないので一旦除外
					//赤みのちょっと少ないステージなので赤要素を追加する
					BMvEff.SetBgSpeculer( { color=0xFF330000 } );
					BMvEff.SetBgColor( { color=0xFFFF8080 } );
					break;
				default:
					BMvEff.SetBgColor( { color=0xFFFF8080 } );
					break;
				}
			}
			else
			{
				BMvEff.SetBgColor( { color=0xFFFF8080 } );
			}
		}
		
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			local gauge_status = BtlPt.Liberate_Get();
			
			enemy.pop();
			
			if( gauge_status != _SpGaugeMode_OverLiberate )
			{
				BMvEff.SetBgColor( { color=0xFFFFFFFF } );
				BMvEff.SetBgSpeculer( { color=0x00000000 } );
			}
		}
		else
		{
			BMvEff.SetBgColor( { color=0xFFFFFFFF } );
			BMvEff.SetBgSpeculer( { color=0x00000000 } );
		}
		
		local player = BtlPt.GetPlayerCharaData();
		if( player.push() )
		{
			BMvEff.SpGauge_SetLimit( { time=def_FL_EXSLimit_HeatEnd } ); //一定時間ゲージ増加に制限をかける
			player.pop();
		}
	}
}

local pat_num_KakuseiStart = BMvEff.GetPatternNum( { datatype=1, pat="KakuseiStart" } );

local pat_num_KakuseiCharaPat = (_ChrNo == Def_ChrNo_Chr017)? 160 : def_PAT_ChargeMotion; // マーリオゥだけ専用にした

//登場演出のパワーアップ
Std_MoveTable.Mv_StandbyBlastWait <- 
{
	function Init_Std() : (pat_num_KakuseiStart, pat_num_KakuseiCharaPat, val_KakuseiStartEffectYpos)
	{
		//時間停止して、不利にならないようにする
		BMvEff.SetStopTime( { time=90, bounderase=1 } );//ちょい長めに
		
		BMvTbl.SetPattern( pat_num_KakuseiCharaPat );//def_PAT_ChargeMotion マーリオゥだけ専用
		Battle_Std.InitVector(); // ベクトル全てクリア
		
		// _dpn("覚醒！");
		BMvEff.SpGauge_SetAwakens( 1 ); // 覚醒状態に

		Battle_Std.TypeSE_Play({ type="登場ピンチ" });
		
		BMvEff.CreateObject( { mvname="Mv_KakuseiCutin" } );
		BMvEff.CreateObject( { datatype=1, start_pat=pat_num_KakuseiStart, x=0, y=val_KakuseiStartEffectYpos*128 } );
		
		
		// 覚醒分だけ増えるバージョン
		local plus_value = def_SC_SpGauge_MaxEx-def_SC_SpGauge_Max;
		BMvEff.SetSpGauge( { value=plus_value, correct=0 } );// 覚醒分増加

		// ゲージ最大になるバージョン
		// BMvEff.SetSpGauge( { value=def_SC_SpGauge_MaxEx, correct=0 } );
		
		BSound.SE_Play( { type=_SeType_Normal, num=30 } );//発動SE
	}
	function Update_Std()
	{
		// 同時に覚醒すると2Pだけカメラ集中するのでタイミングを1F遅らせる
		local mvs = BMvTbl.GetMvStatus();
		// _dpn("mvs.MvCount:"+mvs.MvCount);
		if( mvs.MvCount == 1 )
		{
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				local emv = BMvTbl.GetMvName();
				enemy.pop();
				
				if( emv != "Mv_StandbyBlastWait" )
				{
					Battle_Std.SetInstantCameraFocus( 25 );//ちょっとカメラ集中
				}
				else if( BMvTbl.GetPlayerSide()==0 )
				{
					//同時覚醒
					_dpn("カメラ中央で少しアップ");
					local center_pos = BMvEff.GetCameraPosition( { x=0, y=0, flags=_GetPos_ViewCamera } ); //画面中央の地面
					BMvEff.SetCamera_Focus( { charapos=0, zoom=-0.1, time=[10,15,15], type_in=3, type_out=1, x=center_pos.x, y=center_pos.y } ); //カメラ集中
				}
			}
		}
	}
	function FrameUpdate_Std()
	{
		Battle_Std.CallSamePatLoopEndCache_FrameID( 100 ); // 定期的にループ抜け先のFrameIDを予約

		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 43)//21
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_StandbyBlastEnd" );
	}	
}

Std_MoveTable.Mv_StandbyBlastEnd <- 
{
	function Init_Std()
	{
		BMvEff.SetStopTime( { time=0, bounderase=1 } );
		BMvTbl.JumpFrameID(100);
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}	



Std_MoveTable.Mv_Null_CheckBandCHoujiCheck <-
{
	function Init_Std()
	{
		_dpn("Mv_Null_CheckBandCHoujiCheck Init");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
	}
	function FrameUpdate_Std()
	{
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			if( BMvTbl.CheckButtonHold( (1<<1)|(1<<2) ) >= 100 )
			{
				if( !Battle_Std.GS_CheckFlag( def_PP_GS_BandCTrueDoujiCheck ) )
				{
					_dpn("B+Cが正確におされた");
					Battle_Std.GS_AddFlag( def_PP_GS_BandCTrueDoujiCheck );
					// BMvEff.CreateObject( { mvname="Mv_Null_CheckBandCTrueDoujiCheck" } );//4Fぐらいしたら消えてフラグを消すだけ				
				}
			}
			player.pop();
		}
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount > 30 )
		{
			//あまり長く続いてもしょうがない
			BMvTbl.SetFinalize();
			return;
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		_dpn("Mv_Null_CheckBandCHoujiCheck End");
		Battle_Std.GS_DelFlag( def_PP_GS_BandCDoujiCheck );
		Battle_Std.GS_DelFlag( def_PP_GS_BandCTrueDoujiCheck );
	}
}

Std_MoveTable.Mv_Null_CheckBandCTrueDoujiCheck <-
{
	function Init_Std()
	{
		_dpn("Mv_Null_CheckBandCTrueDoujiCheck Init");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 30 ) //lastdelay分　ヒットストップ中は成功が続く
		{
			BMvTbl.SetFinalize();
			return;
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		_dpn("Mv_Null_CheckBandCTrueDoujiCheck End");
		Battle_Std.GS_DelFlag( def_PP_GS_BandCTrueDoujiCheck );
	}
}

// 空中ダッシュ
local frame_AirDash_B_NoCancel = chrparam.Get( { type="空中後ダッシュでかかり硬直", chrnum=_ChrNo } );
local vecYAdd_AirDash_F_LastUpdate = chrparam.Get( { type="空中ダッシュ抜け重力", chrnum=_ChrNo } );

local val_AirDash_AddAirJumpCount = chrparam.Get( { type="空中ダッシュでの２段ジャンプ消費", chrnum=_ChrNo } );

//空中ダッシュ硬直
local airDash_AirAtkFrameAr = chrparam.Get( { type="空中ダッシュ硬直", chrnum=_ChrNo } );

//-1ならデフォ値に書き換える
if( airDash_AirAtkFrameAr[0] == -1 ) airDash_AirAtkFrameAr[0] = 15;
if( airDash_AirAtkFrameAr[1] == -1 ) airDash_AirAtkFrameAr[1] = 15;
if( airDash_AirAtkFrameAr[2] == -1 ) airDash_AirAtkFrameAr[2] = 15;

local assault_AirAtkParam =
{
	min = airDash_AirAtkFrameAr[0],
	max = airDash_AirAtkFrameAr[0],
	a = airDash_AirAtkFrameAr[0],
	b = airDash_AirAtkFrameAr[1],
	c = airDash_AirAtkFrameAr[2],
}

//最小フレームを決める
if( assault_AirAtkParam.min > assault_AirAtkParam.b ) assault_AirAtkParam.min = assault_AirAtkParam.b
if( assault_AirAtkParam.min > assault_AirAtkParam.c ) assault_AirAtkParam.min = assault_AirAtkParam.c
// if( assault_AirAtkParam.min > assault_AirAtkParam.b ) assault_AirAtkParam.min = assault_AirAtkParam.b
// if( assault_AirAtkParam.min > assault_AirAtkParam.c ) assault_AirAtkParam.min = assault_AirAtkParam.c

//最大フレームを決める
if( assault_AirAtkParam.max < assault_AirAtkParam.b ) assault_AirAtkParam.max = assault_AirAtkParam.b
if( assault_AirAtkParam.max < assault_AirAtkParam.c ) assault_AirAtkParam.max = assault_AirAtkParam.c

/*
空中ダッシュ処理のメモ

9ABでダッシュができるので、9AB→9入れっぱで二段ジャンプがもれないようにする
9AB>(上要素以外)>9としたら二段ジャンプが出るようにする
　→Initで空ダ開始時に上要素があったらチェック処理開始
　　上要素がなくなるまで二段ジャンプを出せなくしている
　→上要素のあとのNが一定F続くと、二段ジャンプ不可の時間となるタイミングが少しある（再度上に入れれば出る）

9ABでダッシュ後、Mvに入ってから上要素が入ったかどうかを見る
Mvに入ってから上要素が入っていなかった場合、行動可能になった1Fだけ、二段ジャンプを不可にする
※そのフレームで上に入っていたら処理は通らないので、二段ジャンプが出しにくいとかはない

本当に二段ジャンプの操作なのか？のチェック
空中ダッシュのMVに入ってから、4F後以降に入っているスティック方向と違ったら二段ジャンプできないフラグは消す

//66 : 669が危ない。4F以内の入力で9ダッシュに置き換える
//96 : 同上。969が危ない。4F以内の入力で9ダッシュに置き換える
//99 : 9ダッシュ
//9AB : 9ダッシュ

9ダッシュの処理:一度Nか9以外に入れて、再度9に入れないと二段前ジャンプはできない。
99とかで9入れっぱなしで二段ジャンプになるのがダメだし、99NでNの部分で先行入力で漏れるのもダメ。

よくある例
9 1
N 4
6 3
9 8
6 1

9 1
9AB 1
9 17
8 2　行動可能になったところで8が入っているので二段ジャンプするところを、8は3F入れないと飛ばないようにした

9 1
9AB 1
9 17

9 6
9AB 7
8AB 2

9 1
9AB 12
9 11
8 1 行動可能になったところで8が入っているので二段ジャンプするところを、8は3F入れないと飛ばないようにした

9 1
9AB 1
6 1
9 入れっぱなし

9 4
9AB 1
6 1
9 16
0 ここで漏れやすかったのを修正

暴走アルク MD発動後
2C 6
0 6
8 6
4 3
4BC 4
0 44
8 4
6AB 2
6 4

9 1
9AB 10
8 2
7 6　7入れっぱなしなのに垂直ジャンプになる。8のときも前ジャンプになる。（優先度の問題なので、正しい方向をチェックするようにした）

9 4
9AB 2
8AB 1
7AB 1
4 9　4入れっぱなしなのにバックジャンプする（優先度の問題なので、正しい方向をチェックするようにした）

9:3
9A+B:9
B:1
N:4
8:入れっぱなしで前ジャンプになる（優先度の問題なので、正しい方向をチェックするようにした）

*/

Std_MoveTable.Mv_AirDash_F <-
{
	function SetMultiJumpCommandFail( time )
	{
		BMvTbl.SetCommandFailTime( { command=[def_CN_MultiJump_F,def_CN_MultiJump_N,def_CN_MultiJumpCancel_F,def_CN_MultiJumpCancel_N], time=time } );
	}
	function StickIsMultiJump()
	{
		return BMvTbl.CheckStickHold( (1<<7)|(1<<8)|(1<<9) );
	}
	function Init_Std() : (val_AirDash_AddAirJumpCount, val_AirDashEffectYpos)
	{
		BMvTbl.SetPattern( def_PAT_Mv_AirDash_F );
		Battle_Std.TypeSE_Play({ type="空中前ダッシュ" });
		
		// BMvTbl.SetVector( { x=1000, y=-200, addx=0, addy=0, flags=_Vector_Normal } );

		if( val_AirDash_AddAirJumpCount )
		{
			BMvTbl.AddAirJumpCount(val_AirDash_AddAirJumpCount);  //ジャンプ回数を加算し二段ジャンプした扱いにする
		}
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_PositiveAction ); // 行動コード(ポジティブ)を設定
		
		BMvTbl.AddAirCount( def_ACS_AirDash, 1 ); // 空中ダッシュを使った加算
		BMvTbl.AddAirCount( def_ACS_AllAirDash, 1 ); // 空中ダッシュを使った加算
		
		Battle_Std.SetDivKeepVector_AirDashMinHeight(def_POS_AirDashHoseiMinHeight,0); // 低すぎる場合上ベクトルをかける
		
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
		
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_Assault );
		
		Battle_Std.DrawAirDashPar( { x=0, y=val_AirDashEffectYpos } );

		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_AirAtkKirikaeTyudanCheckStart ); // ここから出したジャンプ攻撃は切り替え中段チェックする
		
		// 攻撃ではないけど、硬直を狩れたかどうかは知りたい情報なので例外的に入れる（前受身と同じイメージ）
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動

		//強すぎる慣性は緩和する
		local kansei_vec = BMvTbl.GetVector( { flags=_Vector_DivKeep } );
		// _dpn("kansei_vec.x:"+kansei_vec.x);
		if( kansei_vec.x > 700 ) kansei_vec.x = 700;
		BMvTbl.SetVector( { x=kansei_vec.x, flags=_Vector_DivKeep } );
		
		//空中ダッシュに入って、レバーがNになるまで二段ジャンプのコマンドを消す
		BCMDTbl.SetAirJump(0); //空中ダッシュ後は、一度レバーをNにしないと二段ジャンプできない制限をかける
		
		if( StickIsMultiJump() )
		{
			BMvTbl.SetLP(0,1);//チェックする
		}
		else
		{
			BMvTbl.SetLP(0,0);//チェックしない
		}
		
		BMvTbl.SetLP(2,0); //行動可能フラグ用
		
		//二段ジャンプ漏れのチェック用
		BMvTbl.SetLP(5,0); //9方向の空中ダッシュかどうかの記憶
		BMvTbl.SetLP(8,0); //9ダッシュのあと、8を入れたフレーム
	}
	function FrameUpdate_Std() : (assault_AirAtkParam)
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding )
		{
			BMvTbl.SetFinalize(0);
			return 0;
		}

		// アサルト硬直にキャラ差を付ける処理
		{
			local startup = 0;
			local mvcount = mvs.MvCount;
			
			//使うフレーム情報
			local airdamage_addframe = 0;
			
			if( Def_Sys_MinusFrame_AerialAirDashF )
			{
				airdamage_addframe = ( Battle_Std.CheckEnemyisAirDamage() )? -4 : 0;
				//MEMO:暴発対策で、9以下にならないように補正が必要そう
			}
			
			//相手が空中やられのときだけさらに軽減するので別変数にする
			local frames = {
				min = startup+assault_AirAtkParam.min+airdamage_addframe,
				max = startup+assault_AirAtkParam.max+airdamage_addframe,
				a = startup+assault_AirAtkParam.a+airdamage_addframe,
				b = startup+assault_AirAtkParam.b+airdamage_addframe,
				c = startup+assault_AirAtkParam.c+airdamage_addframe,
			}
			
			//9未満になってしまうと暴発しまくるので将来的には防がないとダメそう
			//もしくはコマンドバッファ初期化を入れる…なんだけど、流石に怖いし別の方法で直すべき
			if( Def_Sys_FixComboAirDashBouhatu && airdamage_addframe < 0 )
			{
				if( frames.min < 9 ) frames.min = 9;
				if( frames.a < 9 ) frames.a = 9;
				if( frames.b < 9 ) frames.b = 9;
				if( frames.c < 9 ) frames.c = 9;
			}
			
			// _dpn("frames min:"+frames.min+" max:"+frames.max+" BTN:"+frames.a+", "+frames.b+", "+frames.c );
			
			//レバーNにならないと二段ジャンプができないSetAirJumpを初期化する処理
			{
				local stick_9 = BMvTbl.CheckStickHold( (1<<9) );
				//6ダッシュなのか9ダッシュなのかを操作ミスも考慮して3F以内の入力でチェック
				//最後に入っているのが9なら9をチェックするし、6ならチェックしない
				if( mvcount <= 3 )
				{
					//3Fまでに9ダッシュかどうか決める
					if( stick_9 )
					{
						// _dpn("9ダッシュのチェックを行う");
						BMvTbl.SetLP(5,1); //1:9ダッシュ
						BCMDTbl.SetAirJump(0); //レバーNにしないと二段ジャンプできない制限をかける
					}
					else
					{
						BMvTbl.SetLP(5,0); //1:9ダッシュ
						BCMDTbl.SetAirJump(1);//二段ジャンプ可能に戻す
					}
				}
				else
				{
					//4F以降
					//最初の数Fで9ダッシュかどうか決めて、以降は9ダッシュのときに「N→^」になるまで二段ジャンプを不可にする
					//Nに入れなかった場合も、8の二段ジャンプを長めに入れると二段ジャンプできる(7は1Fで可)
					local air_dash_command_9_status = BMvTbl.GetLP(5);//1:9ダッシュ 5:Nを入れた 10:再度上要素を入れた
					if( air_dash_command_9_status == 1 )//9ダッシュかどうか
					{
						SetMultiJumpCommandFail(1);// 先行入力でもれないようにする
						if( BMvTbl.CheckStickHold( (1<<0) ) )
						{
							BMvTbl.SetLP(5,5); //9ダッシュのあとに9以外を入れた
							BCMDTbl.SetAirJump(1);//二段ジャンプ可能に戻す　※やらないでも入っているはずだけど
						}
						else if( !BMvTbl.CheckStickHold( (1<<9) ) )
						{
							//時間を加算、これが
							if( BMvTbl.CheckStickHold( (1<<8) ) )
							{
								//9ダッシュのあと8が一瞬入ってしまう操作ミスはあるので、8が一定F入っていないとダメにする
								local frame_8 = BMvTbl.AddLP(8,1); //9ダッシュのあと、8を入れたフレーム
								if( frame_8 >= 4 )
								{
									// _dpn("8を長押しした");
									SetMultiJumpCommandFail(0);
									BMvTbl.SetLP(5,10); //1:9ダッシュ 5:Nを入れた 10:再度上要素を入れた
									BCMDTbl.SetAirJump(1);//二段ジャンプ可能に戻す
								}
							}
							else
							{
								BMvTbl.SetLP(5,5); //9ダッシュのあとに9と8以外を入れた
								BCMDTbl.SetAirJump(1);//二段ジャンプ可能に戻す
							}
						}
					}
					else if( air_dash_command_9_status == 5 )//9ダッシュのあとに9と8以外を入れた
					{
						if( StickIsMultiJump() )
						{
							SetMultiJumpCommandFail(0);
							BMvTbl.SetLP(5,10); //1:9ダッシュ 5:Nを入れた 10:再度上要素を入れた
						}
						else
						{
							// _dpn("もれないで");
							SetMultiJumpCommandFail(1);
						}
					}
				}
			}
			
			if( mvcount >= frames.min && mvcount <= frames.max )
			{
				// >= にすると二段ジャンプが漏れまくるがジャンプ攻撃出しやすくするためにアリにする必要あり
				// _dp("\n o:"+mvcount);
				BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
				
				if( Def_Sys_AirDashAirGuard == 0 )
				{
					BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=254, flag=_ClearFlag_ChangeMv } ); // 行動可能だけどガード不能にする
				}
				BMvTbl.SetCommandLongDelay(1); //受付時間増加（先行入力用）
				
				//このタイミングはレバーが本当に上に入っていない場合は二段ジャンプ不可にする
				//ここのチェックは他より厳密にする
				//969と入れて空中ダッシュしたあと、ニュートラルで待機していると漏れるため
				//二段ジャンプの優先度が987なので、先行入力で987が入っていると、最後入れっぱなしにしているスティックに関わらず優先度順で出るので色々弾く
				if( !StickIsMultiJump() ) //789
				{
					//全部禁止
					BMvTbl.SetCommandFailTime( { command=[def_CN_MultiJump_F,def_CN_MultiJump_N,def_CN_MultiJump_B,def_CN_MultiJumpCancel_F,def_CN_MultiJumpCancel_N,def_CN_MultiJumpCancel_B], time=1 } );
				}
				else if( BMvTbl.CheckStickHold( (1<<7) ) )
				{
					// _dpn("7以外は出ちゃダメ");
					SetMultiJumpCommandFail(1);// 先行入力でもれないようにする
					BMvTbl.SetCommandFailTime( { command=[def_CN_MultiJump_F,def_CN_MultiJump_N,def_CN_MultiJumpCancel_F,def_CN_MultiJumpCancel_N], time=1 } );
				}
				else if( BMvTbl.CheckStickHold( (1<<8) ) )
				{
					// _dpn("9以外は出ちゃダメ");
					BMvTbl.SetCommandFailTime( { command=[def_CN_MultiJump_F,def_CN_MultiJump_B,def_CN_MultiJumpCancel_F,def_CN_MultiJumpCancel_B], time=1 } );
				}
			}
			
			//ジャンプ攻撃が出せるフレームをフラグで管理
			if( mvcount >= frames.a )
			{
				if( !Battle_Std.LP_CheckFlag(2,1) )
				{
					// _dp("\n a:"+mvcount);
				}
				Battle_Std.LP_AddFlag(2,1);
			}
			if( mvcount >= frames.b )
			{
				if( !Battle_Std.LP_CheckFlag(2,2) )
				{
					// _dp("\n b:"+mvcount);
				}
				Battle_Std.LP_AddFlag(2,2);
			}
			if( mvcount >= frames.c )
			{
				if( !Battle_Std.LP_CheckFlag(2,4) )
				{
					// _dp("\n c:"+mvcount);
				}
				Battle_Std.LP_AddFlag(2,4);
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_AirDashLand_F" );
	}
	function LastUpdate_Std() : (vecYAdd_AirDash_F_LastUpdate, val_AirDash_F_GravityTypeTbl)
	{
		if( !BMvTbl.FromFinalize() )
		{
			if( val_AirDash_F_GravityTypeTbl.type == 0 )//普通空中ダッシュ
			{
				local vec = BMvTbl.GetVector( { flags=_Vector_Normal } );
				if( vec.addy <= vecYAdd_AirDash_F_LastUpdate )
				{
					BMvTbl.SetVector( { addy=vecYAdd_AirDash_F_LastUpdate, flags=_Vector_Normal } );
				}
				if( vec.x >= 2500 )
				{
					BMvTbl.SetVector( { x=2500, flags=_Vector_Normal } );
				}
				BMvTbl.SetVector_MaxX( 0 ); //XMAXを初期化
				BMvTbl.SetVector( { addx=0, flags=_Vector_Normal } );
			}
			else//水平空中ダッシュ
			{
				local mvCount = BMvTbl.GetMvStatus().MvCount;
				local eff = BMvEff.CreateObject( { mvname="Mv_Null_SetAirDashGravity" } );
				if( eff.push() )
				{
					BMvTbl.SetLP(0,mvCount);//空中ダッシュ何フレーム経過したか
					
					eff.pop();
				}
			}
		}
	}
}

//MEMO:重力に対しての保険処理がないのでちょっと危ない
Std_MoveTable.Mv_Null_SetAirDashGravity <- 
{
	function Init_Std()
	{
		// BMvTbl.SetLP(0,0);//空中ダッシュ何フレーム経過したか
		
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_EraseParentDamage } );//親のダメージでも消える
		BMvEff.SetExist( { level = _Exist_NoHantei } );
	}
	function FrameUpdate_Std() : (vecYAdd_AirDash_F_LastUpdate, val_AirDash_F_GravityTypeTbl)
	{
		local mvs = BMvTbl.GetMvStatus();
		local afterAirDashFrame = mvs.MvCount + BMvTbl.GetLP(0);
		local player = BMvCore.GetPlayerCharaData();
		
		if( player.push() )
		{
			local isNoYSetVectorAirAtk = Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_NoYSetVectorAirAtk );//
			local pl_isbound = Battle_Std.CheckPlayerisBound();//やられ時は処理をしない
			local pl_mvname = BMvTbl.GetMvName();

			//着地したあとにこれが残っているのはどうかと思うので処理を追加
			local pl_island = 0;
			if( BMvTbl.GetMvStatus().isLanding ) pl_island = 1;
			if( BMvTbl.GetPosition().y >= 0 && BCMDTbl.CheckPosState(_PosState_Ground) ) pl_island = 1;
			// _dpn("pl_island:"+pl_island);
			//Mv_Atk_AirA Mv_Atk_AirB Mv_Atk_AirC
			//Mv_Atk_Air2A Mv_Atk_Air2B Mv_Atk_Air2C
			
			local use_AirDash_F_GravityType = val_AirDash_F_GravityTypeTbl.min;//デフォルトはTblを参照していない
			
			//ジャンプ攻撃のABCどれなのかの検知 TODO:チェック処理が人力なので直したい
			//ここに入るのは今の所セイバーのみ
			if( pl_mvname.find("Mv_Atk_Air") == 0 )//ジャンプ攻撃っぽいMVのときはmin以外に分岐
			{
				local wlen = pl_mvname.len()-1;//文字数-1で最後の文字をチェック
				
				// _dpn("pl_mvname.len():"+wlen );
				if( pl_mvname.find("A",wlen) == wlen )
				{
					// _dpn("A");
					use_AirDash_F_GravityType = val_AirDash_F_GravityTypeTbl.a;
				}
				else if( pl_mvname.find("B",wlen) == wlen )
				{
					// _dpn("B");
					use_AirDash_F_GravityType = val_AirDash_F_GravityTypeTbl.b;
				}
				else if( pl_mvname.find("C",wlen) == wlen )
				{
					// _dpn("C");
					use_AirDash_F_GravityType = val_AirDash_F_GravityTypeTbl.c;
				}
				else
				{
					//それ以外はminになる
				}
			}
			
			// _dpn("use_AirDash_F_GravityType:"+use_AirDash_F_GravityType+" mv:"+pl_mvname);
			
			if( isNoYSetVectorAirAtk && !pl_isbound && !pl_island )
			{
				if( afterAirDashFrame >= use_AirDash_F_GravityType )
				{
					//色んな行動で入ってきてしまう
					//普通の空中ダッシュの場合は、重力を入れた後に次のMvに変化するのでいいけど、こっちは違う
					//空中ダッシュ→JA（途中で重力）
					local vec = BMvTbl.GetVector( { flags=_Vector_Normal } );
					if( vec.addy < vecYAdd_AirDash_F_LastUpdate )
					{
						BMvTbl.SetVector( { addy=vecYAdd_AirDash_F_LastUpdate, flags=_Vector_Normal } );
					}
					if( vec.x >= 2500 )
					{
						BMvTbl.SetVector( { x=2500, flags=_Vector_Normal } );
					}
					BMvTbl.SetVector_MaxX( 0 ); //XMAXを初期化
					BMvTbl.SetVector( { addx=0, flags=_Vector_Normal } );
				}
			}
			player.pop();
			
			//ベクトル無効のジャンプ攻撃以外orやられなら抜ける
			if( !isNoYSetVectorAirAtk || pl_isbound || pl_island )
			{
				//おわり
				BMvTbl.SetFinalize();
				return;
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

// 空中前ダッシュと空中後ろダッシュの着地
Std_MoveTable.Mv_AirDashLand_F <-
{
	function Init_Std()
	{
		Battle_Std.InitCharaVector();
		// 着地硬直を設定（8F硬直→以降行動可能）
		BMvTbl.SetMoveableFlagEx( { move=0, timeA=def_FL_AirDash_LandRecovery, timeB=64, flag=_ClearFlag_ChangeMv } );
		
		// 攻撃ではないけど、硬直を狩れたかどうかは知りたい情報なので例外的に入れる（前受身と同じイメージ）
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

Std_MoveTable.Mv_AirDash_B <-
{
	function SetMultiJumpCommandFail( time )
	{
		BMvTbl.SetCommandFailTime( { command=[def_CN_MultiJump_F,def_CN_MultiJump_N,def_CN_MultiJump_B,def_CN_MultiJumpCancel_F,def_CN_MultiJumpCancel_N,def_CN_MultiJumpCancel_B], time=time } );
	}
	function StickIsMultiJump()
	{
		return BMvTbl.CheckStickHold( (1<<7)|(1<<8)|(1<<9) );
	}
	function Init_Std() : (val_AirDash_AddAirJumpCount, val_AirDashEffectYpos)
	{
		BMvTbl.SetPattern( def_PAT_Mv_AirDash_B );
		// Battle_Std.TypeSE_Play({ type="アサルト" });

		if( val_AirDash_AddAirJumpCount )
		{
			BMvTbl.AddAirJumpCount(val_AirDash_AddAirJumpCount);  //ジャンプ回数を加算し二段ジャンプした扱いにする
		}
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_PositiveAction ); // 行動コード(ポジティブ)を設定
		
		BMvTbl.AddAirCount( def_ACS_AirBackDash, 1 ); // 空中ダッシュを使った加算
		BMvTbl.AddAirCount( def_ACS_AllAirDash, 1 ); // 空中ダッシュを使った加算
		
		Battle_Std.SetDivKeepVector_AirDashMinHeight(def_POS_AirDashHoseiMinHeight,0); // 低すぎる場合上ベクトルをかける
		
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_AirAtkKirikaeTyudanCheckStart ); // ここから出したジャンプ攻撃は切り替え中段チェックする
		
		// 攻撃ではないけど、硬直を狩れたかどうかは知りたい情報なので例外的に入れる（前受身と同じイメージ）
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
		
		// BMvTbl.SetVector( { x=-1280, addx=0, y=0, addy=0, flags=_Vector_Normal } );
		Battle_Std.TypeSE_Play({ type="空中後ろダッシュ" });
		
		Battle_Std.DrawAirDashPar( { x=0, y=val_AirDashEffectYpos } );
		
		//空中ダッシュに入って、レバーがNになるまで二段ジャンプのコマンドを消す
		
		if( StickIsMultiJump() )
		{
			BMvTbl.SetLP(0,1);//チェックする
		}
		else
		{
			BMvTbl.SetLP(0,0);//チェックしない
		}
	}
	function FrameUpdate_Std() : (frame_AirDash_B_NoCancel)
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding )
		{
			BMvTbl.SetFinalize(0);
			return 0;
		}
		switch( BMvTbl.GetLP(0) )
		{
		case 1:
			if( !StickIsMultiJump() )
			{
				SetMultiJumpCommandFail(10);
				BMvTbl.SetLP(0,10);
			}
			break;
		case 10:
			break;
		}
		
		
		
		if( mvs.MvCount == 3 )
		{
			// BMvTbl.SetVector( { x=-1800, addx=0, y=-2048, addy=200, flags=_Vector_Normal } );
		}
		
		if( mvs.MvCount >= frame_AirDash_B_NoCancel && BCMDTbl.CheckCancel(_SkillType_None )==0 )
		{
			_dp1p("\n 行動可能にしてコマンドディレイ追加");
			BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
			if( Def_Sys_AirDashAirGuard == 0 )
			{
				BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=254, flag=_ClearFlag_ChangeMv } ); // ガード不可に
			}
			BMvTbl.SetCommandLongDelay(1); //受付時間増加（先行入力用）
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_AirDashLand_F" );
	}
	function LastUpdate_Std() : (vecYAdd_AirDash_F_LastUpdate)
	{
		if( !BMvTbl.FromFinalize() )
		{
			local vec = BMvTbl.GetVector( { flags=_Vector_Normal } );
			if( vec.addy <= vecYAdd_AirDash_F_LastUpdate )
			{
				BMvTbl.SetVector( { addy=vecYAdd_AirDash_F_LastUpdate, flags=_Vector_Normal } );
			}
			BMvTbl.SetVector_MaxX( 0 ); //XMAXを初期化
			BMvTbl.SetVector( { addx=0, flags=_Vector_Normal } );
		}
	}
}












Std_MoveTable.Mv_ImpactCamera <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		
		// BMvTbl.SetLP(0,0); // 生成時に決まる何フレームのアップかどうか
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount>60 ) // 時間で適当に消滅
		{
			BMvTbl.SetFinalize(0);
		}
		else if( Battle_Std.CheckPlayerisDamage() || !Battle_Std.CheckEnemyisDamage() ) // 相打ちか相殺の時はカメラ寄せない
		{
			BMvEff.SetCamera_Focus( { time=[0,0,0] } );
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_AerialLaunchRect <-
{
	function Init_Std()
	{
		BtlPl.SetPos_MarkingEnemy();//敵の座標に
	}
	function HitInterrupt_Std()
	{
		if( Battle_Std.CheckDamageTiming() )
		{
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				//XXX:しばらく無敵にして飛び道具とかあたらないように（エリアルの浮かせを確定させるため）
				//MEMO:本体以外に無敵、というのが欲しいかな？
				BMvEff.SetPlayerTimer( { muteki_dage=6 } ); //無敵、フレームはいい加減。XXX:JAの発生次第では危ないか
				
				enemy.pop();
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//XXX:エリアルのときに生成。ジャンプ攻撃的なときに有効
//エリアルで受け身をとられにくくする
//その代わり消せない上昇ベクトルがキャラにかかる
Std_MoveTable.Mv_Null_AerialStatusMng <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		
		//地上の繋ぎのメリットをあげるため、赤ダメの割合を増える調整がしたい
		// BMvEff.ComboView_Set( { val=90, type=1 } );

		local nowComboPoint = BMvTbl.ComboPoint_Calc( { num=0 } );//今の値
		BMvTbl.SetLP(0,nowComboPoint);//記憶
		BMvTbl.SetLP(1,0)//CPボーナスをやったかどうか
		
		local aerialCPbonus = Def_Sys_AerialComboComboPointHosei;
		if( Battle_Std.EnemyDamageFlag_Check( def_DF_SkillVecAdded ) )
		{
			if( aerialCPbonus == 2 )
			{
				_dpn("必殺技ボーナスのあとなのでなし");
				aerialCPbonus = 0;
			}
		}
		
		if( aerialCPbonus )
		{
			BMvTbl.SetLP(1,1)//CPボーナスをやったかどうか
			
			local min_cp = 15;//20近いと、3C>ためJCが補正キツくても確定する
			if( nowComboPoint < min_cp )
			{
				_dpn("nowComboPoint:"+nowComboPoint);
				BMvTbl.ComboPoint_Calc( { num=-10000 } );//クリア
				BMvTbl.ComboPoint_Calc( { num=min_cp } );//最低保証CP
			}
		}
		Battle_Std.GS_AddFlag( def_PP_GS_AerialStatus );
		// BMvEff.PcAfterImage_Set( { type=0, range=12, delay=3, color=0xFFAAAAFF, blendmode=1 } );
		BMvEff.PcAfterImage_Set( {  type=0, range=12, delay=4, color=0x8FAAAAFF, blendmode=0 } );
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			local isAirAtk = Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_AtkJump );
			local isJump = Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_Jump );
			local isAir = BCMDTbl.CheckPosState( _PosState_Air );
			local isAirDash = Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_Assault );
			
			local isAerialKeep = ( isAirAtk || isJump || isAirDash );
			
			if( isAir && !isAerialKeep )
			{
				//上昇ベクトル残して抜ける
				//この処理だとMvInitのベクトル初期化はきかない（Init後に入ってくる）
				// BMvTbl.SetVector( { y=-1500, addy=150, flags=_Vector_Div } );
			}
			
			/*
			//序盤は無理やり浮く
			if( isAir )
			{
				local frame = mvs.MvCount;
				if( frame < 15 )
				{
					local par = 100 - (frame * 100 / 15);
					local yvec = (-2000 * par / 100)-1000;
					_dpn("par:"+par+" yvec:"+yvec );
					
					BMvTbl.SetVector( { y=yvec, addy=150, flags=_Vector_Div } );
				}
			}
			*/
			
			player.pop();
			
			if( !isAir ) 
			{
				//地上になったら絶対おわり
				BMvTbl.SetFinalize();
			}
			if( isAerialKeep )
			{
				//ジャンプ攻撃、ジャンプ、空中ダッシュ中は有効
			}
			else
			{
				//それ以外なら終わり
				BMvTbl.SetFinalize();
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		// if( Def_Sys_AerialComboComboPointHosei )
		if( BMvTbl.GetLP(1)==1 )//CPボーナスをやったかどうか
		{
			local startComboPoint = BMvTbl.GetLP(0);
			local nowComboPoint = BMvTbl.ComboPoint_Calc( { num=0 } );//今の値
			//開始前の方がCPきつかったら開始前のにする
			if( nowComboPoint > startComboPoint )
			{
				BMvTbl.ComboPoint_Calc( { num=-10000 } );//クリア
				BMvTbl.ComboPoint_Calc( { num=startComboPoint } );
			}
			// Battle_Std.ComboPoint_Multi( 50 );//戻して半分にする
		}
		Battle_Std.GS_DelFlag( def_PP_GS_AerialStatus );
		local is_bc_skill = 0;
		local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		if( player.push() )
		{
			is_bc_skill = Battle_Std.MoveCode.CheckFlag( def_MC_BCAction );
			
			player.pop();
		}
		if( !is_bc_skill )
		{
			BMvEff.PcAfterImage_Clear();
		}
	}
}

local pat_num_AerialLaunchRect = BMvEff.GetPatternNum( { datatype=0, pat="AerialLaunchRect" } );

//浮かせからのジャンプ
//いろんな攻撃でカメラズームのあと、このジャンプが呼ばれる
Std_MoveTable.Mv_Atk_Aerial_AddJump <-
{
	atkflags = def_AtkTmplFlags_Enable,
	function Init_Std() : (pat_num_AerialLaunchRect)
	{
		BMvTbl.SetPattern(def_PAT_Mv_AirDash_V);
		
		//MD中は受け身不能を伸ばす
		local is_moon_drive = Battle_Std.MoonDrive_IsActive();
		local eff = BMvEff.CreateObject( { start_pat=pat_num_AerialLaunchRect, mvname="Mv_AerialLaunchRect" } );
		if( eff.push() )
		{
			if( is_moon_drive )
			{
				BMvTbl.JumpFrameID(200);
			}
			eff.pop();
		}
		BMvEff.CreateObject( { mvname="Mv_Null_AerialStatusMng" } );//これで…
		if( Def_Sys_AerialJump_NoUseJumpCanceled == 0 )
		{
			// エリアルジャンプはこのフラグをたてない（ヒットストップ-1Fがきついので）
			Battle_Std.EnemyDamageFlag_Add( def_DF_JumpCanseled );
		}
		Battle_Std.EnemyDamageFlag_Add( def_DF_AerialJumpCanseled );
		
		//二段ジャンプを消費したコンボ中ならさらにフラグをたてる
		if( Battle_Std.EnemyDamageFlag_Check( def_DF_MultiJumpCanceled ) )
		{
			Battle_Std.EnemyDamageFlag_Add( def_DF_AllJumpCancel_UsedMultiJumpCancel );
		}
		
		BMvTbl.SetMuki( _Direction_Auto ); // 相手の方を向く
		
		BMvTbl.SetVector_MaxX( 0 ); //XMAXを初期化
		// BMvTbl.SetVector( { x=1700, y=-5200, addx=0, addy=200 } );
		BMvTbl.SetVector( { x=1500, y=-5200, addx=0, addy=200 } );
		
		BSound.SE_Play( { type=_SeType_Normal, num=185 } ); // 高速移動音
		BMvEff.CreateObject( { datatype=1, start_pat=35 } );//ジャンプ煙
		
		Battle_Std.DrawAirDashPar( { x=0, y=-200 } );
		
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動不能にする
		// BMvTbl.SetCommandLongDelay(2); //受付時間増加（先行入力用）
		
		Battle_Std.SetPP_JumpStartHeight(); // ジャンプしたときの高さを記憶
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_Jump );
		Battle_Std.MoveCodeEx.AddFlag( 5, def_MC5_EnableAirToLandedShield );
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount == 5 )
		{
			BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
			BMvTbl.SetCommandLongDelay(1); //受付時間増加（先行入力用）
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable("Mv_Neutral");
	}
	function LastUpdate_Std()
	{
		BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Erase  } );
	}
}


/*
ラストアーク仕様

A+B+C+D
Mv_LastArcBlastWait　※ゲージ消費＆記憶LP0
	Mv_LastArc_Atk
	Mv_LastArc_AtkHit
	Mv_LastArc_PreHit : LP0で残量を判断

BH中D
Mv_LastArc　※ゲージ消費＆記憶LP0
	Mv_LastArc_PreHit : LP0で残量を判断

*/


// ラストアーク攻撃
Std_MoveTable.Mv_LastArcBlastWait <- 
{
	function Init_Std()
	{
		BMvTbl.SetMuki( _Direction_Auto );
		BMvTbl.SetPattern( 150 );
		Battle_Std.InitVector(); // ベクトル全てクリア
		BMvTbl.SetVector( { y=0, flags=_Vector_Div } );
		BMvTbl.SetPosition( { y=0 } ); // かならず地面からでる。同時押しの都合でちょっと浮いてることがある
		
		BMvTbl.SetLP(0,0);//
		local gauge_par = BMvEff.Liberate_GetTimeValue();
		BMvTbl.SetLP(0,gauge_par);

		//IWEの処理をもってきた
		BMvEff.SpGauge_SetLimit( { time=def_FL_EXSLimit_IWEAtk } ); //一定時間ゲージ増加に制限をかける
		
		Battle_Std.Init_ExistAtkSkill(); //SPゲージ消費・カットイン呼び出し
		// BMvEff.CutInProc_Set({ time=[10,999,10], cutin_mv="Mv_CutinGrp",erasetype=1, bgtype=0 }); //カットイングラフィックとか呼び
		Battle_Std.MoveCode.AddFlag( def_MC_Skill|def_MC_EXAction ); // 行動コード(必殺技)を設定
		
		BMvEff.Liberate_End(); //開放中なら終了
		
		//エフェクト表示
		local eff = BMvEff.CreateObject( { datatype=1, start_pat=400, x=0, y=-200*128 } );
		if( eff.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange|_ObjFlags_EraseParentDamage|_ObjFlags_NoGround } );
			eff.pop();
		}
		
		BMvEff.SetPlayerTimer( { muteki_dage=254, muteki_dageX=254, muteki_nage=254, muteki_nageX=254 } );
		Battle_Std.Reversal.CheckTime_DrawInfo(); // リバーサルなら文字表示
		//Battle_Std.TypeSE_Play({ type="バウンドブラスト" });
		
		//演出テスト
		BSound.SE_Play( { type=_SeType_Normal, num=31 } );
		
		Battle_Std.TypeSE_Play({ type="ラストアーク攻撃", flags=(1<<2) });
		
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_BanMoonDriveCounter ); // ムーンドライブカウンター不可の行動
		
		BMvTbl.SetCounterHitFlag( { val=1, time=254, flag=_ClearFlag_ChangeMv } );//行動中ハイカウンター
		
		if( !Def_Sys_ComboRateSetStartTiming ) BMvTbl.AddComboRate(); // コンボレート加算
		
		//def_PAT_LastArc_Atkのキャッシュ予約
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_LastArc_Atk, frame=0, rest=30 } );
	}
	function Start_Std()
	{
		if( Def_Sys_ComboRateSetStartTiming ) BMvTbl.AddComboRate(); // コンボレート加算
	}
	function FrameUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=2, muteki_dageX=2, muteki_nage=2, muteki_nageX=2 } );
		
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 42)//発生遅めでコンボ入れにくく？そもそもキャンセル不能な方がいいかも…
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_LastArc_Atk" );
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0, muteki_nage=0, muteki_nageX=0 } );
	}
}	


Std_MoveTable.Mv_LastArc_Atk <- 
{
	flags = def_TmplFlags_NoAddComboRate // コンボレートを加算しない
	function Init_Std()
	{
		Battle_Std.InitCharaVector();
		BMvTbl.SetPattern(def_PAT_LastArc_Atk);
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
		
		//1.30からSP技扱いに変更して通常技に相殺されにくく変更
		BMvTbl.SetMvAction( def_MVA_SPSkill );
		Battle_Std.MoveCode.AddFlag( def_MC_Skill|def_MC_SPAction ); // 行動コード		
	}
	function HitInterrupt_Std()
	{
		Battle_Std.SetThrowHitFinalize(256); // ヒット分岐ファイナライズ
	}
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_LastArc_AtkHit"]); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_LastArc_AtkHit <- 
{
	flags = def_TmplFlags_NoAddComboRate // コンボレートを加算しない
	function Init_Std()
	{
		Battle_Std.InitCharaVector();
		BMvEff.ThrowParam( { pattern=620, x=250, y=0 } );
		BMvTbl.SetFinalize(0);
		BMvEff.SetPlayerTimer( { muteki_dage=10, muteki_nage=10, muteki_dageX=10, muteki_nageX=10 } );
		BMvEff.SetExist( { level=_Exist_NoKuraiHantei, mode=_ExistMode_Set } );
		
		Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_SPActionProduction );
	}
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_LastArc_PreHit" );
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_nage=0, muteki_dageX=0, muteki_nageX=0 } );
		BMvEff.SetExist( { level=0 } );
	}	
}

local pat_num_LastArcWhite = BMvEff.GetPatternNum( { datatype=1, pat="LastArcWhite" } );
local pat_num_LastArcWhiteOut = BMvEff.GetPatternNum( { datatype=1, pat="LastArcWhiteOut" } );

Std_MoveTable.Mv_LastArc_PreHit <- 
{
	flags = def_TmplFlags_NoAddComboRate // コンボレートを加算しない
	function Init_Std() : (pat_num_LastArcWhiteOut)
	{
		//シールド成功orA+B+C+Dでくる（事前にLP0にゲージ残量が入っている）
		//60Fの時間停止で画面を真っ白にする
		//真っ白にした後、適当な絵に変更して相手を一発殴ってやられ状態にする
		//そのまま30F待機してから抜ける
		//抜けるときにゲージ残量(LP0)に応じてダメージ補正をかける
		
		Battle_Std.InitCharaVector();
		
		//時間停止しつつ画面を白くしていく
		local draw_effect = 1; // LA確認を素早くやる用
		if( Def_Dbg_LocalDebugMode && Def_Dbg_DebugButtonMode == 10 ) draw_effect = 0;
		if( draw_effect )
		{
			BMvEff.SetStopTime( { time=60, stopme=2, bounderase=1 } ); //時間停止
			BMvEff.CutInProc_Set({ time=[10,999,10], cutin_mv="Mv_IWXCutinGrp", erasetype=1, bgtype=0 }); //カットイングラフィックとか呼び
			
			BMvEff.SetCamera_Focus( { charapos=1, zoom=1.25, time=[30,90+10,0], type_in=3, type_out=1 } ); //カメラ集中テスト
		}
		
		BMvTbl.SetMvAction( def_MVA_SPSkill );
		Battle_Std.MoveCode.AddFlag( def_MC_Skill|def_MC_SPAction ); // 行動コード
		BMvEff.SetPlayerTimer( { muteki_dage=10, muteki_nage=10, muteki_dageX=10, muteki_nageX=10 } );
		BMvEff.SetExist( { level=_Exist_NoHantei, mode=_ExistMode_Set } );
		
		Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_SPActionProduction );
		Battle_Std.SPProduction_AddFlag(def_PP_SPPS_PreLastArc, def_PP_SPPS_Enemy_PreLastArc); // LAカットイン開始
		
		if( draw_effect )
		{
			local eff = BMvEff.CreateObject( { datatype=1, start_pat=pat_num_LastArcWhiteOut } );
			if( eff.push() )
			{
				BMvTbl.SetPrio( _CharaPrio_Near_Layer_0 );
				BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_MoveTimeStopAll|_ObjFlags_NoCamera } );
				BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
				BMvTbl.SetPosition( { x=0, y=0 } );
				
				eff.pop();
			}
		}
			
		
		//KO後にLAするとゲージは減らないけど覚醒が終わってしまうのでチェック
		if( !Battle_Std.RoundisEnd() )
		{
			BMvEff.SpGauge_SetAwakens( 0 );//覚醒終了
		}
		BMvEff.Cockpit_SetPrioU( 1 );//隠れちゃうのでゲージ手前に
		// BSound.BGM_SetFade( { val=50, time=60 } );//BGMのフェード
		
		Battle_Std.TypeSE_Play({ type="ラストアーク成立" });
		BMvEff.AttackInfoString_Set({ word=def_AISW_LASkill,} );	
		
		BSound.SE_Play( { type=_SeType_Normal, num=35 } );//ラストアーク発動SE
		
		//前のMv
		if( BMvTbl.ChangeMv_GetMvName() == "Mv_LastArc" )
		{
			//シールドからのラストアークだ
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_GenFlag );
		}
		
		//LA中の判定などがパートナーにあたると、演出中に相手がでてきてしまう
		//強制的にやられにする判定もあてるとまずいので消す
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			if( BMvCore.GetTagStatus() != -1 )
			{
				local pertner = BMvCore.GetPertnerCharaData();
				if( pertner.push() )
				{
					BMvTbl.SetAliveFlag( { val=0, time=255, flag=_ClearFlag_ChangeMv } );
					
					pertner.pop();
				}
			}
			enemy.pop();
		}
	}
	function Update_Std() : (pat_num_LastArcWhite)
	{
		local mvs = BMvTbl.GetMvStatus();
		// _dpn("count:"+mvs.MvCount);
		if( mvs.MvCount == 5 )
		{
			//時間停止終了後(2Fではなく4F以上にして敵キャラのupdate処理の後にする)
			Battle_Std.InitVector();
			Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_PartnerAtkMvStop );//パートナーの攻撃があったら止めてしまう
			
			// 開始座標を固定にする
			local muki = BMvTbl.GetMuki();
			BMvTbl.SetPosition( { x=-320*128*muki, y=0 } );
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				//念の為ベクトル初期化
				Battle_Std.InitVector();
				
				BMvTbl.SetPosition( { x=320*128*muki, y=0 } );
				enemy.pop();
			}
			
			BMvTbl.SetPattern(def_PAT_SuperMotion);
			BMvEff.ThrowParam( { pattern=620, x=640, y=0 } );
			
			//攻撃判定
			local eff = BMvEff.CreateObject( { datatype=1, start_pat=pat_num_LastArcWhite } );
			if( eff.push() )
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_MoveTimeStopAll } );
				
				eff.pop();
			}
		}
		else if( mvs.MvCount > 30 )
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Skill_LastArc_Hit" );
		BMvTbl.SetPosition( { y=0 } ); // 地面でとったようにする
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_nage=0, muteki_dageX=0, muteki_nageX=0 } );
		BMvEff.SetExist( { level=_Exist_NoKuraiHantei, mode=_ExistMode_Erase } );
		BMvEff.SetExist( { level=0 } );
		BMvEff.SetCamera_Focus( { time=[0,0,0] } ); // カメラ集中の解除
		
		//BMvTbl.SetLP(0,0);//ラストアークのダメージ割合
		local gauge_par = BMvTbl.GetLP(0);
		if( gauge_par > 100 ) gauge_par = 100;
		if( gauge_par <   0 ) gauge_par =   0;
		
		//LAのダメージは6000
		// 0〜100
		//50〜100
		local damage_hosei_par = 80 + (gauge_par*40/100);
		BMvEff.ComboView_Set( { val=damage_hosei_par, type=1 } ); // 乗算
		// _dpn("damage_hosei_par:"+damage_hosei_par+" gauge_par:"+gauge_par);
		
		//途中で抜けたようなときの救済処理
		if( BMvTbl.FromFinalize() == 0 )
		{
			//※ありえないはずだけど、ヤバそうなのだけ念の為入れておく
			//もとに戻す処理
			BMvEff.Cockpit_SetPrioU( 0 );
			BSound.BGM_SetFade( { val=100, time=60 } );
		}
		
		Battle_Std.SPProduction_DelFlag(def_PP_SPPS_PreLastArc, def_PP_SPPS_Enemy_PreLastArc); // LAカットイン開始
	}
}

//シールド成功時に飛んでくるラストアーク
//無理やり掴んで演出を始めてしまう
//このMv名を見て次のMvで処理をしているので注意
Std_MoveTable.Mv_LastArc <-
{
	function Init_Std()
	{
		Battle_Std.InitVector(); // ベクトル全てクリア

		BMvTbl.SetLP(0,0);//LA発動時のゲージ残量
		
		local gauge_par = BMvEff.Liberate_GetTimeValue();
		BMvTbl.SetLP(0,gauge_par);
		
		BMvEff.SetSpGauge( { mode=_SpGauge_UseBuffer } ); //ＳＰゲージ予約分を消費
		BMvEff.Liberate_End(); //開放中なら終了

		local enemy = BMvCore.GetEnemyCharaData();
		local enemy_is_damage = Battle_Std.CheckEnemyisDamage();
		local ret = BMvEff.CapturePlayer( { target = enemy } );
		if( ret == 1 )
		{
			//シールド成功時のLA
			BMvTbl.SetFinalize(256);
			
			if( Def_Sys_CapturePlayerAddMoonIcon && !enemy_is_damage )
			{
				Battle_Std.Moon_AddValue(Def_AttackDamageInitMoonAdd,1);//攻撃初段でのボーナス（パートナー側からの呼び出しも有効）
				
				if( enemy.push() )
				{
					Battle_Std.Moon_AddValue(Def_DamageInitMoonAdd,1);//やられ初段でのボーナス
					enemy.pop();
				}
			}
		}
		else
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_LastArcMiss", [256,"Mv_LastArc_PreHit"]); 
	}
}

//失敗することもあるかもしれない。
//空中シールドもあるしで一旦落下につないでいる
Std_MoveTable.Mv_LastArcMiss <-
{
	function Init_Std()
	{
		BMvTbl.SetPattern(def_PAT_BlastFall);
		Battle_Std.InitVector(); // ベクトル全てクリア
		BMvTbl.SetVector( { addy=250 } );
		BMvEff.SetPlayerTimer( { muteki_dage=254, muteki_dageX=254, muteki_nage=254, muteki_nageX=254 } );
	}
	function Finalize()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

Std_MoveTable.Mv_DyingIWEAtk <-
{
	function Init_Std()
	{
		Battle_Std.MoveCode.AddFlag( def_MC_SPAction ); // 行動コード(ＳＰ)を追加
		
		Battle_Std.SetCharaFlash_LiberateInit(); //光って
		
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Win);	

		Battle_Std.InitVector(); // ベクトル初期化
		BMvTbl.SetPosition( { y=0 } ); // 地面にくっつける
	
		Battle_Std.Reversal.CheckTime_DrawInfo(); // リバーサルなら文字表示
		
		//発動時にGRDは空になります
		local isVorpal = (BMvEff.GRD_GetJudgeResult()>0);
		
		local stock = BMvEff.GRD_CheckStock( { val=-1 } );;
		BMvEff.GRD_UseStock( { val=stock } ); // 全消費
		if( isVorpal )
		{
			BMvEff.GRD_ClearVorpal( 0 ); // ヴォーパルを解除する
		}
		else
		{
			BMvEff.GRD_SetBreak( 0, def_GRDBF_IWE, def_GRDBF_IWE ); // ブレイク
		}
		
		if( Def_Dbg_LocalDebugScriptPath ) //ローカル環境でのデバッグ時
		{
			Battle_Std.DebugFunc.CallAtkInitScript();
		}
		
		BMvEff.SpGauge_SetLimit( { time=def_FL_EXSLimit_IWEAtk } ); //一定時間ゲージ増加に制限をかける
		BMvEff.SetSpGauge( { mode=_SpGauge_UseBuffer } ); 
		
		//EXカットインと時間停止をつける　でも技はSPアクション？
		Battle_Std.Init_ExistAtkSkill(); //SPゲージ消費・カットイン呼び出し
		Battle_Std.MoveCode.AddFlag( def_MC_Skill|def_MC_EXAction ); // 行動コード(必殺技)を設定
		
		Battle_Std.TypeSE_Play({ type="IWE攻撃" });
		
		local muteki_f = 25 + def_FL_EXCutinStopTime;
		BMvEff.SetPlayerTimer( { muteki_nage=muteki_f, muteki_dage=muteki_f, muteki_nageX=muteki_f, muteki_dageX=muteki_f } ); // ちょっと長めに無敵
		
		
		BMvTbl.SetLP(0,0); // ヒットしたかどうか
		BMvTbl.SetLP(1,0); // カットイン消去したかどうか
		
		// ループの抜け先を予約
		local stopframe = BMvEff.GetFrameIDNum( 256 );
		if( stopframe != -1 ) // FrameIDがあるかどうか
		{
			BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Convert, frame=stopframe, rest=8 } );
		}
	}
	function FrameUpdate_Std()
	{
		Battle_Std.CallLoopEndCache_FrameID( def_PAT_Convert, 256, 10 ); // キャッシュ予約Pat, 予約FrameID, 何F毎に呼ぶか

		local mvs = BMvTbl.GetMvStatus(); // ステータス取得
		local mvcount = mvs.MvCount;
		local frameid = mvs.FrameID;
		local mode = BMvTbl.GetLP(0);
		
		if( frameid == 200 ) BMvTbl.JumpFrameID( 100 ); // 無限ループ
		if( mvs.MvCount > (65 + def_FL_EXCutinStopTime) )
		{
			BMvTbl.SetFinalize( 256 ); // 抜ける
		}
		if( mvs.MvCount > (45 + def_FL_EXCutinStopTime) )
		{
			if( BMvTbl.GetLP(0) == 1 )
			{
				BMvTbl.SetFinalize(512);	
			}
		}
		if( mvs.MvCount == (10 + def_FL_EXCutinStopTime ) && mvs.CallCount == 0 ) // 実際には +5Fぐらいの発生になる
		{
			local vo_eff = BMvEff.CreateObject( { x=0, y=-260, mvname="Mv_DyingIWEAtk_AtkEff", datatype=1, start_pat=99, flags=_Position_ToolShift } );
			if( vo_eff.push() )
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_ToParentHitStatus } );
				 
				vo_eff.pop();
			}
		}
		
		if( mvs.MvCount > (25 + def_FL_EXCutinStopTime) )
		{
			if( BMvTbl.GetLP(1) == 0 )
			{
				BMvEff.CutInProc_Erase(); //カットイン消去
				BMvTbl.SetLP(1,1); // 消した記憶
			}		
		}

	}
	function Finalize_Std() // 
	{
		local fc = BMvTbl.GetFinalizeCode(); //今のファイナライズコードを取得
		if( fc != 512 ) // Mv_Skill_IWEXIST 以外
		{
			BMvEff.CutInProc_Erase(); //カットイン消去
		}
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_DyingIWEAtk_Modori"], [512,"Mv_Skill_IWEXIST"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //抜けるときに消す
		if( !BMvTbl.FromFinalize() )
		{
			BMvEff.CutInProc_Erase(); //カットイン消去
		}
	}
}

local patnum_BloodHeatPar = BMvEff.GetPatternNum( { datatype=1, pat="BloodHeatPar" } );
local patnum_HeatPar = BMvEff.GetPatternNum( { datatype=1, pat="HeatPar" } );
local patnum_BloodHeatAnime = BMvEff.GetPatternNum( { datatype=1, pat="BloodHeatAnime" } );
local patnum_HeatAnime = BMvEff.GetPatternNum( { datatype=1, pat="HeatAnime" } );

Std_MoveTable.Mv_SparkHeal <-
{
	function CheckEndTiming()
	{
		Battle_Std.SetPos_MarkingPlayer();
		
		local gauge_st = BtlPt.Liberate_Get();
		
		
		//開放状態が終わったら消えよう
		if( gauge_st == 0 )
		{
			BMvTbl.JumpFrameID(999);
			BMvTbl.SetFinalize(0);
			return;
		}
		else if( Battle_Std.RoundisEnd() )
		{
			BMvTbl.JumpFrameID(999);
			BMvTbl.SetFinalize(0);
			return;
		}
		
		/*
		// SPとかLAになったらヒート状態終わってるはず
		local player = BtlPt.GetPlayerCharaData();
		if( player.push() )
		{
			local mva = BMvTbl.GetMvAction();
			local is_tyouwaza = ( mva == def_MVA_SPSkill || mva == def_MVA_LASkill );
			
			player.pop();
			
			if( is_tyouwaza )
			{
				BMvTbl.JumpFrameID(999);
				BMvTbl.SetFinalize(0);
				return;
			}
		}
		*/
	}
	function Init_Std() : (patnum_HeatAnime,patnum_BloodHeatAnime, val_PowerUpEffectScalePar)
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_MoveTimeStopAll|_ObjFlags_NoRenderOrder } );
		
		local gauge_st = BtlPt.Liberate_Get();
		local use_pat = (gauge_st == _SpGaugeMode_OverLiberate)? patnum_BloodHeatAnime : patnum_HeatAnime;

		BMvTbl.SetPattern( use_pat );
		
		local rand = BMvEff.Random_Limit(val_PowerUpEffectScalePar*10);
		local scale = { x=val_PowerUpEffectScalePar*100+rand, y=val_PowerUpEffectScalePar*100+rand }; //10000で等倍

		BMvTbl.SetScale( { x=scale.x, y=scale.y } );
	}
	function Update_Std() : (patnum_BloodHeatPar, patnum_HeatPar)
	{
		local mvs = BMvTbl.GetMvStatus();
		local tag_st = BtlPt.GetTagStatus();
		if( tag_st == 0 )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
			
			// パートナー側は適当なタイミングの更新でよい
			if( mvs.MvCount%4 == 0 )
			{
				CheckEndTiming();
			}
		}
		else
		{
			BMvEff.EraseObjectFlags( { flags=_ObjFlags_NoRender } );
			CheckEndTiming();
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

local pat_num_UpperCutinBG = BMvEff.GetPatternNum( { datatype=1, pat="UpperCutinBG" } ); // パターン文字列のパターン番号を事前取得

Std_MoveTable.Mv_UpperCutin <-
{
	function Init_Std() : (pat_num_UpperCutinBG)
	{
		BMvTbl.SetPattern(def_PAT_UpperCutin);
		
		local bg = BMvEff.CreateObject( { datatype=1, start_pat=pat_num_UpperCutinBG} );
		if( bg.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll|_ObjFlags_EraseParentPatChange } );
			BMvEff.SetExist( { level = _Exist_NoHantei } );
			BMvTbl.SetPosition( { x=0, y=-281*128 } );
			BMvTbl.SetPrio( _CharaPrio_Parent_M1 );
			
			bg.pop();
		}
		
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( { x=0, y=-281*128 } );

		BMvEff.SetDefaultExtendedEffectDrawing( 0 );//追加効果描画設定
		BMvTbl.SetPrio( _CharaPrio_Parent_BG );
		BMvEff.SetBgPrioEx( { val=1, type=0 } ); //BGのPAniでprio_exを使用するか
	}
	function FrameUpdate_Std()
	{
		if( Battle_Std.CheckPlayerisBound() )
		{
			BMvTbl.SetFinalize();
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		BMvEff.SetBgPrioEx( { val=0, type=0 } ); //BGのPAniでprio_exを使用するか
	}
}

local pat_num_MoonCutinBG = BMvEff.GetPatternNum( { datatype=1, pat="MoonCutinBG" } ); // パターン文字列のパターン番号を事前取得

//ムーンドライブを発動した自分側のカットイン
//この手のカットインはKO後は出ないので、見た目以上のことはしないこと
Std_MoveTable.Mv_MoonCutin <-
{
	function Init_Std() : (pat_num_MoonCutinBG)
	{
		BMvTbl.SetPattern(def_PAT_MoonCutin);
		BMvTbl.SetPrio( _CharaPrio_Parent_BG );
		
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( { x=0, y=-281*128 } );

		BMvEff.SetDefaultExtendedEffectDrawing( 0 );//追加効果描画設定
		
		local bg = BMvEff.CreateObject( { datatype=1, start_pat=pat_num_MoonCutinBG} );
		if( bg.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll|_ObjFlags_EraseParentPatChange } );
			BMvEff.SetExist( { level = _Exist_NoHantei } );
			BMvTbl.SetPosition( { x=0, y=-281*128 } );
			BMvTbl.SetPrio( _CharaPrio_Near_P1 );
			
			bg.pop();
		}
		BMvEff.SetBgPrioEx( { val=1, type=0 } ); //BGのPAniでprio_exを使用するか
	}
	function FrameUpdate_Std()
	{
		//相手を見て・カウンター発動したら消える
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			local emv = BMvTbl.GetMvName();
			enemy.pop();
			
			// _dpn("emv:"+emv);
			if( emv == "Mv_MoonDriveCounter" || Battle_Std.RoundisEnd() )
			{
				BMvTbl.SetFinalize();
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		BMvEff.SetBgPrioEx( { val=0, type=0 } ); //BGのPAniでprio_exを使用するか
	}
}

//ムーンドライブを発動された相手側のカットイン
Std_MoveTable.Mv_MoonCutinEnemy <-
{
	function Init_Std()
	{
		BMvTbl.SetPattern(def_PAT_MoonEnemyCutin);
		BMvTbl.SetPrio( _CharaPrio_Parent_BG );
		
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( { x=0, y=-281*128 } );

		BMvEff.SetDefaultExtendedEffectDrawing( 0 );//追加効果描画設定
		BMvEff.SetBgPrioEx( { val=1, type=0 } ); //BGのPAniでprio_exを使用するか
	}
	function FrameUpdate_Std()
	{
		//自分を見て・カウンター発動したら消える
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			local pmv = BMvTbl.GetMvName();
			player.pop();
			
			// _dpn("pmv:"+pmv);
			if( pmv == "Mv_MoonDriveCounter" || Battle_Std.RoundisEnd() )
			{
				BMvTbl.SetFinalize();
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		BMvEff.SetBgPrioEx( { val=0, type=0 } ); //BGのPAniでprio_exを使用するか
	}
}

//ムーンドライブを発動した自分側のカットイン
Std_MoveTable.Mv_MoonCounterCutin <-
{
	function Init_Std() : (pat_num_MoonCutinBG)
	{
		BMvTbl.SetPattern(def_PAT_MoonCutin);
		BMvTbl.SetPrio( _CharaPrio_Far_Layer_9 );
		
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( { x=0, y=-281*128 } );

		BMvEff.SetDefaultExtendedEffectDrawing( 0 );//追加効果描画設定
		
		local bg = BMvEff.CreateObject( { datatype=1, start_pat=pat_num_MoonCutinBG} );
		if( bg.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
			BMvEff.SetExist( { level = _Exist_NoHantei } );
			BMvTbl.SetPosition( { x=0, y=-281*128 } );
			BMvTbl.SetPrio( _CharaPrio_Near_P1 );
			
			bg.pop();
		}
		BMvEff.SetBgPrioEx( { val=1, type=0 } ); //BGのPAniでprio_exを使用するか
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		BMvEff.SetBgPrioEx( { val=0, type=0 } ); //BGのPAniでprio_exを使用するか
	}
}

//ムーンドライブを発動された相手側のカットイン
Std_MoveTable.Mv_MoonCounterCutinEnemy <-
{
	function Init_Std()
	{
		BMvTbl.SetPattern(def_PAT_MoonEnemyCutin);
		BMvTbl.SetPrio( _CharaPrio_Far_Layer_9 );
		
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( { x=0, y=-281*128 } );

		BMvEff.SetDefaultExtendedEffectDrawing( 0 );//追加効果描画設定
		BMvEff.SetBgPrioEx( { val=1, type=0 } ); //BGのPAniでprio_exを使用するか
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		BMvEff.SetBgPrioEx( { val=0, type=0 } ); //BGのPAniでprio_exを使用するか
	}
}

local pat_num_KakuseiCutinBG = BMvEff.GetPatternNum( { datatype=1, pat="KakuseiCutinBG" } ); // パターン文字列のパターン番号を事前取得

Std_MoveTable.Mv_KakuseiCutin <-
{
	function Init_Std() : (pat_num_KakuseiCutinBG)
	{
		BMvTbl.SetPattern(def_PAT_KakuseiCutin);
		
		local bg = BMvEff.CreateObject( { datatype=1, start_pat=pat_num_KakuseiCutinBG} );
		if( bg.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
			BMvEff.SetExist( { level = _Exist_NoHantei } );
			BMvTbl.SetPosition( { x=0, y=-281*128 } );
			BMvTbl.SetPrio( _CharaPrio_Parent_M1 );
			
			bg.pop();
		}		
		
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( { x=0, y=-281*128 } );

		BMvEff.SetDefaultExtendedEffectDrawing( 0 );//追加効果描画設定
		BMvTbl.SetPrio( _CharaPrio_Parent_M1 ); //BG手前ではなくキャラの後ろに変更
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_BloodCutin <-
{
	function Init_Std()
	{
		BMvTbl.SetPattern(def_PAT_BloodCutin);
		
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( { x=0, y=-281*128 } );

		BMvEff.SetDefaultExtendedEffectDrawing( 0 );//追加効果描画設定
		BMvTbl.SetPrio( _CharaPrio_Parent_BG );
		BMvEff.SetBgPrioEx( { val=1, type=0 } ); //BGのPAniでprio_exを使用するか
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		BMvEff.SetBgPrioEx( { val=0, type=0 } ); //BGのPAniでprio_exを使用するか
	}
}


//パートナー用の処理


//-----------------------------------------------------------------------------
// タッグ
//-----------------------------------------------------------------------------

/*
Mv_〜 : 通常の処理
MainMv_: タッグメイン側の処理
PatMv_ : タッグパートナー側の処理

PPの状態を見てパートナーが自動で動く

親の方でコマンドチェック
　使えるかどうかは、パートナーの行動が完了しているかどうかを見る（パートナーのPPチェック）

呼び出しポーズを取り、PPに値が入る
子はPPを監視してコマンドを成立させる
子のMvが変化したら、PPの値を初期化



*/

/*

*/

local pat_num_P_Walk_F = BMvEff.GetPatternNum( { datatype=0, pat="P_Walk_F" } );

//マーリオゥのシスター用の歩き定義
if( _ChrNo == Def_ChrNo_Chr018 )
{
	Std_MoveTable.PatMv_Walk <-
	{
		function Init_Std() : (pat_num_P_Walk_F)
		{
			// BtlPt.SetMuki_ToPartner();

			BMvTbl.SetPattern(pat_num_P_Walk_F);
			
			BMvTbl.SetLP(0,0); // カウンタ用
			BMvTbl.SetLP(1,0); // 各PATに変わってから何フレーム経過したか
			BMvTbl.SetLP(2,0); // 振り向きカウンタ
		}
		function FrameUpdate_Std()
		{
			BtlPt.NoRenderPartner_EnemySPAction(); //自分と相手の超技中は消す
			BMvTbl.SetMoveableFlag( { move=1, time=32, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); // ループに含める行動可能
			
			local mvs = BMvTbl.GetMvStatus();
			
			//ステージ外にいかないようにする
			local kyori = Battle_Std.GetFrontStageDistance();
			// _dpn("kyori:"+kyori/128);
			if( kyori < 0 )
			{
				BtlPl.SetPos_ExcessGamenHajiX();//はみ出ていたら位置調整
				BMvTbl.SetFinalize(0);//止まる
			}
			
			//救済措置
			// if( mvs.MvCount > 240 || TagFunc.CheckPartnerIsDamage() )
			// {
				// BMvTbl.SetFinalize(0);
				// return;
			// }
			
			//パートナー近くにきたら止まって向き更新
			// local partner = BMvCore.GetPertnerCharaData();
			local target = BMvCore.GetPertnerCharaData();
			if( target.push() )
			{
				local tpos = BMvTbl.GetPosition();
				// partner.pop();
				target.pop();
				
				local posst = BMvEff.GetPointStatus( { position=tpos } );
				local kyori = posst.pos_x*BMvTbl.GetMuki();
				
				//テスト
				local mvs = BMvTbl.GetMvStatus();
				local pat_num = mvs.DataPattern;
				
				local vec = kyori / 30;
				// 0 〜 1000 歩きの範疇
				// 以降はダッシュとして早くしちゃう
				local dash = 0;
				if( abs(vec) <= 1500 || pat_num == 44 )
				{
					//歩き
					if( vec >  1000 ) vec =  1000;//上限
					if( vec < -1000 ) vec = -1000;//上限
				}
				else
				{
					//ダッシュ
					// vec = 2000; //固定?
					if( kyori < 500*128 )
					{
						if( vec >  2000 ) vec =  2000;//上限
						if( vec < -2000 ) vec = -2000;//下限
					}
					else
					{
						//距離が遠いとき
						local pat_count = BMvTbl.GetLP(1);
						if( pat_count < 0 ) pat_count = 0;
						if( pat_count > 30 ) pat_count = 30;
						
						local dash_xvec_max = 2000 + pat_count*150;
						
						if( vec >  dash_xvec_max ) vec =  dash_xvec_max;//上限
						if( vec < -dash_xvec_max ) vec = -dash_xvec_max;//下限
						// _dpn("pat_count:"+pat_count+" dash_xvec_max:"+dash_xvec_max);
					}
					
					dash = 1;
				}
				
				local count = BMvTbl.GetLP(0);
				if( count > 0 )
				{
					BMvTbl.AddLP(0,-1);
				}
				local pat_count = BMvTbl.AddLP(1,1);
				
				//メモ
				// 目標地点はマーリオゥ
				// PATはベクトルに応じて変化する
				// 
				
				local furimuki_target = 0; //0:相手キャラ 1:マーリオゥ
				
				local player_is_damage = Battle_Std.CheckPlayerisBound();//やられ中はマーリオゥの方を向いていたい
				if( player_is_damage )
				{
					furimuki_target = 1;
				}
				
				if( pat_num == 10 || pat_num == 11 )
				{
					local furimuki = 0;
					if( furimuki_target == 0 )
					{
						furimuki = BMvTbl.CheckFurimuki();
					}
					else if( furimuki_target == 1 )
					{
						//マーリオゥとの座標でチェック
						furimuki = BtlPt.CheckFurimuki_ToPartner();
					}
					//TODO:微妙な座標のズレでの振り向きはしないようにしたい
					
					if( furimuki )
					{
						local furimuki_count = BMvTbl.AddLP(2,1);
						// _dpn("furimuki_count:"+furimuki_count);
						
						if( furimuki_count > 30 )
						{
							local set_pat = (pat_num==10)? 11 : 10;
							// _dpn("pat_num:"+pat_num+" set_pat:"+set_pat)
							BMvTbl.SetPattern(set_pat);//XXX
							BMvTbl.SetMuki(_Direction_Auto);//XXX
							BMvTbl.SetLP(1,0); // 各PATに変わってから何フレーム経過したか
							BMvTbl.SetLP(2,0);//振り向きカウンタ
						}
					}
				}
				
				//ダッシュ直後に止まるのはおかしいので一定時間走るのは確定にする？ LP0でテスト updateでカウンタは減らす
				//ダッシュ停止＞ダッシュ停止を繰り返すのがかなりあれ
				//コンボのあと戻ってくるな、そこでとまっててくれ　被弾とか再命令で帰ってくるようにする
				//被コンボ中に歩いてついてくるのがかなりきもい
				//基本的に敵キャラの方を向き続ける

				BMvTbl.SetVector( { x=vec } );
				
				local speed = abs(vec);
				// _dpn("P:"+pat_num+" 距離:"+kyori/128+" speed:"+speed );

				if( dash || count > 0 )
				{
					if( pat_num != 43 )
					{
						BMvTbl.SetPattern(43);
						BMvTbl.SetLP(0,20); // カウンタ用
						BMvTbl.SetLP(1,0); // 各PATに変わってから何フレーム経過したか
						BMvTbl.SetLP(2,0);//振り向きカウンタ
						BtlPt.SetMuki_ToPartner();
					}
				}
				else
				{
					if( pat_num == 43 )
					{
						BMvTbl.SetPattern(44);
						BMvTbl.SetLP(1,0); // 各PATに変わってから何フレーム経過したか
						BMvTbl.SetLP(2,0);//振り向きカウンタ
						// Battle_Std.InitCharaVector();
					}
					else if( pat_num == 44 )
					{
						
					}
					else
					{
						if( vec > 0 )
						{
							if( pat_num != 10 )
							{
								BMvTbl.SetPattern(10);
								BMvTbl.SetLP(1,0); // 各PATに変わってから何フレーム経過したか
								BMvTbl.SetLP(2,0);//振り向きカウンタ
							}
						}
						else
						{
							if( pat_num != 11 )
							{
								BMvTbl.SetPattern(11);
								BMvTbl.SetLP(1,0); // 各PATに変わってから何フレーム経過したか
							}
						}
					}
				}
				
				if( kyori > -60*128 && kyori < 60*128 )
				{
					BMvTbl.SetFinalize(0);
				}
				else
				{
					if( pat_num == 43 || pat_num == 44 )
					{
						// BtlPt.SetMuki_ToPartner( 0, 0, 1, 0 );
					}
					else
					{
						// BtlPt.SetMuki_ToEnemy( 0, 0, 1, 0 );
					}
				}
			}
			
		}
		function Finalize_Std()
		{
			BMvTbl.SetNextMoveTable( "PatMv_WalkStop_F" );
		}
	}

	local pat_num_P_Walk_B = BMvEff.GetPatternNum( { datatype=0, pat="P_Walk_B" } );

	Std_MoveTable.PatMv_WalkStop_F <- // 前進停止
	{
		function Init_Std() : (pat_num_P_Walk_F, pat_num_P_Walk_B)
		{
			local now_pat = BMvTbl.GetMvStatus().DataPattern;
			if( now_pat == pat_num_P_Walk_F || now_pat == pat_num_P_Walk_B )
			{
				Battle_Std.JumpFrameIDEX(256, now_pat, 0); //設定FrameID, 上書きPattern, 失敗時FinalizeCode
			}
			else
			{
				Battle_Std.JumpFrameIDEX(256, pat_num_P_Walk_F, 0); //設定FrameID, 上書きPattern, 失敗時FinalizeCode
				// BMvTbl.SetFinalize(0);//それ以外のPATからきたら即戻していいかな→停止しやすくて弱いので廃止
			}
			Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
			BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		}
		function FrameUpdate_Std()
		{
			BtlPt.NoRenderPartner_EnemySPAction(); //自分と相手の超技中は消す
		}
		function Finalize_Std() // 
		{
			BMvTbl.SetNextMoveTable( "PatMv_Neutral" );
		}
	}
}
else
{
	//ヒスコハ
	Std_MoveTable.PatMv_Walk <-
	{
		function Init_Std() : (pat_num_P_Walk_F)
		{
			BtlPt.SetMuki_ToPartner();
			BMvTbl.SetPattern(pat_num_P_Walk_F);
		}
		function FrameUpdate_Std()
		{
			BtlPt.NoRenderPartner_EnemySPAction(); //自分と相手の超技中は消す
			BMvTbl.SetMoveableFlag( { move=1, time=32, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); // ループに含める行動可能
			
			local mvs = BMvTbl.GetMvStatus();
			
			//ステージ外にいかないようにする
			local kyori = Battle_Std.GetFrontStageDistance();
			// _dpn("kyori:"+kyori/128);
			if( kyori < 0 )
			{
				BtlPl.SetPos_ExcessGamenHajiX();//はみ出ていたら位置調整
				BMvTbl.SetFinalize(0);//止まる
			}
			
			//救済措置
			// if( mvs.MvCount > 240 || TagFunc.CheckPartnerIsDamage() )
			// {
				// BMvTbl.SetFinalize(0);
				// return;
			// }
			
			//パートナー近くにきたら止まって向き更新
			local partner = BMvCore.GetPertnerCharaData();
			if( partner.push() )
			{
				local tpos = BMvTbl.GetPosition();
				partner.pop();
				
				local posst = BMvEff.GetPointStatus( { position=tpos } );
				local kyori = posst.pos_x*BMvTbl.GetMuki();
				
				if( kyori > -240*128 && kyori < 240*128 )
				{
					BMvTbl.SetFinalize(0);
				}
				else
				{
					BtlPt.SetMuki_ToPartner( 0, 0, 1, 0 );
				}
			}
			
		}
		function Finalize_Std()
		{
			BMvTbl.SetNextMoveTable( "PatMv_WalkStop_F" );
		}
	}

	Std_MoveTable.PatMv_WalkStop_F <- // 前進停止
	{
		function Init_Std() : (pat_num_P_Walk_F)
		{
			Battle_Std.JumpFrameIDEX(256, pat_num_P_Walk_F, 0); //設定FrameID, 上書きPattern, 失敗時FinalizeCode
			Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
			BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		}
		function FrameUpdate_Std()
		{
			BtlPt.NoRenderPartner_EnemySPAction(); //自分と相手の超技中は消す
		}
		function Finalize_Std() // 
		{
			BMvTbl.SetNextMoveTable( "PatMv_Neutral" );
		}
	}
	
	
}
//マーリオゥのシスター用の歩き定義


local pat_num_P_ChangeDash = BMvEff.GetPatternNum( { datatype=0, pat="P_ChangeDash" } );

Std_MoveTable.PatMv_ChangeDash <-
{
	function Init_Std() : (pat_num_P_ChangeDash)
	{
		BMvTbl.SetPP(def_PP_TagStatusLast, BMvTbl.GetPP(def_PP_TagStatus) );
		BMvTbl.SetPP(def_PP_TagStatus,0);//初期化
		
		//パートナーの特定の座標に対しての振り向き
		BtlPt.SetMuki_ToPartner( 0, 240, 1, 4200 );

		BMvTbl.SetPattern(pat_num_P_ChangeDash);
	}
	function FrameUpdate_Std()
	{
		BtlPt.NoRenderPartner_EnemySPAction(); //自分と相手の超技中は消す
		local mvs = BMvTbl.GetMvStatus();
		
		//救済措置
		if( mvs.MvCount > 240 || BtlPt.CheckPartnerIsDamage() )
		{
			BMvTbl.SetFinalize(0);
			return;
		}
		
		//走ってる
		local partner = BMvCore.GetPertnerCharaData();
		if( partner.push() )
		{
			local tpos = BMvTbl.GetPosition();
			local pmuki = BMvTbl.GetMuki();
			partner.pop();
			
			local offx = 240; // タッチ時の距離感
			local marginx = 50; // どれくらいのズレを許容するか
			tpos.x+= (offx*pmuki*128);
			local posst = BMvEff.GetPointStatus( { position=tpos } );
			local kyori = posst.pos_x*BMvTbl.GetMuki();
			
			if( kyori > -marginx*128 && kyori < marginx*128 )
			{
				// _dpn("範囲内なので手をあげてタッチ準備");
				BMvTbl.SetFinalize(100);
			}
			else
			{
				BtlPt.SetMuki_ToPartner( 0, offx, 1, 4200 );
			}
		}
	}
	function Finalize_Std()
	{
		Battle_Std.SwitchNextMoveTable("PatMv_ChangeDashStop", [100,"PatMv_ChangeTouch"] ); //デフォ,[code,mv]...
	}
}

local pat_num_P_ChangeDashStop = BMvEff.GetPatternNum( { datatype=0, pat="P_ChangeDashStop" } );

Std_MoveTable.PatMv_ChangeDashStop <-
{
	function Init_Std() : (pat_num_P_ChangeDashStop)
	{
		BMvTbl.SetPattern(pat_num_P_ChangeDashStop);
	}
	function FrameUpdate_Std()
	{
		BtlPt.NoRenderPartner_EnemySPAction(); //自分と相手の超技中は消す
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "PatMv_Neutral" );
	}
}

local getVoiceFileNameParam = function( mvname )
{
	local Voice = {};
	Voice.Init <- mvname+"_Init";
	Voice.FU <- mvname+"_FU";
	
	return Voice;
}


//交代技
local voice_params = getVoiceFileNameParam("PatMv_ChangeTouch");

local pat_num_P_ChangeTouch = BMvEff.GetPatternNum( { datatype=0, pat="P_ChangeTouch" } );

//控え側のタッチ待ち
Std_MoveTable.PatMv_ChangeTouch <-
{
	function Init_Std() : (voice_params, pat_num_P_ChangeTouch)
	{
		// 操作側は必殺技として動作するが
		// こっちはシステム行動として通常技や必殺技の共通初期化処理を通らないので注意
		BMvTbl.SetPattern(pat_num_P_ChangeTouch);
		
		BMvTbl.SetLP(0,0);//交代までいったかどうか 0:まだ 10:交代後 -1:失敗
		
		local ppos = BtlPt.GetPartnerPosition( 240 );
		BMvTbl.SetPosition( { x=ppos.x } );
		BtlPt.SetMuki_ToPartner();//親の方を向く
		
		Battle_Std.TypeSE_Play({ type=voice_params.Init }); //発動ボイス
		
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
	}
	function FrameUpdate_Std() : (voice_params)
	{
		Battle_Std.TypeSE_Play({ type=voice_params.FU }); //FU中ボイス

		BtlPt.NoRenderPartner_EnemySPAction(); //自分と相手の超技中は消す
		//
		if( BMvTbl.GetLP(0)==0 )
		{
			if( BtlPt.CheckPartnerIsDamage() )
			{
				BMvTbl.SetLP(0,-1);//失敗
				BMvTbl.JumpFrameID(900);
			}
		}
	}
	function Finalize_Std()
	{
		//BtlPt.Change.FrameUpdateでFinalizeCodeは設定される
		Battle_Std.SwitchNextMoveTable("PatMv_Neutral", [256,"Mv_Neutral"] ); //デフォ,[code,mv]...
	}
}

//タッグの214攻撃の生成
local maketmpl_PatMv_Atk = function( param={} ) : (getVoiceFileNameParam)
{
	local ret_mv = {};
	
	local mv_param = {
		pattern = "P_AtkA",
		voice_base = "PatMv_AtkA",
		bc_move = 0,
		check_ptmv = 0, //中下のハメを起こさないチェック。呼び出しのMVと不一致のときにしゃがみガード可能にする
		check_haji_pl_shift = 0, // 端で隙間がなくて挙動がおかしいのをプレイヤー側でも修正する
		add_move = 0, // 追加行動
		dash_checkkyori = 250, // ダッシュ中に近くにきたらFrameIDジャンプ
		no_screenout = 0, // 画面外にいかないようにする
		auto_muki = 1, // 発動時に振り向きを行うか

		player_mvname = 0, // ↓とあわせて使う
		pass_hitstatus = 0, // ヒット情報をプレイヤーに伝えるか 1:伝える
		
		flash_endtiming = 0, // 技終了時にエフェクトを出す
		is_ex_skill = 0, //EX技扱い
		
		whiff_partnermuteki = 0, //パートナー攻撃無敵にスカる　デフォ1でいいと思うけど影響範囲を狭めてる
	}
	
	switch( param.type )
	{
	case "A":
		mv_param.pattern = "P_AtkA";
		mv_param.voice_base = "PatMv_AtkA";
		mv_param.player_mvname = "Mv_Skill_M_214A";
		mv_param.pass_hitstatus = 1;
		break;
	case "B":
		mv_param.pattern = "P_AtkB";
		mv_param.voice_base = "PatMv_AtkB";
		mv_param.player_mvname = "Mv_Skill_M_214B";
		mv_param.pass_hitstatus = 1;
		break;
	case "C":
		mv_param.pattern = "P_AtkC";
		mv_param.voice_base = "PatMv_AtkC";
		break;
	case "HisuiC"://琥珀操作時214Cの翡翠攻撃
		mv_param.pattern = "P_AtkC";
		mv_param.voice_base = "PatMv_AtkC";
		mv_param.check_ptmv = { len=500*128, mv="Mv_Skill_M_214C" }; // 中下同時を不可に
		mv_param.check_haji_pl_shift = 1;
		break;
	case "BC":
		mv_param.bc_move = 1;
		mv_param.pattern = "P_AtkBC";
		mv_param.voice_base = "PatMv_AtkBC";
		break;

	case "SisterA":
		mv_param.pattern = "P_AtkA";
		mv_param.voice_base = "PatMv_AtkA";
		mv_param.dash_checkkyori = 400;
		mv_param.no_screenout = 1;
		mv_param.player_mvname = "Mv_Skill_236A";
		mv_param.pass_hitstatus = 1;
		mv_param.flash_endtiming = 1;
		mv_param.whiff_partnermuteki = 1;
		break;
	case "SisterB":
		mv_param.pattern = "P_AtkB";
		mv_param.voice_base = "PatMv_AtkB";
		mv_param.no_screenout = 1;
		mv_param.player_mvname = "Mv_Skill_236B";
		mv_param.pass_hitstatus = 1;
		mv_param.flash_endtiming = 1;
		mv_param.flash_endtiming = 1;
		mv_param.whiff_partnermuteki = 1;
		break;
	case "SisterB_Add":
		mv_param.pattern = "P_AtkA_Add";
		mv_param.voice_base = "PatMv_AtkB_Add";
		mv_param.add_move = 1;
		mv_param.no_screenout = 1;
		mv_param.auto_muki = 0; // 派生は振り向きなし
		mv_param.player_mvname = "Mv_Skill_236B_Add";
		mv_param.pass_hitstatus = 1;
		mv_param.flash_endtiming = 1;
		mv_param.whiff_partnermuteki = 1;
		break;
	case "SisterB_Add_Add":
		mv_param.pattern = "P_AtkA_Add_Add";
		mv_param.voice_base = "PatMv_AtkB_Add_Add";
		mv_param.add_move = 1;
		mv_param.auto_muki = 0; // 派生は振り向きなし
		mv_param.player_mvname = "Mv_Skill_236B_Add_Add";
		mv_param.pass_hitstatus = 1;
		// mv_param.no_screenout = 1;//効果なし
		mv_param.flash_endtiming = 1;
		mv_param.whiff_partnermuteki = 1;
		break;
	case "SisterEX":
		mv_param.pattern = "P_AtkEX";
		mv_param.voice_base = "PatMv_AtkEX";
		mv_param.no_screenout = 1;
		mv_param.player_mvname = "Mv_Skill_236EX";
		mv_param.pass_hitstatus = 1;
		mv_param.flash_endtiming = 1;
		mv_param.is_ex_skill = 1;
		break;
	case "SisterBC":
		mv_param.bc_move = 1;
		mv_param.pattern = "P_AtkBC";
		mv_param.voice_base = "PatMv_AtkBC";
		mv_param.no_screenout = 1;
		mv_param.player_mvname = "Mv_Skill_236BC";
		mv_param.pass_hitstatus = 1;
		mv_param.flash_endtiming = 1;
		mv_param.whiff_partnermuteki = 1;
		break;
	}
	
	local voice_params = getVoiceFileNameParam( mv_param.voice_base );
	
	local pat_num_AttackPattern = BMvEff.GetPatternNum( { datatype=0, pat=mv_param.pattern } );
	
	ret_mv.Init_Std <- function() : (mv_param, voice_params, pat_num_AttackPattern)
	{
		Battle_Std.InitCharaVector();
		Battle_Std.ClearHitStatus_SetChangeMv(); // ヒット情報のクリア
		
		BMvTbl.SetPP(def_PP_TagStatusLast, BMvTbl.GetPP(def_PP_TagStatus) );
		BMvTbl.SetPP(def_PP_TagStatus,0);//初期化

		BMvTbl.AddPP(def_PP_TagMove,1);//行動中
		
		if( Battle_Std.CheckEnemyDistance(50) )
		{
			if( Def_Sys_CheckHajiHisKohZureShift && mv_param.check_haji_pl_shift )
			{
				//自分が画面端背負いで敵も画面端背負いで、プレイヤーが敵と密着していたとき
				local kyori_m = Battle_Std.GetBackStageDistance();
				
				local player = BMvCore.GetPertnerCharaData();
				if( player.push() )
				{
					local enemy = BMvCore.GetEnemyCharaData();
					if( enemy.push() )
					{
						local kyori_e = Battle_Std.GetBackStageDistance();
						enemy.pop();
						
						local posst = BMvEff.GetPointStatus( { target=enemy } );
						local kyori = posst.pos_x*BMvTbl.GetMuki();
						
						if( kyori_m == 0 && kyori_e == 0 )
						{
							if( kyori <= 150*128 )
							{
								_dpn("パートナーで押し出す分の距離を確保する:"+kyori/128 );
								BMvTbl.SetPosition( { x=-50*128, flags=_Position_Add|_Position_ChangeMuki } );//少しズラす
							}
						}
					}
					player.pop();
				}
			}

			// 近くに敵がいると重なり判定が出現してズルっといくので、すり抜けにくく座標調整をする
			// 親> <敵 <自
			// 親> 自> <敵
			// 上記2パターン以外作らないようにするためには、敵が近いときは今の向きより少し後退すれば良い
			// 近くにいて後退しておかしくなるケースはないはずなので、距離が近いときにやるだけで良さそう
			// 前歩き中とかだと向きがおかしいので、振り向きが必要な場合は反転する
			
			local muki = BMvTbl.GetMuki(); // 今の向き
			if( BMvTbl.CheckFurimuki() ) muki = muki * -1; // 反転
			
			BMvTbl.SetPosition( { x=-50*128*muki, flags=_Position_Add } );
		}

		BMvTbl.SetPattern( pat_num_AttackPattern );
		
		if( mv_param.auto_muki )
		{
			BMvTbl.SetMuki(_Direction_Auto);//敵の方を向く
		}
		
		BMvTbl.SetLP(0,0);//交代までいったかどうか 0:まだ 10:交代後　※未使用の模様、ここはキャラ別で使うので触らない
		
		BMvTbl.SetLP(1,0);//上段にする処理をやるかどうか
		BMvTbl.SetLP(2,0);//上段にする処理のカウントダウン
		BMvTbl.SetLP(3,0);//パートナー行動の変化記憶用

		// BMvTbl.SetLP(0,0);//翡翠4BCや琥珀などで使用中
		// BMvTbl.SetLP(1,0);//翡翠4BCで使用中
		// BMvTbl.SetLP(9,0);//翡翠4BCで使用中
		
		// local ppos = BtlPt.GetPartnerPosition( 240 );
		// BMvTbl.SetPosition( { x=ppos.x } );
		// BtlPt.SetMuki_ToPartner();//親の方を向く
		
		BMvTbl.SetAliveFlag( { val=1, time=255, flag=_ClearFlag_ChangeMv } );
		
		Battle_Std.TypeSE_Play({ type=voice_params.Init }); //発動ボイス
		
		Battle_Std.MoveCode.AddFlag( def_MC_Skill ); // 行動コード(必殺技)を設定
		if( mv_param.is_ex_skill )
		{
			Battle_Std.MoveCode.AddFlag( def_MC_Skill|def_MC_EXAction ); // 行動コード(EX必殺技)を設定
			
			BMvTbl.SetMvAction( def_MVA_EXSkill );
			BMvTbl.SetVsAtkValue( { type=0, val=def_SVAV_EXSkill, time=9999, flag=_ClearFlag_ChangeMv } );
		}
		
		if( mv_param.bc_move )
		{
			Battle_Std.MoveCode.AddFlag( def_MC_BCAction ); // 行動コード(ムーンスキル)を設定
			BMvTbl.SetMvAction( def_MVA_BCSkill );
			local moonVsAtkVal = ( Def_Sys_BossChara_MoonSkillVsAtkType && BMvCore.GetBossFlag() != 0 )? def_SVAV_NmSkill : def_SVAV_BCSkill; // ボスMSが強すぎる問題対策
			BMvTbl.SetVsAtkValue( { type=0, val=moonVsAtkVal, time=9999, flag=_ClearFlag_ChangeMv } );
		}

		Battle_Std.SetSkillMvChipDamage(); // 必殺技としての削りダメージを適用
		Battle_Std.SetVsAtkValueFromMvActionCode(); // MvActionCodeを見てVSダメージ削り値を設定
		
		if( mv_param.add_move )
		{
			Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_AddMv );//追加技扱い
		}
		
		//ヒット情報の伝達。操作キャラの行動動変化でもフラグを強制リセット
		if( mv_param.pass_hitstatus )
		{
			//ヒット情報をパートナーに伝える
			BMvTbl.SetPartnerFlag({ val = _PartnerFlag_ToParentHitStatus, time = 254, flag=_ClearFlag_ChangeMv } );
		}
		
		if( mv_param.whiff_partnermuteki )
		{
			BMvTbl.SetHitCheckFlag( { type=1, val=Def_HitCheckFlag_Partner, time=255, flag=_ClearFlag_ChangeMv } ); // パートナー攻撃無敵にスカる技
		}
	}
	ret_mv.FrameUpdate_Std <- function() : (voice_params, mv_param)
	{
		if( mv_param.bc_move )
		{
			Battle_Std.UpdateMoonSkillEffect(1);
		}
		
		if( mv_param.pass_hitstatus )
		{
			if( BMvTbl.GetLP(3) == 0 ) // 未処理
			{
				//パートナーが指定の行動でなくなったらヒットやヒットストップを伝えるのを消さないとバグる
				local partner = BMvCore.GetPertnerCharaData();
				if( partner.push() )
				{
					local pmvname = BMvTbl.GetMvName();
					
					partner.pop();
					
					if( pmvname != mv_param.player_mvname )
					{
						_dpn("別行動に移動したので全部消す");
						BMvTbl.SetPartnerFlag({ val = _PartnerFlag_ToParentHitStatus|_PartnerFlag_ToParentHitStop, time = 0 } );//これで消す
						BMvTbl.SetLP(3,1);//処理完了
					}
				}
			}
		}
		
		//自分と相手にラストアークなどの強制終了フラグがたってたら終わる
		if( BtlPt.CheckPartnerAtkStopFlag() )
		{
			BMvTbl.SetFinalize(100);
		}
		
		//相手キャラが超技の演出中（LAヒットやロック技のAD中）は終わる
		if( Battle_Std.CheckEnemyIsSPActionProduction() )
		{
			BMvTbl.SetFinalize(100);
		}

		Battle_Std.TypeSE_Play({ type=voice_params.FU }); //FU中ボイス
		
		//ダッシュ中に相手が近くになったら攻撃に進む
		local mvs = BMvTbl.GetMvStatus();
		
		if( mvs.Param1&4 )
		{
			/*
			// 発生保障フレームのデバッグ表示用
			local partner = BMvCore.GetPertnerCharaData();
			if( partner.push() )
			{
				local p_mvs = BMvTbl.GetMvStatus();
				
				partner.pop();
				local mvs = BMvTbl.GetMvStatus();

				_dpn("保証なしF:"+p_mvs.MvCount+" -> "+mvs.MvCount);
			}
			*/
			
			//Param1&4:被弾で止まる
			if( BtlPt.CheckPartnerIsDamage() )
			{
				BMvTbl.SetFinalize(100);
			}
		}
		
		if( mvs.Param1&1 )
		{
			//Param1&1:ダッシュ中
			if( Battle_Std.CheckEnemyDistance( mv_param.dash_checkkyori ) )
			{
				BMvTbl.JumpFrameID(200);
			}
		}

		if( mvs.Param1&2 )
		{
			//Param1&2:ダッシュ終了後飛び先数F（攻撃前）
			//MvCountが少ない時は被弾で止まる
			if( BtlPt.CheckPartnerIsDamage() && mvs.MvCount <= 8 )
			{
				BMvTbl.SetFinalize(100);
			}
		}

		if( mv_param.no_screenout )
		{
			//画面外にいきそうなら座標調整
			//自分の移動速度も多少考慮する
			local vec = BMvTbl.GetVector( { flags=_Vector_Normal } );
			local xvec = vec.x;
			// _dpn("vec:"+vec.x);
			if( xvec > 3000 ) xvec = 3000;
			if( xvec <    0 ) xvec = 0;
			BtlPl.SetPos_ExcessGamenHajiX( { off_x=32*128+xvec, flags=4 } );//dofileタイミング的にdef_SetPos_FrontOnlyが使えないので直値
		}
		
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 200:
			break;
		}
		
		if( mv_param.check_ptmv && BMvTbl.GetLP(1)==0 )
		{
			//中下のハメをなくす(21/10/07)
			//呼び出し元の行動が不一致になったら上段に書き換える保険処理
			local player = BMvCore.GetPertnerCharaData();
			if( player.push() )
			{
				local mvname = BMvTbl.GetMvName();
				player.pop();
				
				local posst = BMvEff.GetPointStatus( { target=player } ); // パートナーとの距離情報取得
				local kyori = abs(posst.distance_x)/128;
				// _dpn("距離:"+kyori );
				
				if( mvname != mv_param.check_ptmv.mv && kyori <= 450 )
				{
					//別の行動にうつった
					// _dpn("別の行動にうつって距離も近いので指定F後にしゃがみガード可能に変更");
					BMvTbl.SetLP(1,1); // チェック処理終わり
					BMvTbl.SetLP(2,3); // 指定F後に上段化する(5F下段に合わせるには2Fマージン必要)
				}
			}
		}
	}
	ret_mv.Update_Std <- function() : (mv_param)
	{
		//中下のハメをなくす(21/10/07)
		if( mv_param.check_ptmv && BMvTbl.GetLP(2) > 0 )
		{
			local cnt = BMvTbl.AddLP(2,-1);
			// _dpn("cnt:"+cnt);
			if( cnt <= 0 )
			{
				// _dpn("上段になる");
				BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_GuardCrouch, time=64, flag=_ClearFlag_ChangeMv } );
			}
		}
	}
	ret_mv.Finalize_Std <- function() : (mv_param)
	{
		Battle_Std.SwitchNextMoveTable("PatMv_Neutral", [100,"PatMv_AtkStop"] ); //デフォ,[code,mv]...
		
		//マーリオゥのシスター専用処理
		if( mv_param.flash_endtiming )
		{
			// BMvEff.SetCharaFlash( { color = 0x555555, type = 0, time = 20 } );
			// エフェクト
			local eff = BMvEff.CreateObject( { start_pat=112, x=0, y=-250*128 } );
		}
	}
	ret_mv.LastUpdate_Std <- function() : (mv_param)
	{
		BMvTbl.AddPP(def_PP_TagMove,-1);//行動中-1
		
		if( mv_param.bc_move )
		{
			BMvEff.PcAfterImage_Clear();
		}
	}
	
	return ret_mv;
}	

//ここで分岐するのちょっと違和感あるけど、余計な定義が入るよりは良いかな
//XXX:シスターはそもそも別関数にするべきな気はする…
if( _ChrNo == Def_ChrNo_Chr018 )
{
	Std_MoveTable.PatMv_AtkA <- maketmpl_PatMv_Atk( { type="SisterA" } );
	Std_MoveTable.PatMv_AtkB <- maketmpl_PatMv_Atk( { type="SisterB" } );
	Std_MoveTable.PatMv_AtkEX <- maketmpl_PatMv_Atk( { type="SisterEX" } );
	Std_MoveTable.PatMv_AtkBC <- maketmpl_PatMv_Atk( { type="SisterBC" } );
	Std_MoveTable.PatMv_AtkB_Add <- maketmpl_PatMv_Atk( { type="SisterB_Add" } );
	Std_MoveTable.PatMv_AtkB_Add_Add <- maketmpl_PatMv_Atk( { type="SisterB_Add_Add" } );
	
}
else if( _ChrNo == Def_ChrNo_Chr001 )
{
	Std_MoveTable.PatMv_AtkA <- maketmpl_PatMv_Atk( { type="A" } );
	Std_MoveTable.PatMv_AtkB <- maketmpl_PatMv_Atk( { type="B" } );	
	Std_MoveTable.PatMv_AtkC <- maketmpl_PatMv_Atk( { type="HisuiC" } );
	Std_MoveTable.PatMv_AtkBC <- maketmpl_PatMv_Atk( { type="BC" } );
}
else
{
	Std_MoveTable.PatMv_AtkA <- maketmpl_PatMv_Atk( { type="A" } );
	Std_MoveTable.PatMv_AtkB <- maketmpl_PatMv_Atk( { type="B" } );
	Std_MoveTable.PatMv_AtkC <- maketmpl_PatMv_Atk( { type="C" } );
	Std_MoveTable.PatMv_AtkBC <- maketmpl_PatMv_Atk( { type="BC" } );
}


local pat_num_P_GroBlocked = BMvEff.GetPatternNum( { datatype=0, pat="P_GroBlocked" } );

// PatMv_AtkStop というMvNameを見て琥珀などのオブジェクトを止めているので変更しないこと
Std_MoveTable.PatMv_AtkStop <-
{
	function Init_Std() : (pat_num_P_GroBlocked)
	{
		//地上のときは地上やられ系に
		//BCMDTbl.CheckPosState(_PosState_Ground)をしたいが、被弾時に浮くようにしたいので全部空中判定になってるのでダメ
		if( BMvTbl.GetPosition().y >= 0 )
		{
			local vec = BMvTbl.GetVector( { flags=_Vector_Normal } );
			Battle_Std.InitVector();//ベクトル初期化
			BMvTbl.SetPattern(pat_num_P_GroBlocked);
			local xvec = vec.x * 80 / 100;
			local xmax = 2500;
			if( xvec >  xmax ) xvec =  xmax;
			if( xvec < -xmax ) xvec = -xmax;
			
			//ズザーっと動いたりする
			BMvTbl.SetVector( { x=xvec, addx=-xvec/10, flags=_Vector_Div } );
		}
		else
		{
			Battle_Std.InitVector();//ベクトル初期化
			BMvTbl.SetPattern(def_PAT_AirRecovery);
			BMvTbl.SetVector( { x=0, y=-1500, addy=200, flags=_Vector_Normal } );
		}
		Battle_Std.PlayerSE_StopLastPlaySound(); // 攻撃音声を止める
	}
	function FrameUpdate_Std()
	{
		BtlPt.NoRenderPartner_EnemySPAction(); //自分と相手の超技中は消す
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "PatMv_Neutral" );
	}
}

// 翡翠だったり琥珀だったりから呼ばれる
// 汎用オブジェクトデータ
// 交代で消滅

// 回復時間は280F固定で、回復量は今までの回復量に応じて変わる
// 1500以上は回復しない
local heal_status = [
{ limit =  800, hp = 500 },
{ limit = 1200, hp = 400 },
{ limit = 1500, hp = 300 },
{ limit = 2000, hp = 200 },
]

Std_MoveTable.PatMv_HealObject <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetLP(0,0); // 今回の回復量の合計
		BMvTbl.SetLP(1,0); // 毎フレームの回復量を計算する用
	}
	function Update_Std() : (heal_status)
	{
		local mvs = BMvTbl.GetMvStatus();
		local mvcount = mvs.MvCount;
		
		local start_time = 45;//交代して即回復開始はしない
		local heal_time = 280;//回復時間
		
		// 今までの回復量の合計に応じて回復速度が変わっていく
		local total_heal = BMvTbl.GetPP(defc_PP_Chr001_Chr004_TotalHealVal);
		local use_heal_st = 0;
		for( local i=0; i<heal_status.len(); i++ )
		{
			if( heal_status[i].limit > total_heal )
			{
				//_dpn(i+"ので決定");
				use_heal_st = heal_status[i];
				break;
			}
		}
		
		if( use_heal_st == 0 || mvcount > start_time + heal_time || Battle_Std.RoundisEnd() )
		{
			BMvTbl.SetFinalize();
		}
		else if( mvcount >= start_time )
		{
			//回復中
			local frame_add_heal_val = 0; //このフレームの回復量
			
			local hp = BMvEff.SetHpGauge( { value=0 } );
			local hp_souse = BMvEff.SetHpGauge( { value=0, valuetype=2 } );

			local aka_damage = hp_souse - hp; // 赤ダメ残量
			// _dpn("aka_damage:"+aka_damage);
			if( aka_damage <= 0 )
			{
				// _dpn("回復エリアがないので終わり");
				frame_add_heal_val = 0;
				BMvTbl.SetFinalize();
				return;
			}
			
			if( mvcount == start_time + heal_time )
			{
				// 最終フレームで少数的な部分で切り捨てにあった値の帳尻あわせをする
				local total_heal_hp = BMvTbl.GetLP(0); // 今まで追加した回復量
				if( use_heal_st.hp > total_heal_hp ) // 足りてない
				{
					frame_add_heal_val = use_heal_st.hp - total_heal_hp;
					// _dpn("帳尻:"+frame_add_heal_val );
				}
			}
			else
			{
				local calc_add_hp = use_heal_st.hp * 1000 / heal_time;
				local calc_heal = BMvTbl.AddLP(1,calc_add_hp)
				// _dpn("use_heal_st.hp:"+use_heal_st.hp+" calc_add_hp:"+calc_add_hp+" calc_heal:"+calc_heal);
				
				// 毎フレームの回復量を足していきたいが、小数になることがあるので
				// 100倍した回復量をLPに加算していく
				// LPが100を超えていた＝1以上の回復となったら、100の位を捨てた余りをLPにSetして
				// 捨てた分が回復量になる
				
				if( calc_heal > 1000 )
				{
					local amari = calc_heal%1000;
					BMvTbl.SetLP(1,amari);
					
					frame_add_heal_val = (calc_heal - amari)/1000;
				}
			}
			
			// 色々あって計算の結果回復量があったら、実際に加算する
			if( frame_add_heal_val > 0 )
			{
				/*
				// 保険処理をやるまでもない
				local total_heal_hp = BMvTbl.GetLP(0);
				local yotei_total_heal_hp = total_heal_hp + frame_add_heal_val; // 予定
				if( yotei_total_heal_hp > use_heal_st.hp )
				{
					// _dpn("保険処理:"+frame_add_heal_val );
					frame_add_heal_val = (yotei_total_heal_hp - use_heal_st.hp);
				}
				*/
				
				local total_heal_hp = BMvTbl.AddLP(0,frame_add_heal_val);//今回の合計回復量
				local all_total = BMvTbl.AddPP(defc_PP_Chr001_Chr004_TotalHealVal,frame_add_heal_val); // プレイの回復量合計
				
				// _dpn(format("回復中...:%3d %4d %4d %4d",mvcount-start_time, total_heal_hp, all_total, BMvTbl.GetLP(1) ) );
				BMvEff.SetHpGauge( { value=frame_add_heal_val, valuetype=0 } );//赤ダメ部分を回復
				
				if( total_heal_hp >= use_heal_st.hp )
				{
					_dpn("回復終わり");
					BMvTbl.SetFinalize();
				}
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//パートナー関連


//

Std_MoveTable.Mv_Null_ResetCamera <-
{
	function Init_Std()
	{
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 1 )
		{
			BMvEff.ResetViewCamera();
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				local pos = BMvTbl.GetPosition( 0 );
				BMvEff.SetCamera_Focus( { x=pos.x, y=pos.y, zoom=1.0, time=[0,0,0] } );
				
				player.pop();
			}
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//次のフレームに暗転キャラに打撃無敵をつける
Std_MoveTable.Mv_Null_SetNextMutekiObject <-
{
	function Init_Std()
	{
		// BMvTbl.SetLP(0,0);// 生成時にセットされる暗転時間
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 1 )
		{
			if( Battle_Std.CheckPlayerisBound() )
			{
				BMvTbl.SetFinalize(0);
				return;
			}

			local anten_frame = (BMvTbl.GetLP(0) - 1); // 1F後なので暗転フレームも-1される
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				BMvEff.SetPlayerTimer( { muteki_dage=anten_frame, muteki_dageX=anten_frame } );
				
				player.pop();
			}
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//BC技の残像管理
Std_MoveTable.Mv_MoonSkillAfterImageObject <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPosition( { y=1024, flags=_Position_CaptureShift } );
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount < 2 )
		{
			//Initでやると他の残像消去で消される可能性があるので念入りにやる
			//オブジェクト側で読んでもプレイヤーに行きます
			BMvEff.PcAfterImage_Set( { type=1, range=14, delay=3, color=0xFF55CCFF, blendmode=1 } );
		}
		local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		if( player.push() )
		{
			local is_moon_skill = Battle_Std.MoveCode.CheckFlag( def_MC_BCAction );

			player.pop();
		
			if( !is_moon_skill )	
			{
				BMvTbl.SetFinalize(0);
				return;
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		BMvEff.PcAfterImage_Clear();
	}
}

//自分の超技演出中持続して消えるだけのオブジェクト
//パートナーを非表示にするために使用
//20220304:自分のパートナーも非表示にするように修正
Std_MoveTable.Mv_SPActionProductionCheckObject <-
{
	function SetPartnerRender( core, render=1 )
	{
		if( core.push() )
		{
			local tagStatus = BMvCore.GetTagStatus();//-1:通常 1:タッグのメイン 0:タッグのパートナー
			if( tagStatus == 1 )
			{
				local pertner = BMvCore.GetPertnerCharaData();
				if( pertner.push() )
				{
					if( render )
					{
						//表示=非表示をerase
						BMvEff.EraseObjectFlags( { flags=_ObjFlags_NoRender } );
					}
					else
					{
						//非表示=非表示をset
						BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
					}
					pertner.pop();
				}
			}
			core.pop();
		}

	}
	function SetRender_AnyPartner( render=1 )
	{
		//敵と自分のパートナーを表示したり非表示にしたりする
		SetPartnerRender( BMvCore.GetEnemyCharaData(), render );
		SetPartnerRender( BMvCore.GetPlayerCharaData(), render );
	}
	function SetSpGaugeZeroTime_Enemy( time = 0 )
	{
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			BMvEff.SpGauge_SetZeroTime( { time=time } );
			
			enemy.pop();
		}
	}
	function DelProductionFlag()
	{
		local flag = BMvTbl.GetLP(1); // def_PP_GS_ArcDriveProductionとか
		local enemy_flag = BMvTbl.GetLP(2); // def_PP_GS_ArcDriveProductionとか
		Battle_Std.SPProduction_DelFlag(flag, enemy_flag);
	}
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPosition( { y=1024, flags=_Position_CaptureShift } );
		
		SetRender_AnyPartner( 0 ); // 自分と相手のパートナーの表示をなくす
		
		// BMvTbl.SetLP(0,0); // 演出中相手のゲージ増加に制限をかけるかどうか（生成時に指定）
		// BMvTbl.SetLP(1,0); // 終了時に初期化するフラグ（生成時に指定）
		// BMvTbl.SetLP(2,0); // 終了時に初期化する相手のフラグ（生成時に指定）
	}
	function Update_Std()
	{
		local isSpProduction = 0;
		local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		if( player.push() )
		{
			if( Battle_Std.MoveCodeEx.CheckFlag( 3, def_MC3_SPActionProduction ) )
			{
				isSpProduction = 1;
			}
			player.pop();
		}
		
		if( BMvTbl.GetLP(0)==1 )// 演出中相手のゲージ増加に制限をかけるかどうか（生成時に指定）
		{
			SetSpGaugeZeroTime_Enemy( 60 ); // 一定時間相手のゲージを増えないようにする
		}

		// _dpn("isSpProduction:"+isSpProduction);
		if( !isSpProduction )	
		{
			BMvTbl.SetFinalize(0);
			DelProductionFlag();
			return;
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		SetRender_AnyPartner( 1 ); // 自分と相手のパートナーを表示する
		
		DelProductionFlag(); // 念のため
		
		if( BMvTbl.GetLP(0)==1 )// 演出中相手のゲージ増加に制限をかけるかどうか（生成時に指定）
		{
			SetSpGaugeZeroTime_Enemy( 60 ); // 一定時間相手のゲージを増えないようにするを初期化
		}
	}
}

// 相殺成功時に呼ばれて、相殺中に付与する無敵状態を無敵として扱わなくするフラグを付けたり消したりする
Std_MoveTable.Mv_Null_DelSousaiMutekiFlag <-
{
	function Init_Std()
	{
		BMvTbl.AddPP(def_PP_SousaiMutekiFlagMngNum,1); // 加算
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			Battle_Std.MoveCodeEx.AddFlag( 6, def_MC6_SousaiMuteki );
			
			player.pop();
		}
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 4 ) // 3Fだと弾相殺前MDで引っかかる
		{
			// _dpn("終了");
			BMvTbl.SetFinalize( 0 );
			return;
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		local leftNum = BMvTbl.AddPP(def_PP_SousaiMutekiFlagMngNum,-1); // 減算　残り監視オブジェクト数を取得
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			local isMuteki = BMvEff.GetPlayerMuteki( 0 ); // 打撃無敵
			if( leftNum <= 0 || !isMuteki ) // 万が一残り続けるのも嫌なので保険で無敵がなかったらフラグは消す
			{
				// _dpn("フラグ削除");
				Battle_Std.MoveCodeEx.DelFlag( 6, def_MC6_SousaiMuteki );
			}
			
			player.pop();
		}
	}
}

// 終了命令
// Battle_Std.MakeMv.LastCharaAnimeEnd();

//ロックつかみ中の汎用やられ動き定義
Std_MoveTable.Mv_CmnAniSet_AtamaYarareC <- Battle_Std.MakeMv.SetCaptureCharaAnime2( { animation = [
	{ Data = [606,1,5], },
	{ Data = [606,1,5], Vector={ x=-1500,y=0,addx=100,addy=0,flags=_Vector_Normal }, },
	{ Data = [606,0,7], },
	{ Data = [606,1,7], }
	{ Data = [606,2,5], },
	{ Data = [606,3,5], },
	{ Data = [606,4,5], Vector=0, RelJump = 0 },
] } );

Std_MoveTable.Mv_CmnAniSet_AtamaYarareD <- Battle_Std.MakeMv.SetCaptureCharaAnime2( { animation = [
	{ Data = [606,1,5], },
	{ Data = [606,1,8], Vector={ x=-2000,y=0,addx=100,addy=0,flags=_Vector_Normal }, },
	{ Data = [606,0,9], },
	{ Data = [606,1,9], }
	{ Data = [606,2,7], },
	{ Data = [606,3,7], },
	{ Data = [606,4,7], Vector=0, RelJump = 0 },
] } );

Std_MoveTable.Mv_CmnAniSet_HaraYarareC <- Battle_Std.MakeMv.SetCaptureCharaAnime2( { animation = [
	{ Data = [607,1,5], },
	{ Data = [607,1,5], Vector={ x=-1500,y=0,addx=100,addy=0,flags=_Vector_Normal }, },
	{ Data = [607,0,7], },
	{ Data = [607,1,7], }
	{ Data = [607,2,5], },
	{ Data = [607,3,5], },
	{ Data = [607,4,5], Vector=0, RelJump = 0 },
] } );

Std_MoveTable.Mv_CmnAniSet_HaraYarareD <- Battle_Std.MakeMv.SetCaptureCharaAnime2( { animation = [
	{ Data = [607,1,5], },
	{ Data = [607,1,8], Vector={ x=-2000,y=0,addx=100,addy=0,flags=_Vector_Normal }, },
	{ Data = [607,0,9], },
	{ Data = [607,1,9], }
	{ Data = [607,2,7], },
	{ Data = [607,3,7], },
	{ Data = [607,4,7], Vector=0, RelJump = 0 },
] } );


Std_MoveTable.Mv_CmnAniSet_CrouchYarareC <- Battle_Std.MakeMv.SetCaptureCharaAnime2( { animation = [
	{ Data = [608,1,5], },
	{ Data = [608,1,5], Vector={ x=-1500,y=0,addx=100,addy=0,flags=_Vector_Normal }, },
	{ Data = [608,0,7], },
	{ Data = [608,1,7], }
	{ Data = [608,2,5], },
	{ Data = [608,3,5], },
	{ Data = [608,4,5], Vector=0, RelJump = 0 },
] } );

Std_MoveTable.Mv_CmnAniSet_UeUkiC <- Battle_Std.MakeMv.SetCaptureCharaAnime2( { animation = [
	{ Data = [620,0,5], },
	{ Data = [620,0,8], Vector={ x=-900,y=-3000,addx=0,addy=150,flags=_Vector_Normal }, },
	{ Data = [620,1,7], },
	{ Data = [620,2,7], }
	{ Data = [620,3,5], },
	{ Data = [620,4,5], },
	{ Data = [620,5,5], RelJump = 0 },
] } );

Std_MoveTable.Mv_CmnAniSet_UkiC <- Battle_Std.MakeMv.SetCaptureCharaAnime2( { animation = [
	{ Data = [620,0,5], },
	{ Data = [620,0,5], Vector={ x=-1500,y=-2200,addx=0,addy=150,flags=_Vector_Normal }, },
	{ Data = [620,1,7], },
	{ Data = [620,2,7], }
	{ Data = [620,3,5], },
	{ Data = [620,4,5], },
	{ Data = [620,5,5], RelJump = 0 },
] } );



Std_MoveTable.Mv_CmnAniSet_UkiD <- Battle_Std.MakeMv.SetCaptureCharaAnime2( { animation = [
	{ Data = [620,0,5], },
	{ Data = [620,0,8], Vector={ x=-2500,y=-3200,addx=0,addy=150,flags=_Vector_Normal }, },
	{ Data = [620,1,9], },
	{ Data = [620,2,9], }
	{ Data = [620,3,7], },
	{ Data = [620,4,7], },
	{ Data = [620,5,7], RelJump = 0 },
] } );

Std_MoveTable.Mv_CmnAniSet_FukitobiF <- Battle_Std.MakeMv.SetCaptureCharaAnime2( { animation = [
	{ Data = [620,0,5], },
	{ Data = [620,0,6], Vector={ x=-5000,y=-10000,addx=0,addy=150,flags=_Vector_Normal }, },
	{ Data = [620,1,6], },
	{ Data = [620,2,4], RelJump = 0 },
] } );


Std_MoveTable.Mv_CmnAniSet_UtuFumiC <- Battle_Std.MakeMv.SetCaptureCharaAnime2( { animation = [
	{ Data = [660,0,5], Vector={ x=0, y=0, addx=0, addy=0, flags=_Vector_Normal }, },
	{ Data = [660,1,4], },
	{ Data = [660,2,4], },
	{ Data = [660,3,4], RelJump = 0 },
] } );

//その場で落下のアニメをするだけ
Std_MoveTable.Mv_CmnAniSet_UtuRakka <- Battle_Std.MakeMv.SetCaptureCharaAnime2( { animation = [
	{ Data = [621,0,5], },
	{ Data = [621,1,5], },
	{ Data = [621,2,5], },
	{ Data = [621,3,5], RelJump = 0 },
] } );

Std_MoveTable.Mv_CmnAniSet_Kuzure <- Battle_Std.MakeMv.SetCaptureCharaAnime2( { animation = [
	{ Data = [627,0,9], },
	{ Data = [627,1,5], },
	{ Data = [628,0,5], },
	{ Data = [628,1,5], },
	{ Data = [660,0,5], },
	{ Data = [660,1,5], },
	{ Data = [660,2,5], },
	{ Data = [660,3,5], },
	{ Data = [660,4,5], RelJump = 0 },
] } );


// スロー的に腹やられで待機
Std_MoveTable.Mv_CmnAniSet_HaraKeep <- Battle_Std.MakeMv.SetCaptureCharaAnime2( { animation = [
	{ Data = [607,1,10], },
	{ Data = [607,1,10], Vector={ x=-1000,y=0,addx=100,addy=0,flags=_Vector_Normal }, },
	{ Data = [607,0,10], Vector=0 },
	{ Data = [607,1,10], }
	{ Data = [607,2,10], },
	{ Data = [607,3,10], },
	{ Data = [607,4,10], Vector=0, RelJump = 0 },
] } );

Std_MoveTable.Mv_CmnAniSet_SuiMotiage <- Battle_Std.MakeMv.SetCaptureCharaAnime2( { animation = [
	{ Data = [630,0,10], },
	{ Data = [630,1,15], Vector={ x=0,y=-800,addx=0,addy=50,flags=_Vector_Normal }, },
	{ Data = [630,2,15], Vector={ x=0,y=-200,addx=0,addy=5,flags=_Vector_Normal } },
	{ Data = [630,2,15], },
	{ Data = [630,3,10], RelJump = 0 },
] } );

//とまるだけ
Std_MoveTable.Mv_CmnAniSet_AirBoundKeep <- Battle_Std.MakeMv.SetCaptureCharaAnime2( { animation = [
	{ Data = [620,0,10], Vector=0 },
	{ Data = [630,0,10], RelJump = 0 },
] } );

//きりもみループでじわっと浮き
//フィニッシュなど
Std_MoveTable.Mv_CmnAniSet_Kirimomi <- Battle_Std.MakeMv.SetCaptureCharaAnime2( { animation = [
	{ Data = [634,1,3], Vector={ x=0, y=-128, addx=0, addy=0, flags=_Vector_Normal } },
	{ Data = [634,2,3], },
	{ Data = [634,3,3], },
	{ Data = [634,4,3], RelJump = -3 },
] } );

//超技のあととかつかみ開放に繋ぐ
Std_MoveTable.Mv_CmnAniSet_NanameUkiFinish <- Battle_Std.MakeMv.SetCaptureCharaAnime2( { animation = [
	{ Data = [620,0,7], },
	{ Data = [620,0,10], Vector={ x=-3500,y=-4500,addx=0,addy=250,flags=_Vector_Normal }, },
	{ Data = [620,1,30], RelJump = 0 },
] } );

//定義したテーブルを返す
return Std_MoveTable;

}//end


// 壁激突やられベクトルを返す
function Battle_Std::GetWallBoundVector()
{
	return 255; // 文字列でも大丈夫
}
